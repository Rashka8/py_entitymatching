

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>py_entitymatching 0.4.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> py_entitymatching
          

          
          </a>

          
            
            
              <div class="version">
                0.4
              </div>
            
          

          

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-how_to_guide">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/whatisnew">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/installation">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#platforms">Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#c-compiler-required">C Compiler Required</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#installing-using-pip">Installing Using pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#installing-from-source-distribution">Installing from Source Distribution</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/overview">Overview of Supported EM Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#supported-em-problem-scenarios">Supported EM Problem Scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#two-fundamental-steps-in-the-em-process-blocking-and-matching">Two Fundamental Steps in the EM Process: Blocking and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#supported-em-workflows">Supported EM Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#the-development-and-production-stages">The Development and Production Stages</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#the-focus-of-the-current-package">The Focus of the Current Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/guides">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#a-quick-tour-of-jupyter-notebook">A Quick Tour of Jupyter Notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#end-to-end-em-workflows">End-to-End EM Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#stepwise-guides">Stepwise Guides</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/datastructures">Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#storing-tables-using-pandas-dataframes">Storing Tables Using Pandas Dataframes</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#storing-metadata-using-a-catalog">Storing Metadata Using a Catalog</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/steps_supp_em_workflows">Steps of Supported EM Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/read_csv_files">Reading the CSV Files from Disk</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/down_sampling">Down Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/profiling">Profiling Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#example-usage">Example Usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/data_exploration">Data Exploration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#openrefine">OpenRefine</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#pandastable">Pandastable</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/blocking">Specifying Blockers and Performing Blocking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#types-of-blockers-and-blocker-hierarchy">Types of Blockers and Blocker Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#built-in-blockers">Built-In Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#blackbox-blockers">Blackbox Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#rule-based-blockers">Rule-Based Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#combining-multiple-blockers">Combining Multiple Blockers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/create_feats_for_blocking">Creating Features for Blocking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#available-tokenizers-and-similarity-functions">Available Tokenizers and Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#obtaining-tokenizers-and-similarity-functions">Obtaining Tokenizers and Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#obtaining-attribute-types-and-correspondences">Obtaining Attribute Types and Correspondences</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#getting-a-set-of-features">Getting a Set of Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#adding-removing-features">Adding/Removing Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#summary-of-the-manual-feature-generation-process">Summary of the Manual Feature Generation Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ways-to-edit-the-manual-feature-generation-process">Ways to Edit the Manual Feature Generation Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#generating-features-automatically">Generating Features Automatically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/debugging_blocking">Debugging Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/sampling">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/labeling">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/split_train_test">Splitting Labeled Data into Training and Testing Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/create_feats_for_matching">Creating Features for Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-the-features-manually">Creating the Features Manually</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-the-features-automatically">Creating the Features Automatically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/extract_feat_vecs">Extracting Feature Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/imputing_missing_values">Imputing Missing Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/matching">Specifying Matchers and Performing Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ml-matchers">ML-Matchers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#rule-based-matchers">Rule-Based Matchers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/select_best_matcher">Selecting a ML-Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/debugging_matcher">Debugging ML-Matchers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#debugging-using-the-gui">Debugging Using the GUI</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#debugging-using-the-command-line">Debugging Using the Command Line</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#impact-of-imputing-missing-values">Impact of Imputing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/matchercombiner">Combining Predictions from Multiple Matchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/triggers">Using Triggers to Update Matching Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#match-triggers">Match Triggers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/evaluate_matching">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/misc">Miscellaneous</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#csv-format">CSV Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#metadata-file-format">Metadata File Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#writing-a-dataframe-to-disk-along-with-its-metadata">Writing a Dataframe to Disk Along With Its Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#writing-reading-other-types-of-py-entitymatching-objects">Writing/Reading Other Types of py_entitymatching Objects</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/api/overview">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/api/actual_commands">Commands in py_entitymatching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/reading_and_writing_data">Reading and Writing Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/loading_and_saving_objects">Loading and Saving Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/handling_metadata">Handling Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/downsampling">Downsampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/data_exploration">Data Exploration</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/blocking">Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/debugging_blocker_output">Debugging Blocker Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/combining_blocker_outputs">Combining Blocker Outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/sampling">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/labeling">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/handling_features">Handling Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/creating_the_features_automatically">Creating the Features Automatically</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/creating_the_features_manually">Creating the Features Manually</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/adding_features">Adding Features to Feature Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/extracting_feature_vectors">Extracting Feature Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/imputing_missing_values">Imputing Missing Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_similarity_functions">Supported Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_tokenizers">Supported Tokenizers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/matching">Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/splitting_data_into_train_test">Splitting Data into Train and Test</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_matchers">Supported Matchers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/selecting_matcher">Selecting Matcher</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/debugging_matcher">Debugging Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/triggers">Triggers</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/evaluating_the_matching_output">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#experimental-commands">Experimental Commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/dask_commands">Commands Implemented Using Dask</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#downsampling">Downsampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#blocking">Blocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#extracting-feature-vectors">Extracting Feature Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ml-matchers">ML-Matchers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/tuners">Tuners for the Dask-based Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#downsampling">Downsampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#overlap-blocker">Overlap Blocker</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/combiner">Matcher Combiner</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">How to Contribute</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-contributing">Contributing to py_entitymatching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#where-to-start">Where to start?</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#bug-reports-and-enhancement-requests">Bug reports and enhancement requests</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#working-with-the-code">Working with the code</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#version-control-git-and-github">Version control, Git, and GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#getting-started-with-git">Getting started with Git</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#forking">Forking</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-a-branch">Creating a branch</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-a-development-environment">Creating a development environment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-to-the-documentation">Contributing to the documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#about-the-py-entitymatching-documentation">About the <em>py_entitymatching</em> documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#how-to-build-the-py-entitymatching-documentation">How to build the <em>py_entitymatching</em> documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-to-the-code-base">Contributing to the code base</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#code-standards">Code standards</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#writing-tests">Writing tests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-your-changes-to-py-entitymatching">Contributing your changes to <em>py_entitymatching</em></a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#committing-your-code">Committing your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#combining-commits">Combining commits</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#pushing-your-changes">Pushing your changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#review-your-code">Review your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#finally-make-the-pull-request">Finally, make the pull request</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#delete-your-merged-branch-optional">Delete your merged branch (optional)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">py_entitymatching</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>py_entitymatching 0.4.0 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-manual-for-py-entitymatching">
<h1>User Manual for py_entitymatching<a class="headerlink" href="#user-manual-for-py-entitymatching" title="Permalink to this headline">¶</a></h1>
<p>This document explains how to install, use, and contribute to the package.</p>
</div>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-how_to_guide"></span><div class="section" id="how-to-guide-to-do-entity-matching">
<h2>How to Guide To Do Entity Matching<a class="headerlink" href="#how-to-guide-to-do-entity-matching" title="Permalink to this headline">¶</a></h2>
<p>The initial draft of the how to guide to do entity matching can be found <a class="reference external" href="http://pradap-www.cs.wisc.edu/magellan/how-to-guide/how_to_guide_magellan.pdf">here.</a></p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/whatisnew"></span><div class="section" id="what-is-new">
<h2>What is New?<a class="headerlink" href="#what-is-new" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Compared to Version 0.3.3, the followings are new:</dt><dd><ul class="simple">
<li><p>Dropped support for Python 2 and 3.5.</p></li>
<li><p>To support Python 3.8, updated the function
<code class="code docutils literal notranslate"><span class="pre">py_entitymatching.matcher.matcherutils.impute_table()</span></code> to use current
scikit-learn’s <code class="code docutils literal notranslate"><span class="pre">SimpleImputer</span></code>; see <a class="reference internal" href="singlepage.html#imputing-missing-values"><span class="std std-ref">Imputing Missing Values</span></a> for correct
usage.</p></li>
</ul>
</dd>
</dl>
</div>
<span id="document-user_manual/installation"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Python 2.7, 3.5, 3.6, 3.7, or 3.8</p></li>
</ul>
</div>
<div class="section" id="platforms">
<h3>Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h3>
<p>py_entitymatching has been tested on Linux (Ubuntu Xenial 16.04.6), macOS (High Sierra 10.13.6),
and Windows 10.</p>
</div>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>pandas (provides data structures to store and manage tables)</p></li>
<li><p>scikit-learn (provides implementations for common machine learning algorithms)</p></li>
<li><p>joblib (provides multiprocessing capabilities)</p></li>
<li><p>pyqt5 (provides tools to build GUIs)</p></li>
<li><p>py_stringsimjoin (provides implementations for string similarity joins)</p></li>
<li><p>py_stringmatching (provides a set of string tokenizers and string similarity functions)</p></li>
<li><p>cloudpickle (provides functions to serialize Python constructs)</p></li>
<li><p>pyprind (library to display progress indicators)</p></li>
<li><p>pyparsing (library to parse strings)</p></li>
<li><p>six (provides functions to write compatible code across Python 2 and 3)</p></li>
<li><p>xgboost (provides an implementation for xgboost classifier)</p></li>
<li><p>pandas-profiling (provides implementation for profiling pandas dataframe)</p></li>
<li><p>pandas-table (provides data exploration tool for pandas dataframe)</p></li>
<li><p>openrefine (provides data exploration tool for tables)</p></li>
<li><p>ipython (provides better tools for displaying tables in notebooks)</p></li>
<li><p>scipy (dependency for skikit-learn)</p></li>
</ul>
<p>See the <cite>project README &lt;https://github.com/anhaidgroup/py_entitymatching/blob/master/README.rst&gt;</cite>
for more information.</p>
</div>
<div class="section" id="c-compiler-required">
<h3>C Compiler Required<a class="headerlink" href="#c-compiler-required" title="Permalink to this headline">¶</a></h3>
<p>Installing Using conda
Before installing this package, you need to make sure that you have a C compiler installed. This is necessary because this package contains Cython files. Go <a class="reference external" href="https://sites.google.com/site/anhaidgroup/projects/magellan/issues">here</a> for more information about how to check whether you already have a C compiler and how to install a C compiler. After you have confirmed that you have a C compiler installed, you are ready to install py_entitymatching.</p>
</div>
<div class="section" id="installing-using-pip">
<h3>Installing Using pip<a class="headerlink" href="#installing-using-pip" title="Permalink to this headline">¶</a></h3>
<p>To install the package using pip, execute the following
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span> <span class="n">py_entitymatching</span>
</pre></div>
</div>
<p>The above command will install py_entitymatching and all of its dependencies except
XGBoost, pandastable, openrefine, and PyQt5. This is because pip can only install the
dependency packages that are available in PyPI and PyQt5, XGBoost, pandastable are not
in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
</div>
<div class="section" id="installing-from-source-distribution">
<h3>Installing from Source Distribution<a class="headerlink" href="#installing-from-source-distribution" title="Permalink to this headline">¶</a></h3>
<p>Clone the py_entitymatching package from GitHub</p>
<blockquote>
<div><p>git clone  <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching.git">https://github.com/anhaidgroup/py_entitymatching.git</a></p>
</div></blockquote>
<p>Then,  execute the following commands from the package root:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>which installs py_stringmatching into the default Python directory on your machine. If you do not have installation permission for that directory then you can install the package in your
home directory as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>For more information see this StackOverflow <a class="reference external" href="http://stackoverflow.com/questions/14179941/how-to-install-python-packages-without-root-privileges">link</a>.</p>
<p>The above commands will install py_entitymatching and all of its
dependencies, except PyQt5 and XGBoost.</p>
<p>This is  because, similar to pip, setup.py can only install the dependency packages
that are available in PyPI and PyQt5, pandastable, XGBoost are not in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching supports a set of experimental commands that help users
create an EM workflow. Some of these commands will require installing Dask. To
install dask refer to this <a href="#id8"><span class="problematic" id="id9">`page &lt;http://dask.pydata.org/en/latest/install.html`_</span></a>.</p>
</div>
</div>
</div>
<span id="document-user_manual/overview"></span><div class="section" id="overview-of-supported-em-processes">
<h2>Overview of Supported EM Processes<a class="headerlink" href="#overview-of-supported-em-processes" title="Permalink to this headline">¶</a></h2>
<p>In this section we provide a high-level overview of the EM processes supported by
py_entitymatching. For more details, please read the document “How-To Guide to Entity Matching”
(will soon be available from the package website).</p>
<div class="section" id="supported-em-problem-scenarios">
<h3>Supported EM Problem Scenarios<a class="headerlink" href="#supported-em-problem-scenarios" title="Permalink to this headline">¶</a></h3>
<p>Entity matching (EM) has many problem variations: matching two tables, matching within a
single table, matching from a table into a knowledge base, etc. The package currently only
support matching two tables. Specifically, given two tables A and B of relational tuples,
find all tuple pairs (a in A, b in B) such that a and b refer to the same real-world
entity. The following figure shows an example of matching persons between two given tables.</p>
<a class="reference internal image-reference" href="_images/example-match-two-tables.png"><img alt="'An example of matching two tables'" class="align-center" src="_images/example-match-two-tables.png" style="width: 300.0px; height: 120.0px;" /></a>
<p>Of course, if you want to match tuples within a single table X, you can also use
the package, by matching X with X (you do not have to create another copy of X,
just provide X twice as the input if a command in the package requires two tables A
and B as the input).</p>
</div>
<div class="section" id="two-fundamental-steps-in-the-em-process-blocking-and-matching">
<h3>Two Fundamental Steps in the EM Process: Blocking and Matching<a class="headerlink" href="#two-fundamental-steps-in-the-em-process-blocking-and-matching" title="Permalink to this headline">¶</a></h3>
<p>In practice, tables A and B can be quite large, such as having 100K tuples each, resulting
in 10 billions tuple pairs across A and B. Trying to match all of these pairs is clearly
very expensive. Thus, in such cases the user often employs domain heuristics to quickly
remove obviously non-matched pairs, in a step called <em>blocking</em>, before matching the
remaining pairs, in a step called <em>matching</em>.</p>
<p>The following figure illustrates the above two fundamental steps. Suppose that we are
matching the two tables A and B in (a), where each tuple describes a person. The blocking
step can use a heuristic such as “if two tuples do not agree on state, then they cannot
refer to the same person” to quickly remove all such tuple pairs (this is typically
done using indexes, so the blocking step does not have to enumerate all tuple pairs
between A and B). In other words, the blocking step retains only the four tuple pairs
that agree on state, as shown in (b). The matching step in (c) then considers only these
tuple pairs and predicts for each of them a label “match” or “not-match”
(shown as “+” and “-” in the figure).</p>
<a class="reference internal image-reference" href="_images/example-blocking-matching.png"><img alt="'An example of blocking and matching'" class="align-center" src="_images/example-blocking-matching.png" style="width: 500.0px; height: 220.0px;" /></a>
</div>
<div class="section" id="supported-em-workflows">
<h3>Supported EM Workflows<a class="headerlink" href="#supported-em-workflows" title="Permalink to this headline">¶</a></h3>
<p>The current package supports EM workflows that consist of a blocking step followed by a matching step. Specifically, the package provides a set of blockers and a set of matchers (and the user can easily write his or her own blocker/matcher). Given two tables A and B to be matched, the user applies a blocker to the two tables to obtain a set of tuple pairs, then applies a matcher to these pairs to predict “match” or “no-match”. The user can use multiple blockers in the blocking step, and can combine them in flexible ways. The figure below illustrates both cases.</p>
<a class="reference internal image-reference" href="_images/example-workflow.png"><img alt="'An example of EM workflow'" class="align-center" src="_images/example-workflow.png" style="width: 617.5px; height: 90.25px;" /></a>
<p>Further, the current package supports both rule-based and learning-based matchers. Specifically, rule-based matchers will require the user to write domain specific match rules and learning-based matchers  will require the user to label a set of tuple pairs (as “match” or “no-match”), then use the labeled data to train matchers. In the future, we will consider extending the package to support more powerful EM workflows, such as using multiple matchers, or being able to add rules to process the output of the matchers.</p>
</div>
<div class="section" id="the-development-and-production-stages">
<h3>The Development and Production Stages<a class="headerlink" href="#the-development-and-production-stages" title="Permalink to this headline">¶</a></h3>
<p>In practice EM is typically carried out in two stages. In the development stage, the user tries to find an accurate EM workflow, often using data samples. In the production stage, the user then executes the discovered workflow on the entirety of data. The following figure illustrates the development stage, which is the focus of the current package. The figure also highlights the steps of the development stage that the current package supports.</p>
<p>In the figure, suppose we want to match two tables A and B, each having 1 million tuples. Trying to explore and discover an accurate workflow using these two tables would be too time consuming, because they are too big. Hence, the user will first “down sample” the two tables to obtain two smaller versions, shown as Tables A’ and B’ in the figure, each having 100K tuples, say (see the figure).</p>
<a class="reference internal image-reference" href="_images/example-dev-stage.png"><img alt="'An example of the development stage'" class="align-center" src="_images/example-dev-stage.png" style="width: 500.0px; height: 300.0px;" /></a>
<p>Next, suppose the package provides two blockers X and Y. Then the user will experiment with these blockers (for example, executing both on Tables A’ and B’ and examining their output) to select the blocker judged the best (according to some criterion). Suppose the user selects blocker X. Then next, he or she executes X on Tables A’ and B’ to obtain a set of candidate tuple pairs C.</p>
<p>Next, the user takes a sample S from C, and labels the pairs in S as “match” or “no-match” (see the figure). Let the labeled set be G, and suppose the package provides two matchers U and V. Suppose further that U and V are learning-based matchers (for example, one uses decision trees and the other uses logistic regression). Then in the next step, the user will use the labeled set G to perform cross validation for U and V. Suppose V produces higher matching accuracy (such as F1 score of 0.93, see the figure). Then the user will select V as the matcher, then apply V to the set C to predict “match” or “no-match”, shown as “+” or “-” in the figure. Finally, the user may perform quality check (by examining a sample of the predictions), then go back and debug and modify the previous steps as appropriate. This continues until the user is satisfied with the accuracy of the EM workflow.</p>
<p>Once the user has been satisfied with the EM workflow, the production stage begins. In this stage the user will execute the discovered workflow on the original tables A and B. Since these tables are very large, scaling is a major concern (and is typically solved using Hadoop or Spark). Other concerns include quality monitoring, exception handling, crash recovery, etc.</p>
</div>
<div class="section" id="the-focus-of-the-current-package">
<h3>The Focus of the Current Package<a class="headerlink" href="#the-focus-of-the-current-package" title="Permalink to this headline">¶</a></h3>
<p>The current py_entitymatching package focuses on helping the user with the development stage, that is, help him or her discover an accurate EM workflow. In the future, we will extend the package to also help the user with the production stage.</p>
</div>
</div>
<span id="document-user_manual/guides"></span><div class="section" id="guides">
<h2>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h2>
<p>The goal of this page  is to give you some concrete examples for using py_entitymatching.
These are examples with sample data that is already bundled along with the package. The
examples are in the form of Jupyter notebooks.</p>
<div class="section" id="a-quick-tour-of-jupyter-notebook">
<h3>A Quick Tour of Jupyter Notebook<a class="headerlink" href="#a-quick-tour-of-jupyter-notebook" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/index.html">This tutorial</a>
gives a quick tour on installing and using Jupyter notebook.</p>
</div>
<div class="section" id="end-to-end-em-workflows">
<h3>End-to-End EM Workflows<a class="headerlink" href="#end-to-end-em-workflows" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>EM workflow with blocking using a overlap blocker and matching using Random Forest
matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%201.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using a overlap blocker, selecting among multiple matchers,
using the selected matcher to predict matches, and evaluating the predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%202.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using multiple blockers (overlap and attribute equivalence
blocker), debugging the blocker output, selecting among multiple matchers, debugging the
matcher output, using the selected matcher to predict matches, and evaluating the
predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%203.ipynb">Jupyter notebook</a></p></li>
</ul>
</div>
<div class="section" id="stepwise-guides">
<h3>Stepwise Guides<a class="headerlink" href="#stepwise-guides" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Reading CSV files from disk: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Reading%20CSV%20Files%20from%20Disk.ipynb">Jupyter notebook</a></p></li>
<li><p>Down sampling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Down%20Sampling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data profiling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Profiling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data exploration: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Exploration.ipynb">Jupyter notebook</a></p></li>
<li><p>Blocking:</p>
<blockquote>
<div><ul class="simple">
<li><p>Using overlap blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Overlap%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using attribute equivalence blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Attr.%20Equivalence%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using rule-based blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Rule-Based%20Blocking.ipynb">Jupyter notebook</a></p></li>
<li><p>Using blackbox blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Blackbox%20Blocker.ipynb">Jupyter notebook</a></p></li>
<li><p>Combining multiple blockers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Combining%20Multiple%20Blockers.ipynb">Jupyter notebook</a></p></li>
<li><p>Debugging blocker output: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Debugging%20Blocker%20Output.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Handling features:</p>
<blockquote>
<div><ul class="simple">
<li><p>Generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Editing attribute types and generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Editing%20and%20Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Adding features to feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Adding%20Features%20to%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
<li><p>Removing features from feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Removing%20Features%20From%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Sampling and labeling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Sampling%20and%20Labeling.ipynb">Jupyter notebook</a></p></li>
<li><p>Matching:</p>
<blockquote>
<div><ul class="simple">
<li><p>Selecting the best learning-based matcher (involves splitting the labeled data, generating features,
instantiating multiple matchers, debugging the matcher output): <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Selecting%20the%20Best%20Learning%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Performing matching using rule-based matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Matching%20with%20a%20Rule-Based%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Improving matching results using triggers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Using%20Match%20Triggers%20to%20Improve%20Results.ipynb">Jupyter notebook</a></p></li>
<li><p>Evaluating the predictions from a matcher:  <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Evaluating%20the%20Selected%20Matcher.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<span id="document-user_manual/datastructures"></span><div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p>In py_entitymatching, we will need to store many tables and metadata associated
with it. It is important for you to know the data structures that are used to store
the tables and the metadata, so that you can manipulate them based on your need.</p>
<p>As a convention, we will use:</p>
<ul class="simple">
<li><p>A and B to refer to the original two tables to be matched,</p></li>
<li><p>C to refer to the candidate set table obtained from A and B after the blocking step,</p></li>
<li><p>S to refer to a sample taken from C, and</p></li>
<li><p>G to refer to a table that contains the tuple pairs in S and a golden label for each
pair (indicating the pair as matches or non-matches).</p></li>
</ul>
<div class="section" id="storing-tables-using-pandas-dataframes">
<h3>Storing Tables Using Pandas Dataframes<a class="headerlink" href="#storing-tables-using-pandas-dataframes" title="Permalink to this headline">¶</a></h3>
<p>We will need to store a lot of data as tables in py_entitymatching. We use pandas Dataframes to
represent tables (you can read more about pandas and pandas Dataframes <a class="reference external" href="http://pandas.pydata.org/">here</a>).</p>
<p><strong>Tuple:</strong> We often refer to a row of a table as tuple. Each tuple is just a row
in a Dataframe and this is of type pandas Series (you can read more about pandas Series
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html">here</a>).</p>
</div>
<div class="section" id="storing-metadata-using-a-catalog">
<h3>Storing Metadata Using a Catalog<a class="headerlink" href="#storing-metadata-using-a-catalog" title="Permalink to this headline">¶</a></h3>
<p><strong>Bare Minimum that You Should Know:</strong>
In py_entitymatching, we need to store a lot of metadata with a table such as
key and foreign key. We use a
new data structure, Catalog, to store metadata. You need not worry
about instantiating this object (it gets automatically instantiated when py_entitymatching
gets loaded in Python memory) or manipulating this object directly.</p>
<p>All the py_entitymatching commands correctly handle the metadata in the Catalog,
and for you, there are commands to manipulate the Catalog (please see
<a class="reference internal" href="singlepage.html#label-handling-metadata"><span class="std std-ref">Handling Metadata</span></a> section for the supported commands).</p>
<p><strong>If You Want to Read More:</strong>
As we mentioned earlier,  we need to store a lot of metadata with a table. Here are a few examples:</p>
<ul class="simple">
<li><p>Each table in py_entitymatching should have a key, so that we can easily identify the tuples.
Keys are also critical later for debugging, provenance, etc. Key is a metadata that we
want to store for a table.</p></li>
<li><p>The blocking step will create tuple pairs from two tables A and B. For example,
suppose we have table A(aid, a, b) and table B(bid, x, y), then the tuple pairs can be
stored in a candidate set table C(cid, aid, bid, a, b, x, y). This table could be very
big, taking up a lot of space in memory. To save space, we may want to just store C as
C(cid, aid, bid) and then have pointers back to tables A and B. The two pointers back
to A and B are metadata that we may want to store for table C. Specifically, the
metadata for C include key (<cite>cid</cite>) and foreign keys (<cite>aid</cite>, <cite>bid</cite>) to the base tables
(<cite>A</cite>, <cite>B</cite>).</p></li>
</ul>
<p>There are many other examples of metadata that we may want to store for a table. Though
pandas Dataframes is a good choice for storing data as tables, it does not provide a
robust way to store metadata (for more discussion on this topic, please look at <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2485">this thread</a>).
To tackle this, we have a new data structure, <cite>Catalog</cite> to store the metadata for tables.</p>
<p>Conceptually, Catalog is a dictionary, where the keys are unique identifiers for
each Dataframe and the values are dictionaries containing metadata.
This dictionary can have different kinds of keys that point to metadata.
Examples of such keys are:</p>
<ul class="simple">
<li><p>key: the name of the key attribute of the table.</p></li>
<li><p>ltable: pointer to the left table (see below).</p></li>
<li><p>rtable: pointer to the right table (see below).</p></li>
</ul>
<p>The kind of metadata stored for a table would depend on the table itself. For example,
the input tables must have a key and this can be the only metadata.</p>
<p>But, if we consider table C (which is obtained by performing blocking on input tables A
and B), this table can be very large, so we typically represent it using a view over
two tables A and B. Such a table C will have the following attributes:</p>
<ul class="simple">
<li><p>_id (key attribute of table C).</p></li>
<li><p>ltable_aid (aid is the key attribute in table A).</p></li>
<li><p>rtable_bid (bid is the key attribute in table B).</p></li>
<li><p>some attributes from A and B.</p></li>
</ul>
<p>The metadata dictionary for table C will have at least these fields:</p>
<ul class="simple">
<li><p>key: _id.</p></li>
<li><p>ltable: points to table A.</p></li>
<li><p>rtable: points to table B.</p></li>
<li><p>fk_ltable: ltable_aid (that is, ltable.aid is a foreign key of table A).</p></li>
<li><p>fk_rtable: rtable_bid.</p></li>
</ul>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Tables in py_entitymatching are represented as pandas Dataframes.</p></li>
<li><p>The metadata for tables are stored in a separate data structure called Catalog.</p></li>
<li><p>The kind of metadata stored will depend on the table (for example input table will have key,
and the table from blocking will have key, ltable, rtable, fk_table, fk_rtable).</p></li>
<li><p>So there are five reserved keywords for metadata: key, ltable, rtable, fk_ltable,
fk_rtable. You should not use these names to store metadata for other application
specific purposes.</p></li>
</ul>
</div>
</div>
<span id="document-user_manual/steps_supp_em_workflows"></span><div class="section" id="steps-of-supported-em-workflows">
<h2>Steps of Supported EM Workflows<a class="headerlink" href="#steps-of-supported-em-workflows" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/read_csv_files"></span><div class="section" id="reading-the-csv-files-from-disk">
<h3>Reading the CSV Files from Disk<a class="headerlink" href="#reading-the-csv-files-from-disk" title="Permalink to this headline">¶</a></h3>
<p>Currently, py_entitymatching only asupports reading CSV files from disk.</p>
<p><strong>The Minimal That You Should Do:</strong> First, you must store the input tables as CSV files
in disk. Please look at section <a class="reference internal" href="singlepage.html#label-csv-format"><span class="std std-ref">CSV Format</span></a> to learn more
about CSV format. An example of a CSV file will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94121</span>
</pre></div>
</div>
<p>Next, each table in py_entitymatching must have a key column. If the table already
has a key column, then you can read the CSV file and set the key column as like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ID is the key column in table.csv</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the table does not have a key column, then you can read the CSV file, add a
key column and set the added key column like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read the CSV file</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
<span class="c1"># Add a key column with name &#39;ID&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="c1"># Set &#39;ID&#39; as the key column</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>If You Want to Read and Play Around More:</strong> In general, the command
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> looks for a file (with the same file name
as the <cite>CSV</cite> file) with <cite>.metadata</cite> extension in the same directory containing the
metadata. If the file containing metadata information is not present, then
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> will proceed just reading the CSV file
as mentioned in the command.</p>
<p>To update the metadata for a table, using a metadata file, first, you must manually create
this file and specify the metadata for a table and then call
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code>. The command will automatically read the metadata from the
file and update the Catalog.</p>
<p>For example, if you read <cite>table.csv</cite> then <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code>
looks for <cite>table.metadata</cite> file. The contents of <cite>table.metadata</cite> may look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>Each line in the file starts with <cite>#</cite>. The metadata is written as <cite>key=value</cite> pairs,
one in each line. The contents of the above file says that <cite>ID</cite> is the key attribute
(for the table in the file <cite>table.csv</cite>).</p>
<p>The table mentioned in the above example along with the metadata file
stored in the same directory can be read as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once, the table is read, you can check to see which
attribute of the table is a key using <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_key()</span></code> command as
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   &#39;ID&#39;</span>
</pre></div>
</div>
<p>As you see, the key for the table is updated correctly as ‘ID’.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> for more details.</p>
</div>
<span id="document-user_manual/down_sampling"></span><div class="section" id="down-sampling">
<h3>Down Sampling<a class="headerlink" href="#down-sampling" title="Permalink to this headline">¶</a></h3>
<p>Once the tables to be matched are read, they must be down sampled if the number of
tuples in them are large (for example, 100K+ tuples). This is because working with
large tables can be very time consuming (as any operation performed would have
to process these large tables).</p>
<p>Random sampling however does not work, because the sampled may end up sharing very
few matches, especially if the number of matches between the
input tables are small to begin with.</p>
<p>In py_entitymatching, you can use sample the input tables using <cite>down_sample</cite> command.
This command samples the input tables intelligently that ensures a reasonable number of
matches between them.</p>
<p>If <cite>A</cite> and <cite>B</cite> are the input tables, then you can use <cite>down_sample</cite> command as shown
below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y_param</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Conceptually, the command takes in two original input tables, <cite>A</cite>, <cite>B</cite> (and some parameters),
and produces two sampled tables, <cite>sample_A</cite> and <cite>sample_B</cite>.
Specifically, you must set the <cite>size</cite> to be the number of tuples that
should be sampled from <cite>B</cite> (this will be the size of <cite>sample_B</cite> table) and set the
<cite>y_param</cite> to be the number of tuples to be selected from <cite>A</cite> (for each tuple in
<cite>sample_B</cite> table). The command internally uses a
heuristic to ensure a reasonable number of matches between <cite>sample_A</cite> and <cite>sample_B</cite>.</p>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">down_sample()</span></code> for more
details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the input tables must be loaded in memory before the user can down
sample.</p>
</div>
</div>
<span id="document-user_manual/profiling"></span><div class="section" id="profiling-data">
<h3>Profiling Data<a class="headerlink" href="#profiling-data" title="Permalink to this headline">¶</a></h3>
<p>Profiling data is used to help users get general information about their data.
Before working with the data, it is useful for a user to have a high level
understanding of the data because he or she will be able to take advantage of
the the general trends to successfully and efficiently complete the rest of
the workflow.</p>
<p>Data profiling specifically can show users important statistics such as type,
uniqueness, missing values, quartile statistics, mean, mode, standard deviation,
sum, median absolute deviation, coefficient of variation, kurtosis, skewness.
It can also display information to the user visually such as in a histogram.</p>
<p>We recommend using the python package pandas-profiling because it is simple
and easy to use. More information about the package can be found on the github
page at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
<div class="section" id="example-usage">
<h4>Example Usage<a class="headerlink" href="#example-usage" title="Permalink to this headline">¶</a></h4>
<p>After reading in a CSV file into a Dataframe, pandas-profiling shows the user a
report containing useful profiling information. For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The user can also check to see if any variables are highly correlated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check for rejected variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rejected_variables</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">get_rejected_variables</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>The report generated can also be saved into an html file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to a variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to an html file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outputfile</span><span class="o">=</span><span class="s2">&quot;/tmp/myoutputfile.html&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information about pandas-profiling please go to the github page
at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
</div>
</div>
<span id="document-user_manual/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<p>Data exploration is an important part of the entity matching workflow because it
gives the user a chance to look at the actual data closely. Data exploration
allows the user to inspect the individual records and features present in the
table so that he or she can understand the important trends and relationships
present in the data. A complete understanding of the data gives the user an
advantage later on in the entity matching workflow.</p>
<div class="section" id="openrefine">
<h4>OpenRefine<a class="headerlink" href="#openrefine" title="Permalink to this headline">¶</a></h4>
<p>OpenRefine is a data exploration tool that is compatible with Python &gt;= 2.7 or
Python &gt;= 3.4. More information about OpenRefine can be found at its github page
at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine">https://github.com/OpenRefine/OpenRefine</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>OpenRefine is not included with py_entitymatching and must be downloaded and
installed separately. The installation instructions can be found at
<a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
</div>
<div class="section" id="using-openrefine">
<h5>Using OpenRefine<a class="headerlink" href="#using-openrefine" title="Permalink to this headline">¶</a></h5>
<p>Before using OpenRefine, you must start the application to start an OpenRefine
server. The explanations for doing so are explained after the installation
instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
<p>Once the application has created a server, copy the URL from the address bar of
the OpenRefine browser (default is <a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a> ). Then the data can
be explored as in the example below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save the project back to our dataframe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calling export_pandas_frame will automatically delete the OpenRefine project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">export_pandas_frame</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pandastable">
<h4>Pandastable<a class="headerlink" href="#pandastable" title="Permalink to this headline">¶</a></h4>
<p>Pandastable is a data exploration tool available for python &gt;=3.4 that allows users
to view and manipulate data. More information about pandastable can be found at
<a class="reference external" href="https://github.com/dmnfarrell/pandastable">https://github.com/dmnfarrell/pandastable</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pandastable is not packaged along with py_entitymatching. You can install
pandastable using pip as show below:</p>
<blockquote>
<div><p>$ pip install pandastable</p>
</div></blockquote>
<p>or conda as shown below:</p>
<blockquote>
<div><p>$ conda install -c dmnfarrell pandastable=0.7.1</p>
</div></blockquote>
</div>
<div class="section" id="using-pandastable">
<h5>Using pandastable<a class="headerlink" href="#using-pandastable" title="Permalink to this headline">¶</a></h5>
<p>Pandastable can be easily be used with the wrappers included with py_entitymatching.
The following example shows how:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import py_entitymatching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Explore the data using pandastable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-user_manual/blocking"></span><div class="section" id="specifying-blockers-and-performing-blocking">
<h3>Specifying Blockers and Performing Blocking<a class="headerlink" href="#specifying-blockers-and-performing-blocking" title="Permalink to this headline">¶</a></h3>
<p>In this section, we discuss how you can specify blockers and perform blocking.</p>
<div class="section" id="types-of-blockers-and-blocker-hierarchy">
<h4>Types of Blockers and Blocker Hierarchy<a class="headerlink" href="#types-of-blockers-and-blocker-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>Once the tables are loaded and downsampled, most often you have to do blocking.
Note that by <em>blocking</em> we mean to block a <em>tuple pair</em> from going through to the
matching step. When applied to a tuple pair, a blocker returns <em>True</em> if the pair
should be blocked. You must know conceptually the types of blockers and
the blocker hierarchy in py_entitymatching to extend or modify them based on your need.</p>
<p>There are two types of blockers: (1) tuple-level, and (2) global. A tuple-level blocker
can examine a tuple pair in isolation and decide if it should be admitted to the next
stage. For example, an attribute equivalence blocker is a tuple-level blocker. A global
blocker cannot make this decision in isolation. It would need to examine a set of other
pairs as well. For example, a sorted neighborhood blocker applied over an union of the
input tables is a global blocker. Currently, py_entitymatching supports only
tuple-level blockers.</p>
<p>The blockers can be combined in complex ways, such as</p>
<ul class="simple">
<li><p>apply blocker <em>b1</em> to the two tables</p></li>
<li><p>apply blocker <em>b2</em> to the two tables</p></li>
<li><p>apply blocker <em>b3</em> to the output of <em>b1</em></p></li>
</ul>
<p>Further, you may just want to apply a blocker to just a pair of tuples, to see how
the blocker works.</p>
<p>In py_entitymatching, there is a Blocker class from which a set of concrete blockers
are inherited. These concrete blockers implement the following methods:</p>
<ul class="simple">
<li><p>block_tables (apply to input tables A and B)</p></li>
<li><p>block_candset (apply to an output from another blocker (e.g. table C))</p></li>
<li><p>block_tuples (apply to a tuple pair to check if it will survive blocking)</p></li>
</ul>
<p>In py_entitymatching, there are four concrete blockers implemented: (1) attribute
equivalence blocker, (2) overlap blocker, (3) rule-based blocker, and (4) black box
blocker. All the functions implemented in the concrete blockers are metadata aware.</p>
<p>The class diagram of Blocker and the concrete blockers inherited from it is shown below:</p>
<a class="reference internal image-reference" href="_images/blocker_hierarchy.png"><img alt="'Blocker Hierarchy'" src="_images/blocker_hierarchy.png" style="width: 1162.0px; height: 259.0px;" /></a>
</div>
<div class="section" id="built-in-blockers">
<h4>Built-In Blockers<a class="headerlink" href="#built-in-blockers" title="Permalink to this headline">¶</a></h4>
<p>Built-in blockers are those that have been built into py_entitymatching and you can just
simply call them. <em>py_entitymatching</em> currently offers three built-in blockers.</p>
<p><strong>Attribute Equivalence Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in attribute equivalence blocker
takes an attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that
is, drop the tuple pair) if <cite>x</cite> and <cite>y</cite> are not of the same value.</p>
<p>An example of using the above function is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>. An example of using
<cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
<p><strong>Overlap Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in overlap blocker takes an
attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that is, drop
the tuple pair) if <cite>x</cite> and <cite>y</cite> do not share any token (where the token is a word or
a q-gram).</p>
<p>As part of the pre-processing for this blocker, the strings are first converted to lowercase.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
<p><strong>Sorted Neighborhood Blocker</strong></p>
<p>WARNING: THIS IS AN EXPERIMENTAL COMMAND. THIS COMMAND IS NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> works in the following manner.
First, for table A, <cite>block_tables</cite> creates a blocking attribute for every tuple using the output of <cite>l_block_attr</cite>.
Next, for table B, <cite>block_tables</cite> similarly creates a blocking attribute using the output of <cite>r_block_attr</cite>.
Then, tables A and B are combined and sorted on the blocking attribute.</p>
<p>Finally, a sliding window of size <cite>window_size</cite> is passed through the sorted dataset.
If two tuples are within <cite>window_size</cite> positions of each other in sorted order, and the two tuples
come from different tables, then the two tuples are returned in the candidate set.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sn</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">SortedNeighborhoodBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">3</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>Unlike the other two blockers, since the sorted neighborhood blocker requires the sorted order
of all tuples in the database, <cite>block_candset</cite> and <cite>block_tuples</cite> are not applicable and will raise an assertion if called.</p>
<p>Two things to note.
First, consider the trade-off of possible values to <cite>window_size</cite>.
If the size is too small, actually-matching tuples will not be returned in the candidate set (and thus, missed).
If the window size is very large, the resulting candidate set will also be excessively large, hurting performance.
The exact size needed is unique to each dataset.</p>
<p>Second, if <cite>window_size</cite> is smaller than a range of matching tuples, and actually-matching tuples will be missed, not be returned in the candidate set.
However, if the blocking attribute is not sufficient to make a unique sorted order, than the resulting sorted order is one of a set of potential sorted orders.
If the method of sorting changes, for instance if more cores are used, a different sorted order may be returned.
This sorted order may result in a different candidate set being returned.
To avoid this situation it is recommended to add some uniqueness into the blocking attribute (such as the ID), so that there is only one correct sorted order.
This will help ensure the same set of results are returned from the same inputs.
An example of this is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">l_output_prefix</span><span class="o">=</span><span class="s1">&#39;l_&#39;</span><span class="p">,</span> <span class="n">r_output_prefix</span><span class="o">=</span><span class="s1">&#39;r_&#39;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example a new attribute <cite>birth_year_plus_id</cite> is used as the blocking attribute, and will always have the same sorted order.</p>
</div>
<div class="section" id="blackbox-blockers">
<h4>Blackbox Blockers<a class="headerlink" href="#blackbox-blockers" title="Permalink to this headline">¶</a></h4>
<p>By <cite>blackbox blockers</cite> we mean that the user supplies a Python function which
encodes blocking for a tuple pair. Specifically, the Python function will take
in two tuples and returns True if the tuple pair needs to be blocked, else
returns False. To use a blackbox blocker, first you must write a
blackbox blocker function.</p>
<p>An example of blackbox blocker function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that there is a &#39;name&#39; attribute in the input tables</span>
    <span class="c1"># and each value in it has two words</span>
    <span class="n">l_last_name</span> <span class="o">=</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_last_name</span> <span class="o">=</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">l_last_name</span> <span class="o">!=</span> <span class="n">r_last_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Then instantiate a <cite>blackbox blocker</cite> and set the blocking function function as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, you can call <cite>block_tables</cite> on the input tables. Conceptually, <cite>block_tables</cite> would
apply the blackbox blocker function on the Cartesian product of the input tables A and B, and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>Further, <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
</div>
<div class="section" id="rule-based-blockers">
<h4>Rule-Based Blockers<a class="headerlink" href="#rule-based-blockers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for blocking purposes) using rule-based blocker.
If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>block_f</cite>. Then you will be able
to instantiate a rule-based blocker and add rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_f</cite> is a set of features stored as a Dataframe (see section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The blocker is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be blocked.</p>
<p>Once the rules are specified, you can call <cite>block_tables</cite> on the input tables.
Conceptually, <cite>block_tables</cite> would
apply the rule-based blocker function on the Cartesian product of the input tables A and B and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
</div>
<div class="section" id="combining-multiple-blockers">
<h4>Combining Multiple Blockers<a class="headerlink" href="#combining-multiple-blockers" title="Permalink to this headline">¶</a></h4>
<p>If you use multiple blockers, then you have to combine them to get a
consolidated candidate set. There are many different ways to combine the candidate sets
such as doing union, majority vote, weighted vote, etc. Currently, py_entitymatching
only supports union-based combining.</p>
<p>In py_entitymatching, <cite>combine_blocker_outputs_via_union</cite> is used to do union-based
combining.</p>
<p>An example of using <cite>combine_blocker_outputs_via_union</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes in a list of blocker outputs (i.e. pandas Dataframes) and
produces a consolidated table. The output table contains the union of tuple pair ids and
other attributes from the input list.</p>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_blocker_outputs_via_union()</span></code>
for more details.</p>
</div>
</div>
<span id="document-user_manual/create_feats_for_blocking"></span><div class="section" id="creating-features-for-blocking">
<span id="label-create-features-blocking"></span><h3>Creating Features for Blocking<a class="headerlink" href="#creating-features-for-blocking" title="Permalink to this headline">¶</a></h3>
<p>Recall that when doing blocking, you can use built-in blockers,
blackbox blockers, or rule-based blockers. For rule-based blockers,
you have to create a set of features. While creating features, you will have to
refer to tokenizers, similarity functions, and attributes of the tables.
Currently, in py_entitymatching, there are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically generate a set of features (then you can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<p>Note that features will also be used in the matching process, as we
will discuss later.</p>
<p>If you are interested in just letting the system to automatically
generate a set of features, then please see <a class="reference internal" href="#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>.</p>
<p>If you want to generate features on your own, please read below.</p>
<div class="section" id="available-tokenizers-and-similarity-functions">
<h4>Available Tokenizers and Similarity Functions<a class="headerlink" href="#available-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>A tokenizer is a function that takes a string and optionally a number
of other arguments, then tokenizes the string and returns a set of tokens.
Currently, the following tokenizers are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Alphabetic</p></li>
<li><p>Alphanumeric</p></li>
<li><p>White space</p></li>
<li><p>Delimiter based</p></li>
<li><p>Qgram based</p></li>
</ul>
<p>A similarity function takes two arguments (can be strings, numeric values, etc.),
which are typically two attribute values such
as two book titles, then returns an output value which is typically a similarity score
between the two attribute values. Currently, the following similarity functions
are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Affine</p></li>
<li><p>Hamming distance</p></li>
<li><p>Jaro</p></li>
<li><p>Jaro-Winkler</p></li>
<li><p>Levenshtein</p></li>
<li><p>Monge-Elkan</p></li>
<li><p>Needleman-Wunsch</p></li>
<li><p>Smith-Waterman</p></li>
<li><p>Jaccard</p></li>
<li><p>Cosine</p></li>
<li><p>Dice</p></li>
<li><p>Overlap coefficient</p></li>
<li><p>Exact match</p></li>
<li><p>Absolute norm</p></li>
</ul>
</div>
<div class="section" id="obtaining-tokenizers-and-similarity-functions">
<h4>Obtaining Tokenizers and Similarity Functions<a class="headerlink" href="#obtaining-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>First you need to get tokenizers and similarity functions to refer them in features.
In py_entitymatching, you can use
<cite>get_tokenizers_for_blocking</cite> to get all the tokenizers available for blocking purposes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_t</cite> is a dictionary where keys are tokenizer names
and values are tokenizer functions in Python. You can inspect <cite>block_t</cite> and delete/add
tokenizers as appropriate. The above command will return single-argument tokenizers,
i.e., those that take a string then produce a set of tokens.</p>
<p>Each of the keys of the default dictionary returned to ‘block_t’ by
‘get_tokenizers_for_blocking’ represent a tokenizer that can be used by similarity
functions. The keys and the respective tokenizer they represent are shown below:</p>
<ul class="simple">
<li><p>alphabetic: Alphabetic tokenizer</p></li>
<li><p>alphanumeric: Alphanumeric tokenizer</p></li>
<li><p>dlm_dc0: Delimiter tokenizer using spaces as the delimiter</p></li>
<li><p>qgm_2: Two Gram tokenizer</p></li>
<li><p>qgm_3: Three Gram tokenizer</p></li>
<li><p>wspace: Whitespace tokenizer</p></li>
</ul>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_blocking()</span></code>
for more details.</p>
<p>Similarly, the user can use <cite>get_sim_funs_for_blocking</cite> to get all the similarity
functions available for blocking purposes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_s</cite> is a dictionary where keys are similarity function names
and values are similarity functions in Python. Similar to <cite>block_t</cite>, you can
inspect <cite>block_s</cite> and delete/add similarity functions as appropriate.</p>
<p>Each of the keys of the default dictionary returned to ‘block_s’ by
‘get_sim_funs_for_blocking’ represent a similarity function. The keys and the
respective similarity function they represent are shown below:</p>
<ul class="simple">
<li><p>abs_norm: Absolute Norm</p></li>
<li><p>affine: Affine Transformation</p></li>
<li><p>cosine: Cosine Similarity</p></li>
<li><p>dice: Dice similarity Coefficient</p></li>
<li><p>exact_match: Exact Match</p></li>
<li><p>hamming_dist: Hamming Distance</p></li>
<li><p>hamming_sim: Hamming Similarity</p></li>
<li><p>jaccard: Jaccard Similarity</p></li>
<li><p>jaro: Jaro Distance</p></li>
<li><p>jaro_winkler: Jaro-Winkler Distance</p></li>
<li><p>lev_dist: Levenshtein Distance</p></li>
<li><p>lev_sim: Levenshtein Similarity</p></li>
<li><p>monge_elkan: Monge-Elkan Algorithm</p></li>
<li><p>needleman_wunsch: Needleman-Wunsch Algorithm</p></li>
<li><p>overlap_coeff: Overlap Coefficient</p></li>
<li><p>rel_diff: Relative Difference</p></li>
<li><p>smith_waterman: Smith-Waterman Algorithm</p></li>
</ul>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_sim_funs_for_blocking()</span></code>
for more details.</p>
</div>
<div class="section" id="obtaining-attribute-types-and-correspondences">
<h4>Obtaining Attribute Types and Correspondences<a class="headerlink" href="#obtaining-attribute-types-and-correspondences" title="Permalink to this headline">¶</a></h4>
<p>In the next step, you need to obtain type and correspondence information about A and B
so that the features can be generated.</p>
<p>First, you need to obtain the types of attributes in A and B,
so that the right tokenizers/similarity functions can be applied to each of them.
In py_entitymatching, you can use <cite>get_attr_types</cite> to get the attribute types.
An example of using <cite>get_attr_types</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>atypes1</cite> and <cite>atypes2</cite> are dictionaries. They contain, the type of
attribute in each of the tables. Note that this <cite>type</cite> is different from basic
Python types. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_types()</span></code> for more details.</p>
<p>Next, we need to obtain correspondences between the attributes of A and B,
so that the features can be generated based on those correspondences.
In py_entitymatching, you can use <cite>get_attr_corres</cite> to get the attribute
correspondences.</p>
<p>An example of using <cite>get_attr_corres</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_c</cite> is a dictionary containing attribute correspondences.
Currently, py_entitymatching returns attribute correspondences only based on the exact
match of attribute names. You can inspect <cite>block_c</cite> and modify the attribute
correspondences. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_corres()</span></code> for more details.</p>
</div>
<div class="section" id="getting-a-set-of-features">
<span id="label-get-a-set-of-features-manual"></span><h4>Getting a Set of Features<a class="headerlink" href="#getting-a-set-of-features" title="Permalink to this headline">¶</a></h4>
<p>Recall that so far we have obtained:</p>
<ul class="simple">
<li><p>block_t, the set of tokenizers,</p></li>
<li><p>block_s, the set of sim functions</p></li>
<li><p>atypes1 and atypes2, the types of attributes in A and B</p></li>
<li><p>block_c, the correspondences of attributes in A and B</p></li>
</ul>
<p>Next, to obtain a set of features, you can use <cite>get_features</cite> command.
An example of using <cite>get_features</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Briefly, this function will go through the correspondences. For each
correspondence <cite>m</cite>, it examines the types of the involved attributes,
then apply the appropriate tokenizers and similarity functions to generate
all appropriate features for this correspondence. The features are returned as
a Dataframe. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features()</span></code> for more details.</p>
</div>
<div class="section" id="adding-removing-features">
<span id="label-add-remove-features"></span><h4>Adding/Removing Features<a class="headerlink" href="#adding-removing-features" title="Permalink to this headline">¶</a></h4>
<p>Given the set of features <cite>block_f</cite> as a pandas Dataframe, you can delete certain features,
add new features.</p>
<p>Deletion of a feature is straightforward, all that you have to do is delete the row
from the feature table corresponding to the feature. You can use <cite>drop</cite> command
from pandas Dataframe for this purpose. Please look at this
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html">API reference link</a>
for more details.</p>
<p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define a feature declartively and add it to
feature table.</p>
<p><strong>Adding a Blackbox Function as Feature</strong></p>
<p>To create and add a blackbox function as a feature, first you must define it. Specifically,
the function must take in two tuples as input and return a numeric value. An example of
a blackbox function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the feature table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">add_blackbox_feature()</span></code> for more details.</p>
<p><strong>Adding a Feature Declaratively</strong></p>
<p>Another way to add features is to write a feature expression in
a <cite>declarative</cite> way. py_entitymatching will then compile it into a feature. For
example, you can declaratively create and add a feature like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple[&quot;name&quot;]), qgm_3(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <cite>block_t</cite> and <cite>block_s</cite> refer to the dictionaries containing a set of
tokenizers and similarity functions for blocking. Additionally, ‘jaccard’ refers
to the key in ‘block_s’ that represents the Jaccard Similarity function and
‘qgm_3’ refers to the key in ‘block_t’ that represents a three gram tokenizer.
The keys in ‘block_t’ and ‘block_s’ and which function or tokenizer they
represent are explained above in the Obtaining Tokenizers and Similarity Functions
section.</p>
<p>Conceptually, the first command, <cite>get_feature_fn</cite>, creates a feature which is a Python function
that will take two tuples <cite>ltuple</cite> and <cite>rtuple</cite>, get the attribute publisher from <cite>ltuple</cite>,
issuer from <cite>rtuple</cite>, tokenize them, then compute jaccard score.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The feature must refer the tuple from the left table (say A) as <strong>ltuple</strong> and
the tuple from the right table (say B) as <strong>rtuple</strong>.</p>
</div>
<p>The second command, <cite>add_feature</cite> tags the feature with the specified name,
and adds it to the feature table.</p>
<p>As described, the feature that was just created is <em>independent</em> of any table
(eg A and B). Instead, it expects as the input two tuples: ltuple and rtuple.</p>
<p>You can also create more complex features. Specifically,
you are allowed to define arbitrary complex expression involving function names from
<cite>block_t</cite> and <cite>block_s</cite>, and attribute names from ltuple and rtuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create your own similarity functions and tokenizers for your custom features.
For example, you can create a similarity function that changes all strings to lowercase
before checking if they are equivalent.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function converts the two strings to lowercase before checking if they are an exact match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_lowercase</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">l_attr</span> <span class="o">=</span> <span class="n">l_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">r_attr</span> <span class="o">=</span> <span class="n">r_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>You can then add a feature declarativly with your new similarity function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new similarity function is added to block_s and then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;match_lowercase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_lowercase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;match_lowercase(ltuple[&quot;name&quot;], rtuple[&quot;name&quot;])&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_match_lowercase&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to create features with your own similarity functions that require
tokenizers. The next example shows how to create a custom tokenizer that returns only
the first and last words of a string.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This custom tokenizer returns the first and last words of a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_tok</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">all_toks</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">toks</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_toks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_toks</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">all_toks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">toks</span>
</pre></div>
</div>
<p>Next, a similarity function that can utilize the new tokenizer is created. This example
shows how to create a similarity function that raises the score if the first words match
and raises the score by one if the second words match.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function compares two tokens from each set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Greater weight is placed on the equality of the first token.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_sim</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">score</span>
</pre></div>
</div>
<p>Finally, with the tokenizer and similarity functions defined, the new feature can be
created and added.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new tokenizer is added to block_t and the new similarity function is added to block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span><span class="p">[</span><span class="s1">&#39;first_last_tok&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_tok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;first_last_sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;first_last_sim(first_last_tok(ltuple[&quot;name&quot;]), first_last_tok(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_fls_flt_flt&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_feature()</span></code>
for more details.</p>
</div>
<div class="section" id="summary-of-the-manual-feature-generation-process">
<h4>Summary of the Manual Feature Generation Process<a class="headerlink" href="#summary-of-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of commands for the entire manual feature generation process.</p>
<p>To generate features, you must execute the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <cite>block_f</cite> points to a Dataframe containing features as rows.</p>
</div>
<div class="section" id="ways-to-edit-the-manual-feature-generation-process">
<h4>Ways to Edit the Manual Feature Generation Process<a class="headerlink" href="#ways-to-edit-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of ways to edit the variables used in feature generation process.</p>
<ul>
<li><p>The <cite>block_t</cite>, <cite>block_s</cite>, <cite>atypes1</cite>, <cite>atypes2</cite>, <cite>block_c</cite> are dictionaries. You
can modify these variables based on your need, to add/remove tokenizers,
similarity functions, attribute correspondences, etc.</p></li>
<li><p><cite>block_f</cite> is a Dataframe. You can remove a feature by just deleting the corresponding
tuple from the Dataframe.</p></li>
<li><p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define the feature declartively and add it to
feature table.
To add a blackbox feature, first write a blackbox function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>To add a feature declaratively, first write a feature expression and compile it to feature
using <cite>get_feature_fn</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="generating-features-automatically">
<span id="label-gen-feats-automatically"></span><h4>Generating Features Automatically<a class="headerlink" href="#generating-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>Recall that to get the features for blocking, eventually you
must execute the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>atypes1</cite>/<cite>atypes2</cite> are the attribute types of A and B, <cite>block_c</cite> is
the correspondences between their attributes, <cite>block_t</cite> is the set of tokenizers,
and <cite>block_s</cite> is the set of similarity functions.</p>
<p>If you don’t want to go through the hassle of creating these intermediate
variables, then you can execute the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The system will automatically generate a set of features and return it as
as a Dataframe which you can then use for blocking purposes. This Dataframe
contains a few attributes that require further explanation, specifically
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, and ‘simfunction’. There are
two types of similarity functions, those that use tokenizers and those that
do not. Some similarity functions use tokenizers and all such features must
designate a tokenizer for both the left table attribute in
‘left_attr_tokenizer’ and for the right table attribute in
‘right_attr_tokenizer’. The ‘simfunction’ attribute refers to the name of
the function and comes from the keys in ‘block_s’. The various keys and the
actual functions they correspond to are explained in the Obtaining
Tokenizers and Similarity Functions section above.</p>
<p>The command <cite>get_features_for_blocking</cite> will set the following variables: <cite>_block_t</cite>,
<cite>_block_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, and <cite>_block_c</cite>. You can access these variables like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_c</span>
</pre></div>
</div>
<p>You can examine these variables, modify them as appropriate, and
then perhaps re-generate the set of features using <cite>get_features</cite> command.</p>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_blocking()</span></code> for more details.</p>
</div>
</div>
<span id="document-user_manual/debugging_blocking"></span><div class="section" id="debugging-blocking">
<h3>Debugging Blocking<a class="headerlink" href="#debugging-blocking" title="Permalink to this headline">¶</a></h3>
<p>In a typical entity matching workflow, you will load in the two tables to
match, sample them (if required) and use a blocker to remove obvious non-matches.
But it is often not clear whether the blocker drops only non-matches or it
also removes a lot of potential matches.</p>
<p>In such cases, it is important to debug the output of blocker. In
py_entitymatching, <cite>debug_blocker</cite> command can be used for that purpose.</p>
<p>The <cite>debug_blocker</cite> command takes in two input tables A, B, blocker output C
and returns a table D containing a set of tuple pairs that are
potential matches and yet are not present in the blocker output
C. Table D also contains similarity measure computed for each reported
tuple pair (as its second column).</p>
<p>You can examine these potential matches in table D. If you
find that many of them are indeed true matches, then that means the
blocker may have removed too many true matches. In this case you
may want to <cite>relax</cite> the blocker by modifying its parameters, or
choose a different blocker. On the other hand, if you do not
find many true matches in table D, then it could be the case that the
blocker has done a good job and preserve all the matches (or most of
the matches) in the blocker output C.</p>
<p>In the <cite>debug_blocker</cite>, you can optionally specify attribute correspondences between
the input tables A and B. If it is not specified, then attribute correspondences
will be a list of attribute pairs with the exact same names in A and B.</p>
<p>The debugger will use only the attributes mentioned in these attribute
correspondences to try to find potentially matching pairs and place
those pairs into D. Thus, our recommendation is that (a) if the tables
have idential schemas or share a lot of attributes with the same
names, then do not specify the attribute correspondences, in this
case the debugger will use all the attributes with the same name between the two
schemas, (b) otherwise think about what attribute pairs you want to see the
debugger use, then specify those as attribute correspondences.</p>
<p>An example of using <cite>debug_blocker</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_blocker()</span></code>
for more details.</p>
<p>The blocker debugger is implemented in Cython. In case this version of the
command is not working properly, there is also a python version of the command,
called <cite>backup_debug_blocker</cite>, available that can be used instead. Please refer
to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">backup_debug_blocker()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/sampling"></span><div class="section" id="sampling">
<span id="label-sampling"></span><h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers or evaluate matchers, you need to
create labeled data. To create labeled data, first you need to sample of candidate set
pairs and then label them.</p>
<p>In <em>py_stringmatching</em>, you can use <cite>sample_table</cite> to get a sample. The command does
uniform random sampling without replacement. An example of using <cite>sample_table</cite> is shown
below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The command will first create a copy of the input table, sample the specified number of
tuple pairs from the copy, update the metadata and return the sampled table.</p>
<p>For more details, please look into the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">sample_table()</span></code></p>
</div>
<span id="document-user_manual/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<p>The command <cite>label_table</cite> can be used to label the samples (see section
<a class="reference internal" href="singlepage.html#label-sampling"><span class="std std-ref">Sampling</span></a>). An example of using <cite>label_table</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first create a copy of the input table <cite>S</cite>, update
the metadata, add a column with the
specified column name (in <cite>label_col_name</cite> parameter) fill it with 0 (i.e non-matches)
and open a GUI for you to update the labels. You must specify 0 for non-matches and
1 for matches. Once you close the GUI, the updated table will be returned.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">label_table()</span></code>
for more details.</p>
</div>
<span id="document-user_manual/split_train_test"></span><div class="section" id="splitting-labeled-data-into-training-and-testing-sets">
<h3>Splitting Labeled Data into Training and Testing Sets<a class="headerlink" href="#splitting-labeled-data-into-training-and-testing-sets" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you will have to split data for
multiple purposes. Some examples are:</p>
<p>1. Split labeled data into development and test. Th development
set is used to come up with right features for learning-based matcher, and
<cite>test</cite> set is used to evaluate the matcher.</p>
<p>2. Split feature vectors into a train and test set. The train
set is used to train the learning-based matcher and test set is used
for evaluation.</p>
<p>py_entitymatching provides <cite>split_train_test</cite> command for the above need.
An example of using <cite>split_train_test</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>split_train_test</cite> returns a dictionary with two keys: train, and test.
The value for the key <cite>train</cite> is a Dataframe containing tuples
allocated from the input table based on train_proportion.
Similarly, the value for the key <cite>test</cite> is a Dataframe containing
tuples for evaluation. An example of getting train and test Dataframes from the output
of <cite>split_train_test</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">devel_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Setting the value for train proportion would depend on the
context of its use. For instance, if the data is split for machine learning
purposes then train proportion is typically larger than the
test.
The most commonly used values of train_proportion are between
0.5 and 0.8.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">split_train_test()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/create_feats_for_matching"></span><div class="section" id="creating-features-for-matching">
<span id="label-create-feats-matching"></span><h3>Creating Features for Matching<a class="headerlink" href="#creating-features-for-matching" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers, then you cannot just operate on the
labeled set of tuple pairs. For each tuple in the labeled, you need to convert it
into a feature vector which consists of a list of numerical/categorical features. To do
this, first we need to create a set of features.</p>
<p>There are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically create a set of features (then the user can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<p>This is very similar to manual feature creation process for blocking (see section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>) except the features are created for
matching purposes.
In brief, you can execute the following sequence of commands in py_entitymatching
to create the features manually:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Further, you can add or delete features as see saw in section
<a class="reference internal" href="singlepage.html#label-add-remove-features"><span class="std std-ref">Adding/Removing Features</span></a>.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_matching()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code> for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching returns the same set of features for blocking and matching purposes.</p>
</div>
</div>
<div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>If you do not want to go through the hassle of creating the features manually, then
the user can generate the features automatically. This is very similar to automatic
feature creation process for blocking (see section <a class="reference internal" href="singlepage.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>).</p>
<p>In py_entitymatching, you can use <cite>get_features_for_matching</cite> to generate features
for matching purposes automatically. An example of using <cite>get_features_for_matching</cite> is
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to what we saw in section <a class="reference internal" href="singlepage.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a> for blocking, the
command will set the following variables: <cite>_match_t</cite>, <cite>_match_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, <cite>_match_c</cite>
and they can be accessed like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_c</span>
</pre></div>
</div>
<p>You can to examine these variables, modify them as appropriate, and then
perhaps regenerate a set of features.
Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_matching()</span></code>
for more details.</p>
</div>
</div>
<span id="document-user_manual/extract_feat_vecs"></span><div class="section" id="extracting-feature-vectors">
<h3>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h3>
<p>Once you have created a set of features, you use them to convert labeled sample to feature
vectors. In py_entitymatching, you can use <cite>extract_feature_vecs</cite> to convert
labeled sample to feature vectors using the features created
(see section <a class="reference internal" href="singlepage.html#label-create-feats-matching"><span class="std std-ref">Creating Features for Matching</span></a>).</p>
<p>An example of using <cite>extract_feature_vecs</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes the labeled data (<cite>G</cite>), applies the feature functions (in <cite>match_f</cite>)
to each tuple in G to create a Dataframe, adds the <cite>attrs_before</cite> and <cite>attrs_after</cite>
columns, updates the metadata and returns the resulting Dataframe.</p>
<p>If there is one (or several columns) in labeled data that contains the labels, then those need
to be explicitly specified in <cite>attrs_after</cite>, if you want them them to copy over.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_feature_vecs()</span></code>
for more details.</p>
</div>
<span id="document-user_manual/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h3>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h3>
<p>While doing supervised learning-based matching, you would need to create labeled sample,
convert the sample into table of feature vectors, fill in the missing values, select
a machine learning (ML) model and use it to produce matches.</p>
<p>The step of filling in the missing values (also called imputing
missing values) is important and necessary. If there are missing values in the input
tables A and B, then they would be passed on to candidate set and most
likely to the feature vectors. In py_entitymatching, if the feature vectors
contain missing values, then most of the ML algorithms would not work
as they rely on scikit-learn package to provide ML-algorithm
implementations (and their implementations would not work if the
feature vectors contain NaN’s).</p>
<p>To avoid missing value problem in the feature vectors, you must impute the values
of the NaN’s. There are many different ways to impute missing values such as
filling the NaN’s (in the whole table or just some columns) with a constant value,
or fill the NaN’s with an aggregate value (mean, median, etc.).</p>
<p>Since the table is represented as a pandas Dataframe, there are two common ways to impute
missing values: (1) use <cite>fillna</cite> method from pandas Dataframe, and (2) impute missing
values using <cite>SimpleImputer</cite> from Scikit-learn package.</p>
<p>But there are two problems that we have to tackle if we have to using the above commands
or objects directly:</p>
<ul class="simple">
<li><p>They are not metadata aware, so the user has to explicitly take care of it.</p></li>
<li><p>The Dataframe type that gets imputed typically contains attributes such as key, foreign
keys to A and B. The user must have to rightly project them out to impute missing
values using aggregates.</p></li>
</ul>
<p>In py_entitymatching, we propose a hybrid method to impute missing values. To fill NaN’s
with a constant value use <cite>fillna</cite> command from pandas Dataframe. Please look at the
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html">API reference of fillna</a>
for more details. An example of using <cite>fillna</cite> to the whole table is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>H</cite> is a Dataframe containing feature vectors, 0 is the constant value that
to be filled in, and <cite>inplace=True</cite> means that the updation should be done in place
(i.e., without creating a copy). It is important to set <cite>inplace=True</cite> as we do not want
the metadata for H in Catalog to be corrupted.</p>
<p>Another example of using <cite>fillna</cite> on a column is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, in the above <cite>inplace</cite> should be specified as False, this is because
the output is getting assigned to a column in the old Dataframe <cite>H</cite> and the metadata
of <cite>H</cite> does not get affected.</p>
<p>To fill NaN’s with an aggregate value, in py_entitymatching you can use <cite>impute_table</cite>
command. It is a wrapper around scikit-learn’s <cite>SimpleImputer</cite> object (to make it metadata aware).
An example of using <cite>impute_table</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If all the values in a column or a row are NaN’s, then the above aggregation
strategy will not work (i.e. we cannot compute the mean and use it to fill the
missing values). In such cases, you need to specify a value in <cite>val_all_nans</cite>
parameter and the command will use this value to fill in all the missing values.</p>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">impute_table()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/matching"></span><div class="section" id="specifying-matchers-and-performing-matching">
<h3>Specifying Matchers and Performing Matching<a class="headerlink" href="#specifying-matchers-and-performing-matching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
<p>Once yor convert the labeled sample  into a table of feature vectors (and their
labels), the we can  can create and apply matchers to the feature vectors.
Currently py_entitymatching supports only ML-based matchers. Implementation wise,
a Matcher is defined as a Python class with certain methods (and some common
utility functions) and all concrete blockers inherit from this Matcher class and
override the methods. Specifically, each concrete matcher will implement at least
the following methods:</p>
<ul class="simple">
<li><p>fit (for training)</p></li>
<li><p>predict (for prediction)</p></li>
</ul>
<div class="section" id="creating-learning-based-matchers">
<h5>Creating Learning-Based Matchers<a class="headerlink" href="#creating-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>In py_entitymatching, there are seven concrete ML-matchers implemented: (1) naive bayes,
(2) logistic regression, (3) linear regression, (4) support vector machine, (5) decision
trees, (6) random forest, and (7) xgboost matcher.</p>
<p>These concrete matchers are just wrappers of scikit-learn matchers or that supports
scikit-learn wrappers (for eg., xgboost) and this is because
the fit/predict methods in scikit-learn are not metadata aware. The concrete matchers
make the scikit-learn matchers metadata aware.</p>
<p>Each matcher can be created by calling its constructor. Since these matchers are
just the wrappers of scikit-learn matchers, the parameters that can be given to
scikit-learn matchers can be to given to the matchers in py_entitymatching.
For example, a user can create a Decision Tree matcher like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to <code class="xref py py-meth docutils literal notranslate"><span class="pre">DTMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">RFMatcher()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">NBMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">LogisticRegressionMatcher()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">LinearRegressionMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">SVMMatcher()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">XGBoostMatcher()</span></code>
for more details.</p>
</div>
<div class="section" id="training-learning-based-matchers">
<h5>Training Learning-Based Matchers<a class="headerlink" href="#training-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is instantiated, you can train the matcher using the
<cite>fit</cite> command. An example of using the <cite>fit</cite> command for Decision Tree matcher
is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other variants of <cite>fit</cite> method. As an example, Please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code> for more details.</p>
</div>
<div class="section" id="applying-learning-based-matchers">
<h5>Applying Learning-Based Matchers<a class="headerlink" href="#applying-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is trained, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command for Decision Tree matcher
is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">probs_attr</span><span class="o">=</span><span class="s1">&#39;proba&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="go">inplace=True)</span>
</pre></div>
</div>
<p>There are other variants of <cite>predict</cite> method. As an example, Please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
<div class="section" id="rule-based-matchers">
<h4>Rule-Based Matchers<a class="headerlink" href="#rule-based-matchers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for matching purposes) using the rule-based
matcher. If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a rule-based matcher and add rules.</p>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features for matching, you can create rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BooleanRuleMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be a match.</p>
<p>Rules can also be deleted once they have been added to the matcher:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules in a matcher can be found using the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-rule-based-matcher">
<h5>Applying Rule-Based Matcher<a class="headerlink" href="#applying-rule-based-matcher" title="Permalink to this headline">¶</a></h5>
<p>Once the rules are specified, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>predict</cite> method, please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/select_best_matcher"></span><div class="section" id="selecting-a-ml-matcher">
<h3>Selecting a ML-Matcher<a class="headerlink" href="#selecting-a-ml-matcher" title="Permalink to this headline">¶</a></h3>
<p>Once you have created different concrete ML matchers, then you have to choose one of
them for matching purposes. There are many different criteria by which one can
decide to choose a matcher such as <cite>akaike information criterion</cite>, <cite>bayesian information
criterion</cite>, <cite>k-fold cross validation</cite>, etc. Currently py_entitymatching supports
k-fold cross validation and other approaches are left for future work.</p>
<p>Conceptually, the command to select a matcher would take in the following inputs:</p>
<ul class="simple">
<li><p>List of ML matchers.</p></li>
<li><p>Training data (feature vector).</p></li>
<li><p>A column of labels that correspond to the feature vectors in the training data.</p></li>
<li><p>Number of folds.</p></li>
</ul>
<p>And it would produce the following output:</p>
<ul class="simple">
<li><p>Selected matcher.</p></li>
<li><p>Statistics such as mean accuracy of all input matchers.</p></li>
</ul>
<p>In py_entitymatching, <cite>select_matcher</cite> command addresses the above needs. An
example of using <cite>select_matcher</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above the output, <cite>result</cite> is a dictionary containing three keys: (1) selected_matcher,
(2) cv_stats, and (3) drill_down_cv_stats. <cite>selected_matcher</cite> is the selected ML-based matcher,
<cite>cv_stats</cite> is a Dataframe which includes the average cross validation scores for each matcher
and for each metric, and ‘drill_down_cv_stats’ is a dictionary where each key is a metric that
includes the cross validation statistics for each fold.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">select_matcher()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/debugging_matcher"></span><div class="section" id="debugging-ml-matchers">
<h3>Debugging ML-Matchers<a class="headerlink" href="#debugging-ml-matchers" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you would like to choose a matcher that produces the desired
precision, recall or F1 numbers. If a matcher does not produce the desired accuracy, then
you would like to debug the matcher. py_entitymatching supports two ways to
debug: (1) using the GUI, and (2) using the command line.</p>
<div class="section" id="debugging-using-the-gui">
<h4>Debugging Using the GUI<a class="headerlink" href="#debugging-using-the-gui" title="Permalink to this headline">¶</a></h4>
<p>py_entitymatching supports debugging using the GUI for a subset of ML-based matchers.
Specifically, it supports debugging Decision Tree matcher and Random Forest matcher.
You can use <cite>vis_debug_dt</cite> and <cite>vis_debug_rf</cite> to debug Decision Tree matcher
and Random Forest matcher respectively.</p>
<p>An example of using <cite>vis_debug_dt</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The command would display a GUI containing evaluation summary and an option to see tuples
flagged as <cite>false positives</cite> or <cite>false negatives</cite>. If you select <cite>false positives</cite>
then false positive tuple pairs would be displayed in the adjoining window. Similarly,
if <cite>false negatives</cite> is selected then false negative tuple pairs would be
displayed. By default, <cite>false positives</cite> is selected.
Each tuple pair is displayed with two buttons: <cite>show</cite> and <cite>debug</cite>. If you click on
<cite>show</cite>, then individual tuples (of that tuple pair) are displayed in a separate window.
If you click on <cite>debug</cite>, then a window with individual tuples and the
path taken by the feature vector in the Decision Tree that leads to the predicted value
is displayed.</p>
<p>The usage of <cite>vis_debug_rf</cite> is same as <cite>vis_debug_dt</cite>. The command would display a GUI
similar to <cite>vis_debug_dt</cite>, except the debug window would list a set of trees. You can
expand each tree to see the path taken by the features in that tree.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_dt()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_rf()</span></code> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random Forest matcher using GUI,
then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>In the displayed GUI, check precision and recall numbers in evaluation summary.</p></li>
<li><p>If the user wants to improve precision, then he/she should choose to see false positives.</p></li>
<li><p>If the user wants to improve recall, then he/she should choose to see false negatives.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs,
you can click on the <cite>show</cite> button to see the tuples from the left and right tables.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs, you can choose a tuple
and click on the <cite>debug</cite> button to see the detailed evaluation path of that tuple.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are
cleaning  the input data, adding more features, adding more training data, trying a
different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="debugging-using-the-command-line">
<h4>Debugging Using the Command Line<a class="headerlink" href="#debugging-using-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>Similar to debugging using the GUI, py_entitymatching supports command line debugging for two
ML matchers: Decision Tree and Random Forest. Currently, py_entitymatching  supports
command line debugging only using tuple pairs, other approaches are left for future work.</p>
<p>You can use <cite>debug_decisiontree_matcher</cite> and <cite>debug_randomforest_matcher</cite> to debug
Decision Tree matcher and Random Forest matcher respectively.</p>
<p>An example of using <cite>debug_decisiontree_matcher</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, the debug command prints the path taken by the feature vector, its
evaluation status at each node and the actual feature value at each node.</p>
<p>The usage of <cite>debug_randomforest_matcher</cite> is same as <cite>debug_decisiontree_matcher</cite>.
Similar to <cite>debug_decisiontree_matcher</cite> command, it prints the path taken by the feature
vector, except that it displays the path taken in each tree of the Random Forest.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_decisiontree_matcher()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_randomforest_matcher()</span></code> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random
Forest matcher using the command line, then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>Evaluate the accuracy of predictions using user created labels. The evaluation can
be done using <code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code> command.</p></li>
<li><p>If you want to improve precision, then he/she should debug false positives.</p></li>
<li><p>If you want to improve recall, then he/she should debug false negatives.</p></li>
<li><p>You should then retrieve the tuples from the tuple id pairs listed in evaluation
summary, and debug using the commands described above.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are clean
the input data, add more features, add more training data, try different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="impact-of-imputing-missing-values">
<h4>Impact of Imputing Missing Values<a class="headerlink" href="#impact-of-imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<p>You should be aware of the following subtleties as it would
have an impact when he/she imputes values to feature vector set:</p>
<p>1. When you use the GUI for debugging, you would first choose to see
false positives/false negatives and then you would click the <cite>debug</cite> button to debug
that tuple pair. In this case, the feature vector in that row is given as input to find the path
traversed in the Decision Tree. If you had imputed the feature vector set to get
rid of NaN’s, then the imputed values would be considered to find the path traversed.</p>
<p>2. When you use the command line for debugging, then you would first evaluate the
predictions, select false positive or false negative tuple pairs to debug, retrieve the
tuples from the left and right tables and finally give them as input to command line
debugger commands. If you had imputed the feature vector set to get rid of NaN’s (using
a aggregate strategy), then imputed values would not be known to the debugger.</p>
<p>So if the input tables have NaN’s, then the output of the command line debugger would only
be partially correct (i.e., the displayed predicates would be correct, but the predicate
outcome may differ between current tuple pair and the actual feature vector used during
prediction).</p>
</div>
</div>
<span id="document-user_manual/matchercombiner"></span><div class="section" id="combining-predictions-from-multiple-matchers">
<h3>Combining Predictions from Multiple Matchers<a class="headerlink" href="#combining-predictions-from-multiple-matchers" title="Permalink to this headline">¶</a></h3>
<p>In the matching step, if you use multiple matchers then you will have to combine the
predictions from them to get a consolidated prediction. There are many different ways
to combine these predictions such as weighted vote, majority vote, stacking, etc.
Currently, py_entitymatching supports majority and weighted voting-based combining.
These combiners are experimental and not tested.</p>
<p>An example of using majority voting-based combining is shown below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv_combiner</span> <span class="o">=</span> <span class="n">MajorityVote</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;rf_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;nb_predictions&#39;</span><span class="p">]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions (from different matchers) the prediction that
occurs most is returned as the consolidated prediction. If there is no clear winning
prediction (for example, 0 and 1 occuring equal number of times) then 0 is returned.</p>
<p>An example of using weighted voting-based combining is shown below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wv_combiner</span> <span class="o">=</span> <span class="n">WeightedVote</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span>
<span class="go">&#39;rf_predictions&#39;, &#39;nb_predictions&#39;]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions, each prediction is given a
weight, we compute a weighted sum of these predictions and compare the result to a
threshold. If the result is greater than or equal to the threshold then the
consolidated prediction is returned as 1 (i.e., a match) else returned as 0 (no-match).</p>
</div>
<span id="document-user_manual/triggers"></span><div class="section" id="using-triggers-to-update-matching-results">
<h3>Using Triggers to Update Matching Results<a class="headerlink" href="#using-triggers-to-update-matching-results" title="Permalink to this headline">¶</a></h3>
<div class="section" id="match-triggers">
<h4>Match Triggers<a class="headerlink" href="#match-triggers" title="Permalink to this headline">¶</a></h4>
<p>Once you have used a matcher to predict results on a table, you might find
that there is some pattern of false positives or false negatives. Often, it
is useful to be able to create a set of rules to reevaluate tuple pair
predictions to correct these patterns of mistakes.</p>
<div class="section" id="creating-the-trigger">
<h5>Creating the Trigger<a class="headerlink" href="#creating-the-trigger" title="Permalink to this headline">¶</a></h5>
<p>Each trigger can be created by calling its constructor. For example, a user can
create a trigger like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
</pre></div>
</div>
<p>Please refer to <code class="xref py py-meth docutils literal notranslate"><span class="pre">MatchTrigger()</span></code> for more details.</p>
<p>If you have already used a matcher, you should have already created a set of features
for matching. More information on this can be found in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a match trigger and add rules.</p>
</div>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features, you can create rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the result for the tuple pair will
be true.</p>
<p>You also need to add a condition status and action when using match triggers. If the
result is the same value as the condition status, then the action will be carried out.
For example, the action and condition status can be declared like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The condition status and action in the above example mean that if the rules in the
trigger return the value False, then the prediction will be changed to a 0.</p>
<p>Rules can also be deleted once they have been added:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules can be found using the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-the-triggers">
<h5>Executing the Triggers<a class="headerlink" href="#executing-the-triggers" title="Permalink to this headline">¶</a></h5>
<p>Once the rules, condition status, and action have been specified, the trigger can be
used to refine the predictions. An example of using the execute command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;prediction_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>execute</cite> method, please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/evaluate_matching"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<p>Once you have predicted matches using ML-based matcher, then you would have to
evaluate the matches. py_entitymatching supports <cite>eval_matches</cite> command for that
purpose.</p>
<p>An example of using <cite>eval_matches</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>eval_summary</cite> is a dictionary containing accuracy numbers (such as
precision, recall, F1, etc) and the list of false positives/negatives.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code> for
more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/misc"></span><div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>This section covers some miscellaneous things in py_entitymatching.</p>
<div class="section" id="csv-format">
<span id="label-csv-format"></span><h3>CSV Format<a class="headerlink" href="#csv-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV format is selected because it’s well known and can be read by numerous external
programs. Further, it can be easily inspected and edited by the users.
You can read more about CSV formats <a class="reference external" href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.</p>
<p>There are two common CSV formats that are used to store CSV files: one with attribute
names in the first line, and one without. Both these formats are supported by py_entitymatching.</p>
<p>An example of a CSV file with attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
<p>An example of a CSV file with out attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-file-format">
<h3>Metadata File Format<a class="headerlink" href="#metadata-file-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV file can be accompanied with a metadata file containing the metadata information
of the table. Typically, it contains information such as key, foreign key, etc.
The metadata file is expected to be of the same name as the CSV file but with <cite>.metadata</cite>
extension. For example, if the CSV file <cite>table_A.csv</cite> contains table A’s data, then
<cite>table_A.metadata</cite> will contain table A’s metadata. So, the metadata is
associated based on the names of the files. The metadata file contains key-value pairs
one per line and each line starts with ‘#’.</p>
<p>An example of metadata file is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>In the above, the pair key=ID states that ID is the key attribute.</p>
</div>
<div class="section" id="writing-a-dataframe-to-disk-along-with-its-metadata">
<h3>Writing a Dataframe to Disk Along With Its Metadata<a class="headerlink" href="#writing-a-dataframe-to-disk-along-with-its-metadata" title="Permalink to this headline">¶</a></h3>
<p>To write a Dataframe to disk along with its metadata, you can use <cite>to_csv_metadata</cite>
command in py_entitymatching. An example of using <cite>to_csv_metadata</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./table_A.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first write Dataframe pointed by <cite>A</cite> to <cite>table_A.csv</cite> file in the
disk (in CSV format), next it will write the metadata of <cite>table A</cite> stored in the Catalog
to <cite>table_A.metadata</cite> file in the disk.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_csv_metadata()</span></code> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once the Dataframe is written to disk along with metadata, it can read using <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> command.</p>
</div>
</div>
<div class="section" id="writing-reading-other-types-of-py-entitymatching-objects">
<h3>Writing/Reading Other Types of py_entitymatching Objects<a class="headerlink" href="#writing-reading-other-types-of-py-entitymatching-objects" title="Permalink to this headline">¶</a></h3>
<p>After creating a blocker or feature table, it is desirable to have a
way to persist the objects to disk for future use. py_entitymatching provides
two commands for that purpose: <cite>save_object</cite> and <cite>load_object</cite>.</p>
<p>An example of using <cite>save_object</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">([</span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>load_object</cite> loads the stored object from disk. An example of using <cite>load_object</cite> is
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code> for more details.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/overview"></span><div class="section" id="overview-of-command-organization">
<h2>Overview of Command Organization<a class="headerlink" href="#overview-of-command-organization" title="Permalink to this headline">¶</a></h2>
<p>The commands are organized into two parts. First, the commands that the user will typically use to
create an entity matching workflow. Second, a set of experimental commands that are expected to be
useful to create an entity matching workflow. Specifically, it includes commands  such
as  dask-based implementations for blockers and combining predictions from a set of matchers.
However, the experimental commands are not tested, so use these commands at your own risk.</p>
</div>
<span id="document-user_manual/api/actual_commands"></span><div class="section" id="commands-in-py-entitymatching">
<h2>Commands in py_entitymatching<a class="headerlink" href="#commands-in-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/reading_and_writing_data"></span><div class="section" id="reading-and-writing-data">
<h3>Reading and Writing Data<a class="headerlink" href="#reading-and-writing-data" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/loading_and_saving_objects"></span><div class="section" id="loading-and-saving-objects">
<h3>Loading and Saving Objects<a class="headerlink" href="#loading-and-saving-objects" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/handling_metadata"></span><div class="section" id="handling-metadata">
<span id="label-handling-metadata"></span><h3>Handling Metadata<a class="headerlink" href="#handling-metadata" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/downsampling"></span><div class="section" id="downsampling">
<h3>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/blocking"></span><div class="section" id="blocking">
<h3>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/debugging_blocker_output"></span><div class="section" id="debugging-blocker-output">
<h3>Debugging Blocker Output<a class="headerlink" href="#debugging-blocker-output" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/combining_blocker_outputs"></span><div class="section" id="combining-blocker-outputs">
<h3>Combining Blocker Outputs<a class="headerlink" href="#combining-blocker-outputs" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/sampling"></span><div class="section" id="sampling">
<h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/handling_features"></span><div class="section" id="handling-features">
<h3>Handling Features<a class="headerlink" href="#handling-features" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/creating_the_features_automatically"></span><div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/creating_the_features_manually"></span><div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/adding_features"></span><div class="section" id="adding-features-to-feature-table">
<h4>Adding Features to Feature Table<a class="headerlink" href="#adding-features-to-feature-table" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/extracting_feature_vectors"></span><div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h4>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_similarity_functions"></span><div class="section" id="supported-similarity-functions">
<h4>Supported Similarity Functions<a class="headerlink" href="#supported-similarity-functions" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_tokenizers"></span><div class="section" id="supported-tokenizers">
<h4>Supported Tokenizers<a class="headerlink" href="#supported-tokenizers" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
<span id="document-user_manual/api/matching"></span><div class="section" id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/splitting_data_into_train_test"></span><div class="section" id="splitting-data-into-train-and-test">
<h4>Splitting Data into Train and Test<a class="headerlink" href="#splitting-data-into-train-and-test" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_matchers"></span><div class="section" id="supported-matchers">
<h4>Supported Matchers<a class="headerlink" href="#supported-matchers" title="Permalink to this headline">¶</a></h4>
<div class="section" id="ml-matchers">
<h5>ML Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="rule-based-matcher">
<h5>Rule-Based Matcher<a class="headerlink" href="#rule-based-matcher" title="Permalink to this headline">¶</a></h5>
</div>
</div>
<span id="document-user_manual/api/selecting_matcher"></span><div class="section" id="selecting-matcher">
<h4>Selecting Matcher<a class="headerlink" href="#selecting-matcher" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
<span id="document-user_manual/api/debugging_matcher"></span><div class="section" id="debugging-matcher">
<h3>Debugging Matcher<a class="headerlink" href="#debugging-matcher" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/triggers"></span><div class="section" id="triggers">
<h3>Triggers<a class="headerlink" href="#triggers" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/evaluating_the_matching_output"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>
<div class="section" id="experimental-commands">
<h2>Experimental Commands<a class="headerlink" href="#experimental-commands" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/dask_commands"></span><div class="section" id="commands-implemented-using-dask">
<h3>Commands Implemented Using Dask<a class="headerlink" href="#commands-implemented-using-dask" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="blocking">
<h4>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<span id="document-user_manual/api/tuners"></span><div class="section" id="tuners-for-the-dask-based-commands">
<h3>Tuners for the Dask-based Commands<a class="headerlink" href="#tuners-for-the-dask-based-commands" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="overlap-blocker">
<h4>Overlap Blocker<a class="headerlink" href="#overlap-blocker" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<span id="document-user_manual/api/combiner"></span><div class="section" id="matcher-combiner">
<h3>Matcher Combiner<a class="headerlink" href="#matcher-combiner" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-contributing"></span><div class="section" id="contributing-to-py-entitymatching">
<span id="contributing"></span><h2><a class="toc-backref" href="#id1">Contributing to py_entitymatching</a><a class="headerlink" href="#contributing-to-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#contributing-to-py-entitymatching" id="id1">Contributing to py_entitymatching</a></p>
<ul>
<li><p><a class="reference internal" href="#where-to-start" id="id2">Where to start?</a></p></li>
<li><p><a class="reference internal" href="#bug-reports-and-enhancement-requests" id="id3">Bug reports and enhancement requests</a></p></li>
<li><p><a class="reference internal" href="#working-with-the-code" id="id4">Working with the code</a></p>
<ul>
<li><p><a class="reference internal" href="#version-control-git-and-github" id="id5">Version control, Git, and GitHub</a></p></li>
<li><p><a class="reference internal" href="#getting-started-with-git" id="id6">Getting started with Git</a></p></li>
<li><p><a class="reference internal" href="#forking" id="id7">Forking</a></p></li>
<li><p><a class="reference internal" href="#creating-a-branch" id="id8">Creating a branch</a></p></li>
<li><p><a class="reference internal" href="#creating-a-development-environment" id="id9">Creating a development environment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-to-the-documentation" id="id10">Contributing to the documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#about-the-py-entitymatching-documentation" id="id11">About the <em>py_entitymatching</em> documentation</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-the-py-entitymatching-documentation" id="id12">How to build the <em>py_entitymatching</em> documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#requirements" id="id13">Requirements</a></p></li>
<li><p><a class="reference internal" href="#building-the-documentation" id="id14">Building the documentation</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-to-the-code-base" id="id15">Contributing to the code base</a></p>
<ul>
<li><p><a class="reference internal" href="#code-standards" id="id16">Code standards</a></p></li>
<li><p><a class="reference internal" href="#writing-tests" id="id17">Writing tests</a></p>
<ul>
<li><p><a class="reference internal" href="#unit-testing" id="id18">Unit testing</a></p></li>
<li><p><a class="reference internal" href="#performance-testing" id="id19">Performance testing</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-your-changes-to-py-entitymatching" id="id20">Contributing your changes to <em>py_entitymatching</em></a></p>
<ul>
<li><p><a class="reference internal" href="#committing-your-code" id="id21">Committing your code</a></p></li>
<li><p><a class="reference internal" href="#combining-commits" id="id22">Combining commits</a></p></li>
<li><p><a class="reference internal" href="#pushing-your-changes" id="id23">Pushing your changes</a></p></li>
<li><p><a class="reference internal" href="#review-your-code" id="id24">Review your code</a></p></li>
<li><p><a class="reference internal" href="#finally-make-the-pull-request" id="id25">Finally, make the pull request</a></p></li>
<li><p><a class="reference internal" href="#delete-your-merged-branch-optional" id="id26">Delete your merged branch (optional)</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">local</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p>This document is adapted from <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/contributing.html">pandas how to contribute guidelines</a> for
<em>py_entitymatching</em> package.</p>
<div class="section" id="where-to-start">
<h3><a class="toc-backref" href="#id2">Where to start?</a><a class="headerlink" href="#where-to-start" title="Permalink to this headline">¶</a></h3>
<p>All contributions, bug reports, bug fixes, documentation improvements,
enhancements and ideas are welcome.</p>
<p>If you are simply looking to start working with the <em>py_entitymatching</em> codebase, navigate to the
<a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching/issues">GitHub “issues” tab</a> and start looking through
interesting issues.</p>
<p>Or maybe through using <em>py_entitymatching</em> you have an idea of your own or are looking for something
in the documentation and thinking ‘this can be improved’…you can do something
about it!</p>
<p>Feel free to ask questions on the <a class="reference external" href="https://groups.google.com/forum/#!forum/py_entitymatching">mailing list</a></p>
</div>
<div class="section" id="bug-reports-and-enhancement-requests">
<h3><a class="toc-backref" href="#id3">Bug reports and enhancement requests</a><a class="headerlink" href="#bug-reports-and-enhancement-requests" title="Permalink to this headline">¶</a></h3>
<p>Bug reports are an important part of making <em>py_entitymatching</em> more stable.Having a
complete bug report will allow others to reproduce the bug and provide insight into
fixing. We use GitHub issue tracker to track bugs. It is important that you provide the
exact version of <em>py_entitymatching</em> where the bug is found. Trying the bug-producing
code out on the <em>master</em> branch is often a worthwhile exercise to confirm the bug still
exists. It is also worth searching existing bug reports and pull requests to see if the
issue has already been reported and/or fixed.</p>
<p>Bug reports must:</p>
<ol class="arabic">
<li><p>Include a short, self-contained Python snippet reproducing the problem.
You can format the code nicely by using <a class="reference external" href="http://github.github.com/github-flavored-markdown/">GitHub Flavored Markdown</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```python
&gt;&gt;&gt; import py_entitymatching as em
&gt;&gt;&gt; em.down_sample(...)
...
```
</pre></div>
</div>
</li>
<li><p>Include the full version string of <em>py_entitymatching</em>. You can find the version as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">__version__</span>
</pre></div>
</div>
</li>
<li><p>Explain why the current behavior is wrong/not desired and what you expect instead.</p></li>
</ol>
<p>The issue will then show up to the <em>py_entitymatching</em> community and be open to
comments/ideas from others.</p>
</div>
<div class="section" id="working-with-the-code">
<h3><a class="toc-backref" href="#id4">Working with the code</a><a class="headerlink" href="#working-with-the-code" title="Permalink to this headline">¶</a></h3>
<p>Now that you have an issue you want to fix, enhancement to add, or documentation to
improve, you need to learn how to work with GitHub and the <em>py_entitymatching</em> code base.</p>
<div class="section" id="version-control-git-and-github">
<h4><a class="toc-backref" href="#id5">Version control, Git, and GitHub</a><a class="headerlink" href="#version-control-git-and-github" title="Permalink to this headline">¶</a></h4>
<p>To the new user, working with Git is one of the more daunting aspects of contributing
to <em>py_entitymatching</em>. It can very quickly become overwhelming, but sticking to the
guidelines below will help keep the process straightforward and mostly trouble free.
As always, if you are having difficulties please feel free to ask for help.</p>
<p>The code is hosted on <a class="reference external" href="https://www.github.com/anhaidgroup/py_entitymatching">GitHub</a>. To
contribute you will need to sign up for a <a class="reference external" href="https://github.com/signup/free">free GitHub account</a>. We use <a class="reference external" href="http://git-scm.com/">Git</a> for
version control to allow many people to work together on the project.</p>
<p>Some great resources for learning Git:</p>
<ul class="simple">
<li><p>the <a class="reference external" href="http://help.github.com/">GitHub help pages</a>.</p></li>
<li><p>the <a class="reference external" href="http://docs.scipy.org/doc/numpy/dev/index.html">NumPy’s documentation</a>.</p></li>
<li><p>Matthew Brett’s <a class="reference external" href="http://matthew-brett.github.com/pydagogue/">Pydagogue</a>.</p></li>
</ul>
</div>
<div class="section" id="getting-started-with-git">
<h4><a class="toc-backref" href="#id6">Getting started with Git</a><a class="headerlink" href="#getting-started-with-git" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://help.github.com/set-up-git-redirect">GitHub has instructions</a> for installing git,
setting up your SSH key, and configuring git.  All these steps need to be completed before
you can work seamlessly between your local repository and GitHub.</p>
</div>
<div class="section" id="forking">
<span id="contributing-forking"></span><h4><a class="toc-backref" href="#id7">Forking</a><a class="headerlink" href="#forking" title="Permalink to this headline">¶</a></h4>
<p>You will need your own fork to work on the code. Go to the <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching">py_entitymatching project
page</a> and hit the <code class="docutils literal notranslate"><span class="pre">Fork</span></code> button. You will
want to clone your fork to your machine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">your</span><span class="o">-</span><span class="n">user</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="o">&lt;</span><span class="n">local</span><span class="o">-</span><span class="n">repo</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
<span class="n">cd</span> <span class="o">&lt;</span><span class="n">local</span><span class="o">-</span><span class="n">repo</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
<span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">upstream</span> <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>This creates the directory <cite>local-repo-name</cite> and connects your repository to
the upstream (main project) <em>py_entitymatching</em> repository.</p>
<p>The testing suite will run automatically on Travis-CI once your pull request is
submitted.  However, if you wish to run the test suite on a branch prior to
submitting the pull request, then Travis-CI needs to be hooked up to your
GitHub repository.  Instructions for doing so are <a class="reference external" href="http://about.travis-ci.org/docs/user/getting-started/">here</a>.</p>
</div>
<div class="section" id="creating-a-branch">
<h4><a class="toc-backref" href="#id8">Creating a branch</a><a class="headerlink" href="#creating-a-branch" title="Permalink to this headline">¶</a></h4>
<p>You want your master branch to reflect only production-ready code, so create a
feature branch for making your changes. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">branch</span> <span class="n">new_feature</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>The above can be simplified to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>This changes your working directory to the <em>new_feature</em> branch.  Keep any
changes in this branch specific to one bug or feature so it is clear
what the branch brings to <em>py_entitymatching</em>. You can have many new features
and switch in between them using the git checkout command.</p>
<p>To update this branch, you need to retrieve the changes from the master branch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
<span class="n">git</span> <span class="n">rebase</span> <span class="n">upstream</span><span class="o">/</span><span class="n">master</span>
</pre></div>
</div>
<p>This will replay your commits on top of the lastest py_entitymatching git master.  If this
leads to merge conflicts, you must resolve them before submitting your pull
request.  If you have uncommitted changes, you will need to <code class="docutils literal notranslate"><span class="pre">stash</span></code> them prior
to updating.  This will effectively store your changes and they can be reapplied
after updating.</p>
</div>
<div class="section" id="creating-a-development-environment">
<span id="contributing-dev-env"></span><h4><a class="toc-backref" href="#id9">Creating a development environment</a><a class="headerlink" href="#creating-a-development-environment" title="Permalink to this headline">¶</a></h4>
<p>An easy way to create a <em>py_entitymatching</em> development environment is as follows.</p>
<ul class="simple">
<li><p>Install either <span class="xref std std-ref">Anaconda</span> or <span class="xref std std-ref">miniconda</span></p></li>
<li><p>Make sure that you have <a class="reference internal" href="#contributing-forking"><span class="std std-ref">cloned the repository</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cd</span></code> to the <em>py_entitymatching</em> source directory</p></li>
</ul>
<p>Tell conda to create a new environment, named <code class="docutils literal notranslate"><span class="pre">py_entitymatching_dev</span></code>, or any other
name you would like for this environment, by running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="o">--</span><span class="n">file</span> <span class="n">requirements</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>For a python 3 environment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">python</span><span class="o">=</span><span class="mi">3</span> <span class="o">--</span><span class="n">file</span> <span class="n">requirements</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>This will create the new environment, and not touch any of your existing environments,
nor any existing python installation. It will install all of the basic dependencies of
<em>py_entitymatching</em>. You need to install the <em>nose</em> package which is used for
testing, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">nose</span>
</pre></div>
</div>
<p>To work in this environment, Windows users should <code class="docutils literal notranslate"><span class="pre">activate</span></code> it as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">activate</span> <span class="n">py_entitymatching_dev</span>
</pre></div>
</div>
<p>Mac OSX / Linux users should use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="n">activate</span> <span class="n">py_entitymatching_dev</span>
</pre></div>
</div>
<p>You will then see a confirmation message to indicate you are in the new development environment.</p>
<p>To view your environments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">info</span> <span class="o">-</span><span class="n">e</span>
</pre></div>
</div>
<p>To return to your home root environment in Windows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deactivate</span>
</pre></div>
</div>
<p>To return to your home root environment in OSX / Linux:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="n">deactivate</span>
</pre></div>
</div>
<p>See the full conda docs <a class="reference external" href="http://conda.pydata.org/docs">here</a>.</p>
</div>
</div>
<div class="section" id="contributing-to-the-documentation">
<span id="contributing-documentation"></span><h3><a class="toc-backref" href="#id10">Contributing to the documentation</a><a class="headerlink" href="#contributing-to-the-documentation" title="Permalink to this headline">¶</a></h3>
<p>If you’re not the developer type, contributing to the documentation is still
of huge value. You don’t even have to be an expert on
<em>py_entitymatching</em> to do so! Something as simple as rewriting small passages for clarity
as you reference the docs is a simple but effective way to contribute. The
next person to read that passage will be in your debt!</p>
<p>In fact, there are sections of the docs that are worse off after being written
by experts. If something in the docs doesn’t make sense to you, updating the
relevant section after you figure it out is a simple way to ensure it will
help the next person.</p>
<div class="contents local topic" id="documentation">
<p class="topic-title">Documentation:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#about-the-py-entitymatching-documentation" id="id27">About the <em>py_entitymatching</em> documentation</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-the-py-entitymatching-documentation" id="id28">How to build the <em>py_entitymatching</em> documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#requirements" id="id29">Requirements</a></p></li>
<li><p><a class="reference internal" href="#building-the-documentation" id="id30">Building the documentation</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="about-the-py-entitymatching-documentation">
<h4><a class="toc-backref" href="#id27">About the <em>py_entitymatching</em> documentation</a><a class="headerlink" href="#about-the-py-entitymatching-documentation" title="Permalink to this headline">¶</a></h4>
<p>The documentation is written in <strong>reStructuredText</strong>, which is almost like writing
in plain English, and built using <a class="reference external" href="http://sphinx.pocoo.org/">Sphinx</a>. The
Sphinx Documentation has an excellent <a class="reference external" href="http://sphinx.pocoo.org/rest.html">introduction to reST</a>. Review the Sphinx docs to perform more
complex changes to the documentation as well.</p>
<p>Some other important things to know about the docs:</p>
<ul>
<li><p>The <em>py_entitymatching</em> documentation consists of two parts: the docstrings in the code
itself and the docs in this folder <code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/</span></code>.</p>
<p>The docstrings provide a clear explanation of the usage of the individual
functions, while the documentation in this folder consists of tutorial-like
overviews per topic together with some other information (what’s new,
installation, etc).</p>
</li>
<li><p>The docstrings follow the <strong>Google Docstring Standard</strong>. This standard specifies the format of
the different sections of the docstring. See <a class="reference external" href="http://www.sphinx-doc.org/en/stable/ext/example_google.html">this document</a>
for a detailed explanation, or look at some of the existing functions to
extend it in a similar manner.</p></li>
</ul>
</div>
<div class="section" id="how-to-build-the-py-entitymatching-documentation">
<h4><a class="toc-backref" href="#id28">How to build the <em>py_entitymatching</em> documentation</a><a class="headerlink" href="#how-to-build-the-py-entitymatching-documentation" title="Permalink to this headline">¶</a></h4>
<div class="section" id="requirements">
<h5><a class="toc-backref" href="#id29">Requirements</a><a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h5>
<p>To build the <em>py_entitymatching</em> docs there are some extra requirements: you will need to
have <code class="docutils literal notranslate"><span class="pre">sphinx</span></code> and <code class="docutils literal notranslate"><span class="pre">ipython</span></code> installed.</p>
<p>It is easiest to <a class="reference internal" href="#contributing-dev-env"><span class="std std-ref">create a development environment</span></a>, then install:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">sphinx</span> <span class="n">sphinx_rtd_theme</span> <span class="n">ipython</span>
</pre></div>
</div>
</div>
<div class="section" id="building-the-documentation">
<h5><a class="toc-backref" href="#id30">Building the documentation</a><a class="headerlink" href="#building-the-documentation" title="Permalink to this headline">¶</a></h5>
<p>So how do you build the docs? Navigate to your local
<code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/</span></code> directory in the console and run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">html</span>
</pre></div>
</div>
<p>Then you can find the HTML output in the folder <code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/_build/html/</span></code>.</p>
<p>If you want to do a full clean build, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">clean</span> <span class="n">html</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="contributing-to-the-code-base">
<span id="contributing-dev-docs"></span><h3><a class="toc-backref" href="#id15">Contributing to the code base</a><a class="headerlink" href="#contributing-to-the-code-base" title="Permalink to this headline">¶</a></h3>
<div class="contents local topic" id="code-base">
<p class="topic-title">Code Base:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#code-standards" id="id31">Code standards</a></p></li>
<li><p><a class="reference internal" href="#writing-tests" id="id32">Writing tests</a></p>
<ul>
<li><p><a class="reference internal" href="#unit-testing" id="id33">Unit testing</a></p></li>
<li><p><a class="reference internal" href="#performance-testing" id="id34">Performance testing</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="code-standards">
<h4><a class="toc-backref" href="#id31">Code standards</a><a class="headerlink" href="#code-standards" title="Permalink to this headline">¶</a></h4>
<p><em>py_entitymatching</em> follows <a class="reference external" href="https://google.github.io/styleguide/pyguide.html">Google Python Style Guide</a>.</p>
<p>Please try to maintain backward compatibility. <em>py_entitymatching</em> has lots of users with lots of
existing code, so don’t break it if at all possible.  If you think breakage is required,
clearly state why as part of the pull request.  Also, be careful when changing method
signatures and add deprecation warnings where needed.</p>
</div>
<div class="section" id="writing-tests">
<h4><a class="toc-backref" href="#id32">Writing tests</a><a class="headerlink" href="#writing-tests" title="Permalink to this headline">¶</a></h4>
<p>Adding tests is one of the most common requests after code is pushed to <em>py_entitymatching</em>.  Therefore,
it is worth getting in the habit of writing tests ahead of time so this is never an issue.</p>
<div class="section" id="unit-testing">
<h5><a class="toc-backref" href="#id33">Unit testing</a><a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h5>
<p>Like many packages, <em>py_entitymatching</em> uses the <a class="reference external" href="http://nose.readthedocs.org/en/latest/index.html">Nose testing system</a>.</p>
<p>All tests should go into the <code class="docutils literal notranslate"><span class="pre">tests</span></code> subdirectory of the specific package.
This folder contains many current examples of tests, and we suggest looking to these for
inspiration.</p>
<p>The tests can then be run directly inside your Git clone (without having to
install <em>py_entitymatching</em>) by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nosetests</span>
</pre></div>
</div>
</div>
<div class="section" id="performance-testing">
<h5><a class="toc-backref" href="#id34">Performance testing</a><a class="headerlink" href="#performance-testing" title="Permalink to this headline">¶</a></h5>
<p>Performance matters and it is worth considering whether your code has introduced
performance regressions.  <em>py_entitymatching</em> uses
<a class="reference external" href="https://github.com/spacetelescope/asv">asv</a> for performance testing.
The benchmark test cases are all found in the <code class="docutils literal notranslate"><span class="pre">benchmarks/asv_benchmarks</span></code> directory.  asv
supports both python2 and python3.</p>
<p>To install asv:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">spacetelescope</span><span class="o">/</span><span class="n">asv</span>
</pre></div>
</div>
<p>If you need to run a benchmark, run the following from the <code class="docutils literal notranslate"><span class="pre">benchmarks</span></code> directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asv</span> <span class="n">run</span>
</pre></div>
</div>
<p>This command uses <code class="docutils literal notranslate"><span class="pre">conda</span></code> by default for creating the benchmark environments.</p>
<p>Information on how to write a benchmark and how to use asv can be found in the
<a class="reference external" href="http://asv.readthedocs.org/en/latest/writing_benchmarks.html">asv documentation</a>.</p>
</div>
</div>
</div>
<div class="section" id="contributing-your-changes-to-py-entitymatching">
<h3><a class="toc-backref" href="#id20">Contributing your changes to <em>py_entitymatching</em></a><a class="headerlink" href="#contributing-your-changes-to-py-entitymatching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="committing-your-code">
<h4><a class="toc-backref" href="#id21">Committing your code</a><a class="headerlink" href="#committing-your-code" title="Permalink to this headline">¶</a></h4>
<p>Finally, commit your changes to your local repository with an explanatory message.</p>
<p>The following defines how a commit message should be structured.  Please reference the
relevant GitHub issues in your commit message using GH1234 or #1234.  Either style
is fine, but the former is generally preferred:</p>
<blockquote>
<div><ul class="simple">
<li><p>a subject line with <cite>&lt; 80</cite> chars.</p></li>
<li><p>One blank line.</p></li>
<li><p>Optionally, a commit message body.</p></li>
</ul>
</div></blockquote>
<p>Now you can commit your changes in your local repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-commits">
<h4><a class="toc-backref" href="#id22">Combining commits</a><a class="headerlink" href="#combining-commits" title="Permalink to this headline">¶</a></h4>
<p>If you have multiple commits, you may want to combine them into one commit, often
referred to as “squashing” or “rebasing”.  This is a common request by package maintainers
when submitting a pull request as it maintains a more compact commit history.  To rebase
your commits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">rebase</span> <span class="o">-</span><span class="n">i</span> <span class="n">HEAD</span><span class="o">~</span><span class="c1">#</span>
</pre></div>
</div>
<p>Where # is the number of commits you want to combine.  Then you can pick the relevant
commit message and discard others.</p>
<p>To squash to the master branch do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">rebase</span> <span class="o">-</span><span class="n">i</span> <span class="n">master</span>
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">s</span></code> option on a commit to <code class="docutils literal notranslate"><span class="pre">squash</span></code>, meaning to keep the commit messages,
or <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">fixup</span></code>, meaning to merge the commit messages.</p>
<p>Then you will need to push the branch (see below) forcefully to replace the current
commits with the new ones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">new_feature</span> <span class="o">-</span><span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="pushing-your-changes">
<h4><a class="toc-backref" href="#id23">Pushing your changes</a><a class="headerlink" href="#pushing-your-changes" title="Permalink to this headline">¶</a></h4>
<p>When you want your changes to appear publicly on your GitHub page, push your
forked feature branch’s commits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">origin</span></code> is the default name given to your remote repository on GitHub.
You can see the remote repositories:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">remote</span> <span class="o">-</span><span class="n">v</span>
</pre></div>
</div>
<p>If you added the upstream repository as described above you will see something
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">origin</span>  <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">yourname</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
<span class="n">origin</span>  <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">yourname</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
<span class="n">upstream</span>        <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
<span class="n">upstream</span>        <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</pre></div>
</div>
<p>Now your code is on GitHub, but it is not yet a part of the <em>py_entitymatching</em> project.  For that to
happen, a pull request needs to be submitted on GitHub.</p>
</div>
<div class="section" id="review-your-code">
<h4><a class="toc-backref" href="#id24">Review your code</a><a class="headerlink" href="#review-your-code" title="Permalink to this headline">¶</a></h4>
<p>When you’re ready to ask for a code review, file a pull request. Before you do, once
again make sure that you have followed all the guidelines outlined in this document
regarding code style, tests, performance tests, and documentation. You should also
double check your branch changes against the branch it was based on:</p>
<ol class="arabic simple">
<li><p>Navigate to your repository on GitHub – <a class="reference external" href="https://github.com">https://github.com</a>/&lt;your-user-name&gt;/py_entitymatching</p></li>
<li><p>Click on <code class="docutils literal notranslate"><span class="pre">Branches</span></code></p></li>
<li><p>Click on the <code class="docutils literal notranslate"><span class="pre">Compare</span></code> button for your feature branch</p></li>
<li><p>Select the <code class="docutils literal notranslate"><span class="pre">base</span></code> and <code class="docutils literal notranslate"><span class="pre">compare</span></code> branches, if necessary. This will be <code class="docutils literal notranslate"><span class="pre">master</span></code> and
<code class="docutils literal notranslate"><span class="pre">new_feature</span></code>, respectively.</p></li>
</ol>
</div>
<div class="section" id="finally-make-the-pull-request">
<h4><a class="toc-backref" href="#id25">Finally, make the pull request</a><a class="headerlink" href="#finally-make-the-pull-request" title="Permalink to this headline">¶</a></h4>
<p>If everything looks good, you are ready to make a pull request.  A pull request is how
code from a local repository becomes available to the GitHub community and can be looked
at and eventually merged into the master version.  This pull request and its associated
changes will eventually be committed to the master branch and available in the next
release.  To submit a pull request:</p>
<ol class="arabic simple">
<li><p>Navigate to your repository on GitHub</p></li>
<li><p>Click on the <code class="docutils literal notranslate"><span class="pre">Pull</span> <span class="pre">Request</span></code> button</p></li>
<li><p>You can then click on <code class="docutils literal notranslate"><span class="pre">Commits</span></code> and <code class="docutils literal notranslate"><span class="pre">Files</span> <span class="pre">Changed</span></code> to make sure everything looks
okay one last time</p></li>
<li><p>Write a description of your changes.</p></li>
<li><p>Click <code class="docutils literal notranslate"><span class="pre">Send</span> <span class="pre">Pull</span> <span class="pre">Request</span></code>.</p></li>
</ol>
<p>This request then goes to the repository maintainers, and they will review
the code. If you need to make more changes, you can make them in
your branch, push them to GitHub, and the pull request will be automatically
updated.  Pushing them to GitHub again is done by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="o">-</span><span class="n">f</span> <span class="n">origin</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>This will automatically update your pull request with the latest code and restart the
Travis-CI tests.</p>
</div>
<div class="section" id="delete-your-merged-branch-optional">
<h4><a class="toc-backref" href="#id26">Delete your merged branch (optional)</a><a class="headerlink" href="#delete-your-merged-branch-optional" title="Permalink to this headline">¶</a></h4>
<p>Once your feature branch is accepted into upstream, you’ll probably want to get rid of
the branch. First, merge upstream master into your branch so git knows it is safe to
delete your branch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">master</span>
<span class="n">git</span> <span class="n">merge</span> <span class="n">upstream</span><span class="o">/</span><span class="n">master</span>
</pre></div>
</div>
<p>Then you can just do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>Make sure you use a lower-case <code class="docutils literal notranslate"><span class="pre">-d</span></code>, or else git won’t warn you if your feature
branch has not actually been merged.</p>
<p>The branch will still exist on GitHub, so to delete it there do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">new_feature</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016, anhaidgroup

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>