

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>py_entitymatching.feature.autofeaturegen &mdash; py_entitymatching 0.4.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> py_entitymatching
          

          
          </a>

          
            
            
              <div class="version">
                0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to_guide.html">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/whatisnew.html">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/overview.html">Overview of Supported EM Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/guides.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/datastructures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/steps_supp_em_workflows.html">Steps of Supported EM Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/misc.html">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/api/overview.html">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/api/actual_commands.html">Commands in py_entitymatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/api/actual_commands.html#experimental-commands">Experimental Commands</a></li>
</ul>
<p class="caption"><span class="caption-text">How to Contribute</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to py_entitymatching</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">py_entitymatching</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>py_entitymatching.feature.autofeaturegen</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for py_entitymatching.feature.autofeaturegen</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functions for auto feature generation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">py_entitymatching.utils.validation_helper</span> <span class="kn">import</span> <span class="n">validate_object_type</span>

<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

<span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="kn">import</span> <span class="nn">py_entitymatching.feature.attributeutils</span> <span class="k">as</span> <span class="nn">au</span>
<span class="kn">import</span> <span class="nn">py_entitymatching.feature.simfunctions</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="kn">import</span> <span class="nn">py_entitymatching.feature.tokenizers</span> <span class="k">as</span> <span class="nn">tok</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="get_features"><a class="viewcode-back" href="../../../user_manual/api/creating_the_features_manually.html#py_entitymatching.get_features">[docs]</a><span class="k">def</span> <span class="nf">get_features</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">l_attr_types</span><span class="p">,</span> <span class="n">r_attr_types</span><span class="p">,</span>
                 <span class="n">attr_corres</span><span class="p">,</span> <span class="n">tok_funcs</span><span class="p">,</span> <span class="n">sim_funcs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will automatically generate a set of features based on the</span>
<span class="sd">    attributes of the input tables.</span>

<span class="sd">    Specifically, this function will go through the attribute</span>
<span class="sd">    correspondences between the input tables. For each correspondence ,</span>
<span class="sd">    it examines the types of the involved attributes, then apply the</span>
<span class="sd">    appropriate tokenizers and sim functions to generate all appropriate</span>
<span class="sd">    features for this correspondence.</span>

<span class="sd">    Args:</span>
<span class="sd">        ltable,rtable (DataFrame): The pandas DataFrames for which the</span>
<span class="sd">            features must be generated.</span>
<span class="sd">        l_attr_types,r_attr_types (dictionary): The attribute types for the</span>
<span class="sd">            input DataFrames. Typically this is generated using the</span>
<span class="sd">            function &#39;get_attr_types&#39;.</span>
<span class="sd">        attr_corres (dictionary): The attribute correspondences between the</span>
<span class="sd">            input DataFrames.</span>
<span class="sd">        tok_funcs (dictionary): A Python dictionary containing tokenizer</span>
<span class="sd">            functions.</span>
<span class="sd">        sim_funcs (dictionary): A Python dictionary containing similarity</span>
<span class="sd">            functions.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A pandas DataFrame containing automatically generated features.</span>
<span class="sd">        Specifically, the DataFrame contains the following attributes:</span>
<span class="sd">        &#39;feature_name&#39;, &#39;left_attribute&#39;, &#39;right_attribute&#39;,</span>
<span class="sd">        &#39;left_attr_tokenizer&#39;, &#39;right_attr_tokenizer&#39;, &#39;simfunction&#39;,</span>
<span class="sd">        &#39;function&#39;, &#39;function_source&#39;, &#39;is_auto_generated&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `ltable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `rtable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `l_attr_types` is not of type</span>
<span class="sd">            python dictionary.</span>
<span class="sd">        AssertionError: If `r_attr_types` is not of type</span>
<span class="sd">            python dictionary.</span>
<span class="sd">        AssertionError: If `attr_corres` is not of type</span>
<span class="sd">            python dictionary.</span>
<span class="sd">        AssertionError: If `sim_funcs` is not of type</span>
<span class="sd">            python dictionary.</span>
<span class="sd">        AssertionError: If `tok_funcs` is not of type</span>
<span class="sd">            python dictionary.</span>
<span class="sd">        AssertionError: If the `ltable` and `rtable` order is same as mentioned</span>
<span class="sd">            in the `l_attr_types`/`r_attr_types` and `attr_corres`.</span>

<span class="sd">    Examples:</span>

<span class="sd">        &gt;&gt;&gt; import py_entitymatching as em</span>
<span class="sd">        &gt;&gt;&gt; A = em.read_csv_metadata(&#39;path_to_csv_dir/table_A.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = em.read_csv_metadata(&#39;path_to_csv_dir/table_B.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; match_t = em.get_tokenizers_for_matching()</span>
<span class="sd">        &gt;&gt;&gt; match_s = em.get_sim_funs_for_matching()</span>
<span class="sd">        &gt;&gt;&gt; atypes1 = em.get_attr_types(A) # don&#39;t need, if atypes1 exists from blocking step</span>
<span class="sd">        &gt;&gt;&gt; atypes2 = em.get_attr_types(B) # don&#39;t need, if atypes2 exists from blocking step</span>
<span class="sd">        &gt;&gt;&gt; match_c = em.get_attr_corres(A, B)</span>
<span class="sd">        &gt;&gt;&gt; match_f = em.get_features(A, B, atypes1, atype2, match_c, match_t, match_s)</span>

<span class="sd">    See Also:</span>
<span class="sd">     :meth:`py_entitymatching.get_attr_corres`, :meth:`py_entitymatching.get_attr_types`,</span>
<span class="sd">     :meth:`py_entitymatching.get_sim_funs_for_blocking`,</span>
<span class="sd">     :meth:`py_entitymatching.get_tokenizers_for_blocking`,</span>
<span class="sd">     :meth:`py_entitymatching.get_sim_funs_for_matching`,</span>
<span class="sd">     :meth:`py_entitymatching.get_tokenizers_for_matching`</span>


<span class="sd">    Note:</span>
<span class="sd">        In the output DataFrame, two</span>
<span class="sd">        attributes demand some explanation: (1)function, and (2)</span>
<span class="sd">        is_auto_generated. The function, points to the actual python function</span>
<span class="sd">        that implements feature. Specifically, the function takes in two</span>
<span class="sd">        tuples (one from each input table) and returns a numeric value. The</span>
<span class="sd">        attribute is_auto_generated contains either True or False. The flag</span>
<span class="sd">        is True only if the feature is automatically generated by py_entitymatching.</span>
<span class="sd">        This is important because this flag is used to make some assumptions</span>
<span class="sd">        about the semantics of the similarity function used and use that</span>
<span class="sd">        information for scaling purposes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input parameters</span>
    <span class="c1"># # We expect the ltable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input ltable&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the rtable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">rtable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input rtable&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the l_attr_types to be of type python dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">l_attr_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Input l_attr_types&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the r_attr_types to be of type python dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">r_attr_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Input r_attr_types&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the attr_corres to be of type python dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">attr_corres</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Input attr_corres&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the tok_funcs to be of type python dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">tok_funcs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Input tok_funcs&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the sim_funcs to be of type python dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">sim_funcs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Input sim_funcs&#39;</span><span class="p">)</span>

    <span class="c1"># We expect the table order to be same in l/r_attr_types and attr_corres</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_check_table_order</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span>
                              <span class="n">l_attr_types</span><span class="p">,</span> <span class="n">r_attr_types</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Table order is different than what is mentioned &#39;</span>
                     <span class="s1">&#39;in l/r attr_types and attr_corres&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Table order is different than what is mentioned &#39;</span>
                             <span class="s1">&#39;in l/r attr_types and attr_corres&#39;</span><span class="p">)</span>

    <span class="c1"># Initialize output feature dictionary list</span>
    <span class="n">feature_dict_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Generate features for each attr. correspondence</span>
    <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">attr_corres</span><span class="p">[</span><span class="s1">&#39;corres&#39;</span><span class="p">]:</span>
        <span class="n">l_attr_type</span> <span class="o">=</span> <span class="n">l_attr_types</span><span class="p">[</span><span class="n">ac</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">r_attr_type</span> <span class="o">=</span> <span class="n">r_attr_types</span><span class="p">[</span><span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Generate a feature only if the attribute types are same</span>
        <span class="k">if</span> <span class="n">l_attr_type</span> <span class="o">!=</span> <span class="n">r_attr_type</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;py_entitymatching types: </span><span class="si">%s</span><span class="s1"> type (</span><span class="si">%s</span><span class="s1">) and </span><span class="si">%s</span><span class="s1"> type (</span><span class="si">%s</span><span class="s1">) &#39;</span>
                           <span class="s1">&#39;are different.&#39;</span>
                           <span class="s1">&#39;If you want to set them to be same and &#39;</span>
                           <span class="s1">&#39;generate features, &#39;</span>
                           <span class="s1">&#39;update output from get_attr_types and &#39;</span>
                           <span class="s1">&#39;use get_features command.</span><span class="se">\n</span><span class="s1">.&#39;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_attr_type</span><span class="p">,</span> <span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r_attr_type</span><span class="p">))</span>
            <span class="c1"># features_1 = _get_features_for_type(l_attr_type)</span>
            <span class="c1"># features_2 = _get_features_for_type(r_attr_type)</span>
            <span class="c1"># features = set(features_1).union(features_2)</span>
            <span class="k">continue</span>

        <span class="c1"># Generate features</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_get_features_for_type</span><span class="p">(</span><span class="n">l_attr_type</span><span class="p">)</span>

        <span class="c1"># Convert features to function objects</span>
        <span class="n">fn_objs</span> <span class="o">=</span> <span class="n">_conv_func_objs</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">tok_funcs</span><span class="p">,</span> <span class="n">sim_funcs</span><span class="p">)</span>
        <span class="c1"># Add the function object to a feature list.</span>
        <span class="n">feature_dict_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn_objs</span><span class="p">)</span>

    <span class="c1"># Create a feature table</span>
    <span class="n">feature_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">flatten_list</span><span class="p">(</span><span class="n">feature_dict_list</span><span class="p">))</span>
    <span class="c1"># Project out only the necessary columns.</span>
    <span class="n">feature_table</span> <span class="o">=</span> <span class="n">feature_table</span><span class="p">[[</span><span class="s1">&#39;feature_name&#39;</span><span class="p">,</span> <span class="s1">&#39;left_attribute&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;right_attribute&#39;</span><span class="p">,</span> <span class="s1">&#39;left_attr_tokenizer&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;right_attr_tokenizer&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;simfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;function&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;function_source&#39;</span><span class="p">,</span> <span class="s1">&#39;is_auto_generated&#39;</span><span class="p">]]</span>
    <span class="c1"># Return the feature table.</span>
    <span class="k">return</span> <span class="n">feature_table</span></div>


<div class="viewcode-block" id="get_features_for_blocking"><a class="viewcode-back" href="../../../user_manual/api/creating_the_features_automatically.html#py_entitymatching.get_features_for_blocking">[docs]</a><span class="k">def</span> <span class="nf">get_features_for_blocking</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">validate_inferred_attr_types</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function automatically generates features that can be used for</span>
<span class="sd">    blocking purposes.</span>

<span class="sd">    Args:</span>
<span class="sd">        ltable,rtable (DataFrame): The pandas DataFrames for which the</span>
<span class="sd">            features are to be generated.</span>
<span class="sd">        validate_inferred_attr_types (boolean): A flag to indicate whether to </span>
<span class="sd">            show the user the inferred attribute types and the features</span>
<span class="sd">            chosen for those types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A pandas DataFrame containing automatically generated features.</span>

<span class="sd">        Specifically, the DataFrame contains the following attributes:</span>
<span class="sd">        &#39;feature_name&#39;, &#39;left_attribute&#39;, &#39;right_attribute&#39;,</span>
<span class="sd">        &#39;left_attr_tokenizer&#39;, &#39;right_attr_tokenizer&#39;, &#39;simfunction&#39;,</span>
<span class="sd">        &#39;function&#39;, &#39;function_source&#39;, and &#39;is_auto_generated&#39;.</span>


<span class="sd">        Further, this function also sets the following global variables:</span>
<span class="sd">        _block_t, _block_s, _atypes1, _atypes2, and _block_c.</span>

<span class="sd">        The variable _block_t contains the tokenizers used and  _block_s</span>
<span class="sd">        contains the similarity functions used for creating features.</span>

<span class="sd">        The variables _atypes1, and  _atypes2 contain the attribute types for</span>
<span class="sd">        ltable and rtable respectively. The variable _block_c contains the</span>
<span class="sd">        attribute correspondences between the two input tables.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `ltable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `rtable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `validate_inferred_attr_types` is not of type</span>
<span class="sd">            pandas DataFrame.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import py_entitymatching as em</span>
<span class="sd">        &gt;&gt;&gt; A = em.read_csv_metadata(&#39;path_to_csv_dir/table_A.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = em.read_csv_metadata(&#39;path_to_csv_dir/table_B.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; block_f = em.get_features_for_blocking(A, B)</span>

<span class="sd">    Note:</span>
<span class="sd">        In the output DataFrame, two</span>
<span class="sd">        attributes demand some explanation: (1) function, and (2)</span>
<span class="sd">        is_auto_generated. The function, points to the actual Python function</span>
<span class="sd">        that implements the feature. Specifically, the function takes in two</span>
<span class="sd">        tuples (one from each input table) and returns a numeric value. The</span>
<span class="sd">        attribute is_auto_generated contains either True or False. The flag</span>
<span class="sd">        is True only if the feature is automatically generated by py_entitymatching.</span>
<span class="sd">        This is important because this flag is used to make some assumptions</span>
<span class="sd">        about the semantics of the similarity function used and use that</span>
<span class="sd">        information for scaling purposes.</span>

<span class="sd">    See Also:</span>
<span class="sd">     :meth:`py_entitymatching.get_attr_corres`, :meth:`py_entitymatching.get_attr_types`,</span>
<span class="sd">     :meth:`py_entitymatching.get_sim_funs_for_blocking`</span>
<span class="sd">     :meth:`py_entitymatching.get_tokenizers_for_blocking`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input parameters</span>
    <span class="c1"># # We expect the ltable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input table A&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the rtable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">rtable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input table B&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the validate_inferred_attr_types to be of type boolean</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">validate_inferred_attr_types</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;Validate inferred attribute type&#39;</span><span class="p">)</span>

    <span class="c1"># Get the similarity functions to be used for blocking</span>
    <span class="n">sim_funcs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
    <span class="c1"># Get the tokenizers to be used for blocking</span>
    <span class="n">tok_funcs</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>

    <span class="c1"># Get the attr. types for ltable and rtable</span>
    <span class="n">attr_types_ltable</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">ltable</span><span class="p">)</span>
    <span class="n">attr_types_rtable</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">rtable</span><span class="p">)</span>
    <span class="c1"># Get the attr. correspondences between ltable and rtable</span>
    <span class="n">attr_corres</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">)</span>
    
    <span class="c1"># Show the user inferred attribute types and features and request</span>
    <span class="c1"># user permission to proceed</span>
    <span class="k">if</span> <span class="n">validate_inferred_attr_types</span><span class="p">:</span>
        <span class="c1"># if the user does not want to proceed, then exit the function</span>
        <span class="k">if</span> <span class="n">validate_attr_types</span><span class="p">(</span><span class="n">attr_types_ltable</span><span class="p">,</span> <span class="n">attr_types_rtable</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

    <span class="c1"># Get features based on attr types, attr correspondences, sim functions</span>
    <span class="c1"># and tok. functions</span>
    <span class="n">feature_table</span> <span class="o">=</span> <span class="n">get_features</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">attr_types_ltable</span><span class="p">,</span>
                                 <span class="n">attr_types_rtable</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">,</span>
                                 <span class="n">tok_funcs</span><span class="p">,</span> <span class="n">sim_funcs</span><span class="p">)</span>

    <span class="c1"># Export important variables to global name space</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_block_t</span> <span class="o">=</span> <span class="n">tok_funcs</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_block_s</span> <span class="o">=</span> <span class="n">sim_funcs</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span> <span class="o">=</span> <span class="n">attr_types_ltable</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span> <span class="o">=</span> <span class="n">attr_types_rtable</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_block_c</span> <span class="o">=</span> <span class="n">attr_corres</span>
    <span class="c1"># Return the feature table</span>
    <span class="k">return</span> <span class="n">feature_table</span></div>


<div class="viewcode-block" id="get_features_for_matching"><a class="viewcode-back" href="../../../user_manual/api/creating_the_features_automatically.html#py_entitymatching.get_features_for_matching">[docs]</a><span class="k">def</span> <span class="nf">get_features_for_matching</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">validate_inferred_attr_types</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function automatically generates features that can be used for</span>
<span class="sd">    matching purposes.</span>

<span class="sd">    Args:</span>
<span class="sd">        ltable,rtable (DataFrame): The pandas DataFrames for which the</span>
<span class="sd">            features are to be generated.</span>
<span class="sd">        validate_inferred_attr_types (boolean): A flag to indicate whether to </span>
<span class="sd">            show the user the inferred attribute types and the features</span>
<span class="sd">            chosen for those types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A pandas DataFrame containing automatically generated features.</span>

<span class="sd">        Specifically, the DataFrame contains the following attributes:</span>
<span class="sd">        &#39;feature_name&#39;, &#39;left_attribute&#39;, &#39;right_attribute&#39;,</span>
<span class="sd">        &#39;left_attr_tokenizer&#39;, &#39;right_attr_tokenizer&#39;, &#39;simfunction&#39;,</span>
<span class="sd">        &#39;function&#39;, &#39;function_source&#39;, and &#39;is_auto_generated&#39;.</span>


<span class="sd">        Further, this function also sets the following global variables:</span>
<span class="sd">        _match_t, _match_s, _atypes1, _atypes2, and _match_c.</span>

<span class="sd">        The variable _match_t contains the tokenizers used and  _match_s</span>
<span class="sd">        contains the similarity functions used for creating features.</span>

<span class="sd">        The variables _atypes1, and  _atypes2 contain the attribute types for</span>
<span class="sd">        ltable and rtable respectively. The variable _match_c contains the</span>
<span class="sd">        attribute correspondences between the two input tables.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `ltable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `rtable` is not of type pandas</span>
<span class="sd">            DataFrame.</span>
<span class="sd">        AssertionError: If `validate_inferred_attr_types` is not of type</span>
<span class="sd">            pandas DataFrame.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import py_entitymatching as em</span>
<span class="sd">        &gt;&gt;&gt; A = em.read_csv_metadata(&#39;path_to_csv_dir/table_A.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = em.read_csv_metadata(&#39;path_to_csv_dir/table_B.csv&#39;, key=&#39;ID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; match_f = em.get_features_for_matching(A, B)</span>

<span class="sd">    Note:</span>
<span class="sd">        In the output DataFrame, two</span>
<span class="sd">        attributes demand some explanation: (1) function, and (2)</span>
<span class="sd">        is_auto_generated. The function, points to the actual Python function</span>
<span class="sd">        that implements the feature. Specifically, the function takes in two</span>
<span class="sd">        tuples (one from each input table) and returns a numeric value. The</span>
<span class="sd">        attribute is_auto_generated contains either True or False. The flag</span>
<span class="sd">        is True only if the feature is automatically generated by py_entitymatching.</span>
<span class="sd">        This is important because this flag is used to make some assumptions</span>
<span class="sd">        about the semantics of the similarity function used and use that</span>
<span class="sd">        information for scaling purposes.</span>

<span class="sd">    See Also:</span>
<span class="sd">     :meth:`py_entitymatching.get_attr_corres`, :meth:`py_entitymatching.get_attr_types`,</span>
<span class="sd">     :meth:`py_entitymatching.get_sim_funs_for_matching`</span>
<span class="sd">     :meth:`py_entitymatching.get_tokenizers_for_matching`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input parameters</span>
    <span class="c1"># # We expect the ltable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input table A&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the rtable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">rtable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input table B&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the validate_inferred_attr_types to be of type boolean</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">validate_inferred_attr_types</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;Validate inferred attribute type&#39;</span><span class="p">)</span>

    <span class="c1"># Get similarity functions for generating the features for matching</span>
    <span class="n">sim_funcs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
    <span class="c1"># Get tokenizer functions for generating the features for matching</span>
    <span class="n">tok_funcs</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>

    <span class="c1"># Get the attribute types of the input tables</span>
    <span class="n">attr_types_ltable</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">ltable</span><span class="p">)</span>
    <span class="n">attr_types_rtable</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">rtable</span><span class="p">)</span>

    <span class="c1"># Get the attribute correspondence between the input tables</span>
    <span class="n">attr_corres</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">)</span>

    <span class="c1"># Show the user inferred attribute types and features and request</span>
    <span class="c1"># user permission to proceed</span>
    <span class="k">if</span> <span class="n">validate_inferred_attr_types</span><span class="p">:</span>
        <span class="c1"># if the user does not want to proceed, then exit the function</span>
        <span class="k">if</span> <span class="n">validate_attr_types</span><span class="p">(</span><span class="n">attr_types_ltable</span><span class="p">,</span> <span class="n">attr_types_rtable</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

    <span class="c1"># Get the features</span>
    <span class="n">feature_table</span> <span class="o">=</span> <span class="n">get_features</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">attr_types_ltable</span><span class="p">,</span>
                                 <span class="n">attr_types_rtable</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">,</span>
                                 <span class="n">tok_funcs</span><span class="p">,</span> <span class="n">sim_funcs</span><span class="p">)</span>

    <span class="c1"># Export important variables to global name space</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_match_t</span> <span class="o">=</span> <span class="n">tok_funcs</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_match_s</span> <span class="o">=</span> <span class="n">sim_funcs</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span> <span class="o">=</span> <span class="n">attr_types_ltable</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span> <span class="o">=</span> <span class="n">attr_types_rtable</span>
    <span class="n">em</span><span class="o">.</span><span class="n">_match_c</span> <span class="o">=</span> <span class="n">attr_corres</span>

    <span class="c1"># Finally return the feature table</span>
    <span class="k">return</span> <span class="n">feature_table</span></div>


<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_check_table_order</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">l_attr_types</span><span class="p">,</span> <span class="n">r_attr_types</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether the order of tables matches with what is mentioned in</span>
<span class="sd">    l_attr_types, r_attr_type and attr_corres.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate the input parameters</span>
    <span class="c1"># We expect the input object ltable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input left table&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the rtable to be of type pandas DataFrame</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">rtable</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="s1">&#39;Input right table&#39;</span><span class="p">)</span>

    <span class="c1"># Get the ids of the input tables. This is used to validate the order</span>
    <span class="c1"># of tables present in the given data structures.</span>
    <span class="c1"># Note: This kind of checking is bit too aggressive, the reason is this</span>
    <span class="c1"># checking needs the ltable and rtable to point to exact memory location</span>
    <span class="c1"># across the given dictionaries and the input. Ideally, we just need to</span>
    <span class="c1"># check whether the contents of those DataFrames are same.</span>
    <span class="n">ltable_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">ltable</span><span class="p">)</span>
    <span class="n">rtable_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">rtable</span><span class="p">)</span>

    <span class="c1"># Check whether ltable id matches with id of table mentioned in l_attr_types</span>
    <span class="k">if</span> <span class="n">ltable_id</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">l_attr_types</span><span class="p">[</span><span class="s1">&#39;_table&#39;</span><span class="p">]):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s1">&#39;ltable is not the same as table mentioned in left attr types&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check whether rtable id matches with id of table mentioned in r_attr_types</span>
    <span class="k">if</span> <span class="n">rtable_id</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">r_attr_types</span><span class="p">[</span><span class="s1">&#39;_table&#39;</span><span class="p">]):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s1">&#39;rtable is not the same as table mentioned in right attr types&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check whether ltable matches with ltable mentioned in attr_corres</span>
    <span class="k">if</span> <span class="n">ltable_id</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">attr_corres</span><span class="p">[</span><span class="s1">&#39;ltable&#39;</span><span class="p">]):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s1">&#39;ltable is not the same as table mentioned in attr correspondence&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check whether rtable matches with rtable mentioned in attr_corres</span>
    <span class="k">if</span> <span class="n">rtable_id</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">attr_corres</span><span class="p">[</span><span class="s1">&#39;rtable&#39;</span><span class="p">]):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s1">&#39;rtable is not the same as table mentioned in attr correspondence&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Finally, return True.</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># get look up table to generate features</span>
<span class="k">def</span> <span class="nf">_get_feat_lkp_tbl</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function embeds the knowledge of mapping what features to be</span>
<span class="sd">    generated for what kind of attr. types.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize a lookup table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Features for type str_eq_1w</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_EQ_1W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;lev_dist&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_sim&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;jaro&#39;</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;jaro_winkler&#39;</span><span class="p">),</span>
                                 <span class="p">(</span><span class="s1">&#39;exact_match&#39;</span><span class="p">),</span>
                                 <span class="p">(</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">)]</span>

    <span class="c1"># Features for type str_bt_1w_5w</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_BT_1W_5W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">),</span>
                                    <span class="p">(</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">),</span>
                                    <span class="p">(</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">),</span>
                                    <span class="p">(</span><span class="s1">&#39;monge_elkan&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_dist&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_sim&#39;</span><span class="p">),</span>
                                    <span class="p">(</span><span class="s1">&#39;needleman_wunsch&#39;</span><span class="p">),</span>
                                    <span class="p">(</span><span class="s1">&#39;smith_waterman&#39;</span><span class="p">)]</span>  <span class="c1"># dlm_dc0 is the concrete space tokenizer</span>

    <span class="c1"># Features for type str_bt_5w_10w</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_BT_5W_10W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s1">&#39;monge_elkan&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_dist&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_sim&#39;</span><span class="p">)]</span>

    <span class="c1"># Features for type str_gt_10w</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_GT_10W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">,</span> <span class="s1">&#39;qgm_3&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">,</span> <span class="s1">&#39;dlm_dc0&#39;</span><span class="p">)]</span>

    <span class="c1"># Features for NUMERIC type</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;NUM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;exact_match&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;abs_norm&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lev_dist&#39;</span><span class="p">),</span>
                           <span class="p">(</span><span class="s1">&#39;lev_sim&#39;</span><span class="p">)]</span>

    <span class="c1"># Features for BOOLEAN type</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;BOOL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;exact_match&#39;</span><span class="p">)]</span>

    <span class="c1"># Features for un determined type</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;UN_DETERMINED&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Finally, return the lookup table</span>
    <span class="k">return</span> <span class="n">lookup_table</span>


<span class="k">def</span> <span class="nf">_get_features_for_type</span><span class="p">(</span><span class="n">column_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get features to be generated for a type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First get the look up table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="n">_get_feat_lkp_tbl</span><span class="p">()</span>

    <span class="c1"># Based on the column type, return the feature functions that should be</span>
    <span class="c1"># generated.</span>
    <span class="k">if</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;str_eq_1w&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_EQ_1W&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;str_bt_1w_5w&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_BT_1W_5W&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;str_bt_5w_10w&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_BT_5W_10W&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;str_gt_10w&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;STR_GT_10W&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;numeric&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;NUM&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;boolean&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;BOOL&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="s1">&#39;un_determined&#39;</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;UN_DETERMINED&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown type&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">features</span>


<span class="k">def</span> <span class="nf">get_magellan_str_types</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the py_entitymatching types as a list of  strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;str_eq_1w&#39;</span><span class="p">,</span> <span class="s1">&#39;str_bt_1w_5w&#39;</span><span class="p">,</span> <span class="s1">&#39;str_bt_5w_10w&#39;</span><span class="p">,</span> <span class="s1">&#39;str_gt_10w&#39;</span><span class="p">,</span>
            <span class="s1">&#39;numeric&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">,</span> <span class="s1">&#39;un_determined&#39;</span><span class="p">]</span>


<span class="c1"># convert features from look up table to function objects</span>
<span class="k">def</span> <span class="nf">_conv_func_objs</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span>
                    <span class="n">tokenizer_functions</span><span class="p">,</span> <span class="n">similarity_functions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert features from look up table to function objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We need to check whether the features have allowed tokenizers and</span>
    <span class="c1"># similarity functions.</span>

    <span class="c1"># # First get the tokenizer and similarity functions list.</span>
    <span class="n">tokenizer_list</span> <span class="o">=</span> <span class="n">tokenizer_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">similarity_functions_list</span> <span class="o">=</span> <span class="n">similarity_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="c1"># # Second get the features that uses only valid tokenizers and</span>
    <span class="c1"># similarity functions</span>
    <span class="n">valid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">check_valid_tok_sim</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">tokenizer_list</span><span class="p">,</span>
                                      <span class="n">similarity_functions_list</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">]</span>

    <span class="c1"># Get function as a string and other meta data; finally we will get a</span>
    <span class="c1"># list of tuples</span>
    <span class="n">function_tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_fn_str</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">valid_list</span><span class="p">]</span>

    <span class="c1"># Convert the function string into a function object</span>
    <span class="n">function_objects</span> <span class="o">=</span> <span class="n">conv_fn_str_to_obj</span><span class="p">(</span><span class="n">function_tuples</span><span class="p">,</span> <span class="n">tokenizer_functions</span><span class="p">,</span>
                                   <span class="n">similarity_functions</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">function_objects</span>


<span class="c1"># check whether tokenizers and simfunctions are allowed</span>
<span class="c1"># inp is of the form (&#39;jaccard&#39;, &#39;qgm_3&#39;, &#39;qgm_3&#39;) or (&#39;lev&#39;)</span>
<span class="k">def</span> <span class="nf">check_valid_tok_sim</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">simlist</span><span class="p">,</span> <span class="n">toklist</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">inp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;len of feature config should be 1 or 3&#39;</span>
    <span class="c1"># check whether the sim function in features is in simlist</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">simlist</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inp</span>
    <span class="c1"># check whether the tokenizer in features is in tok list</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">toklist</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inp</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># get function string for a feature</span>
<span class="k">def</span> <span class="nf">get_fn_str</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inp</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="c1"># fill function string from a template</span>
        <span class="k">return</span> <span class="n">fill_fn_template</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># fill function template</span>
<span class="k">def</span> <span class="nf">fill_fn_template</span><span class="p">(</span><span class="n">attr1</span><span class="p">,</span> <span class="n">attr2</span><span class="p">,</span> <span class="n">sim_func</span><span class="p">,</span> <span class="n">tok_func_1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tok_func_2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># construct function string</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;from py_entitymatching.feature.simfunctions import *</span><span class="se">\n</span><span class="s1">from py_entitymatching.feature.tokenizers import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="c1"># get the function name</span>
    <span class="n">fn_name</span> <span class="o">=</span> <span class="n">get_fn_name</span><span class="p">(</span><span class="n">attr1</span><span class="p">,</span> <span class="n">attr2</span><span class="p">,</span> <span class="n">sim_func</span><span class="p">,</span> <span class="n">tok_func_1</span><span class="p">,</span> <span class="n">tok_func_2</span><span class="p">)</span>
    <span class="c1"># proceed with function construction</span>
    <span class="n">fn_st</span> <span class="o">=</span> <span class="s1">&#39;def &#39;</span> <span class="o">+</span> <span class="n">fn_name</span> <span class="o">+</span> <span class="s1">&#39;(ltuple, rtuple):&#39;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">fn_st</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="c1"># add 4 spaces</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;    &#39;</span>
    <span class="n">fn_body</span> <span class="o">=</span> <span class="s1">&#39;return &#39;</span>
    <span class="k">if</span> <span class="n">tok_func_1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tok_func_2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fn_body</span> <span class="o">=</span> <span class="n">fn_body</span> <span class="o">+</span> <span class="n">sim_func</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">tok_func_1</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;ltuple[&quot;&#39;</span> <span class="o">+</span> <span class="n">attr1</span> <span class="o">+</span> <span class="s1">&#39;&quot;]&#39;</span>
        <span class="n">fn_body</span> <span class="o">+=</span> <span class="s1">&#39;), &#39;</span>
        <span class="n">fn_body</span> <span class="o">=</span> <span class="n">fn_body</span> <span class="o">+</span> <span class="n">tok_func_2</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;rtuple[&quot;&#39;</span> <span class="o">+</span> <span class="n">attr2</span> <span class="o">+</span> <span class="s1">&#39;&quot;]&#39;</span>
        <span class="n">fn_body</span> <span class="o">=</span> <span class="n">fn_body</span> <span class="o">+</span> <span class="s1">&#39;)) &#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fn_body</span> <span class="o">=</span> <span class="n">fn_body</span> <span class="o">+</span> <span class="n">sim_func</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;ltuple[&quot;&#39;</span> <span class="o">+</span> <span class="n">attr1</span> <span class="o">+</span> <span class="s1">&#39;&quot;], rtuple[&quot;&#39;</span> <span class="o">+</span> <span class="n">attr2</span> <span class="o">+</span> <span class="s1">&#39;&quot;])&#39;</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">fn_body</span>

    <span class="k">return</span> <span class="n">fn_name</span><span class="p">,</span> <span class="n">attr1</span><span class="p">,</span> <span class="n">attr2</span><span class="p">,</span> <span class="n">tok_func_1</span><span class="p">,</span> <span class="n">tok_func_2</span><span class="p">,</span> <span class="n">sim_func</span><span class="p">,</span> <span class="n">s</span>


<span class="c1"># construct function name from attrs, tokenizers and sim funcs</span>

<span class="c1"># sim_fn_names=[&#39;jaccard&#39;, &#39;lev&#39;, &#39;cosine&#39;, &#39;monge_elkan&#39;,</span>
<span class="c1">#               &#39;needleman_wunsch&#39;, &#39;smith_waterman&#39;, &#39;jaro&#39;, &#39;jaro_winkler&#39;,</span>
<span class="c1">#               &#39;exact_match&#39;, &#39;rel_diff&#39;, &#39;abs_norm&#39;]</span>
<span class="k">def</span> <span class="nf">get_fn_name</span><span class="p">(</span><span class="n">attr1</span><span class="p">,</span> <span class="n">attr2</span><span class="p">,</span> <span class="n">sim_func</span><span class="p">,</span> <span class="n">tok_func_1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tok_func_2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">attr1</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attr1</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">attr2</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attr2</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">attr1</span><span class="p">,</span> <span class="n">attr2</span><span class="p">])</span>
    <span class="n">name_lkp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;jaccard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;jac&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;lev_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lev_dist&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;lev_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lev_sim&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;cosine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cos&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;monge_elkan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mel&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;needleman_wunsch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nmw&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;smith_waterman&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sw&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;jaro&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;jar&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;jaro_winkler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;jwn&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;exact_match&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;exm&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;abs_norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;anm&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;rel_diff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rdf&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;2&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;3&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;4&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;tok_whitespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;wsp&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;tok_qgram&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;qgm&quot;</span>
    <span class="n">name_lkp</span><span class="p">[</span><span class="s2">&quot;tok_delim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;dlm&quot;</span>

    <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim_func</span><span class="p">,</span> <span class="n">tok_func_1</span><span class="p">,</span> <span class="n">tok_func_2</span><span class="p">]</span>
    <span class="n">nm_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_lkp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">arg_list</span> <span class="k">if</span> <span class="n">tok</span><span class="p">]</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nm_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">fp</span><span class="p">,</span> <span class="n">sp</span><span class="p">])</span>


<span class="c1"># conv function string to function object and return with meta data</span>
<span class="k">def</span> <span class="nf">conv_fn_str_to_obj</span><span class="p">(</span><span class="n">fn_tup</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">sim_funcs</span><span class="p">):</span>
    <span class="n">d_orig</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">d_orig</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
    <span class="n">d_orig</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sim_funcs</span><span class="p">)</span>
    <span class="n">d_ret_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fn_tup</span><span class="p">:</span>
        <span class="n">d_ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attr2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">tok_1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">tok_2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">simfunction</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="c1"># exec(f[6] in d_orig)</span>
        <span class="n">six</span><span class="o">.</span><span class="n">exec_</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">d_orig</span><span class="p">)</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_orig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;feature_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;left_attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr1</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;right_attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr2</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;left_attr_tokenizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok_1</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;right_attr_tokenizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok_2</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;simfunction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">simfunction</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;function_source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
        <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;is_auto_generated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">d_ret_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_ret</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_ret_list</span>


<span class="k">def</span> <span class="nf">flatten_list</span><span class="p">(</span><span class="n">inp_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">inp_list</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>


<span class="c1"># Show the user inferred attribute types and features and request</span>
<span class="c1"># user permission to proceed</span>
<span class="k">def</span> <span class="nf">validate_attr_types</span><span class="p">(</span><span class="n">l_attr_types</span><span class="p">,</span> <span class="n">r_attr_types</span><span class="p">,</span> <span class="n">attr_corres</span><span class="p">):</span>

    <span class="c1"># # We expect the l_attr_types to be of type dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">l_attr_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Left table attribute types&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the r_attr_types to be of type dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">r_attr_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Right table attribute types&#39;</span><span class="p">)</span>

    <span class="c1"># # We expect the attr_corres to be of type dictionary</span>
    <span class="n">validate_object_type</span><span class="p">(</span><span class="n">attr_corres</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s1">&#39;Left table attribute types&#39;</span><span class="p">)</span>

    <span class="n">corres_features_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The table shows the corresponding attributes along with their respective &#39;</span>
          <span class="s1">&#39;types.</span><span class="se">\n</span><span class="s1">Please confirm that the information  has been correctly inferred.</span><span class="se">\n</span><span class="s1">&#39;</span>
          <span class="s1">&#39;If you would like to skip this validation process in the future,</span><span class="se">\n</span><span class="s1">please set &#39;</span>
          <span class="s1">&#39;the flag validate_inferred_attr_types equal to false.&#39;</span><span class="p">)</span>

    <span class="c1"># Generate features for each attr. correspondence</span>
    <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">attr_corres</span><span class="p">[</span><span class="s1">&#39;corres&#39;</span><span class="p">]:</span>
        <span class="n">l_attr_type</span> <span class="o">=</span> <span class="n">l_attr_types</span><span class="p">[</span><span class="n">ac</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">r_attr_type</span> <span class="o">=</span> <span class="n">r_attr_types</span><span class="p">[</span><span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># get human readable type names</span>
        <span class="n">readable_l_type</span> <span class="o">=</span> <span class="n">_get_readable_type_name</span><span class="p">(</span><span class="n">l_attr_type</span><span class="p">)</span>
        <span class="n">readable_r_type</span> <span class="o">=</span> <span class="n">_get_readable_type_name</span><span class="p">(</span><span class="n">r_attr_type</span><span class="p">)</span>

        <span class="c1"># List and string of readable feature descriptions</span>
        <span class="n">readable_features</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Generate a feature only if the attribute types are same</span>
        <span class="k">if</span> <span class="n">l_attr_type</span> <span class="o">!=</span> <span class="n">r_attr_type</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;py_entitymatching types: </span><span class="si">%s</span><span class="s1"> type (</span><span class="si">%s</span><span class="s1">) and </span><span class="si">%s</span><span class="s1"> type (</span><span class="si">%s</span><span class="s1">) &#39;</span>
                        <span class="s1">&#39;are different.&#39;</span>
                        <span class="s1">&#39;If you want to set them to be same and &#39;</span>
                        <span class="s1">&#39;generate features, &#39;</span>
                        <span class="s1">&#39;update output from get_attr_types and &#39;</span>
                        <span class="s1">&#39;use get_features command.</span><span class="se">\n</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_attr_type</span><span class="p">,</span> <span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r_attr_type</span><span class="p">))</span>
            <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;N/A&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Generate features</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">_get_features_for_type</span><span class="p">(</span><span class="n">l_attr_type</span><span class="p">)</span>

        <span class="c1"># Change features into more readable format</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">readable_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_readable_feature_name</span><span class="p">(</span><span class="n">feat</span><span class="p">))</span>

        <span class="c1"># Change the first 3 values in the list of features into a string</span>
        <span class="n">readable_features_str</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">readable_features</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Add information for each set of corresponding attributes to the list</span>
        <span class="c1"># corres_features_list.append([ac[0], readable_l_type, ac[1], readable_r_type, readable_features_str])</span>
        <span class="n">corres_features_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ac</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ac</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">readable_l_type</span><span class="p">,</span> <span class="n">readable_r_type</span><span class="p">,</span> <span class="n">readable_features_str</span><span class="p">])</span>

    <span class="c1"># create and display table for the user</span>
    <span class="c1"># Create the pandas dataframe from the lists</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Left Attribute&#39;</span><span class="p">,</span> <span class="s1">&#39;Right Attribute&#39;</span><span class="p">,</span> <span class="s1">&#39;Left Attribute Type&#39;</span><span class="p">,</span> <span class="s1">&#39;Right Attribute Type&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Example Features&#39;</span><span class="p">]</span>
    <span class="n">corres_feat_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">corres_features_list</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

    <span class="c1"># display the pandas dataframe</span>
    <span class="n">display</span><span class="p">(</span><span class="n">corres_feat_df</span><span class="p">)</span>

    <span class="c1"># Ask user if the inferred types are satisfactory. Repeat until satisfactory answer is reached</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;Do you want to proceed? (y/n):&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">corres_feat_df</span>
        <span class="k">elif</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">If the attribute correspondences or types have been inferred incorrectly,</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;use the get_features() function with your  own correspondences and attribute</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;types to get the correct features for your data&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You must answer with either &#39;y&#39; or &#39;n&#39;&quot;</span><span class="p">)</span>



<span class="c1"># get look up table to generate readable type names</span>
<span class="k">def</span> <span class="nf">_get_type_name_lkp_tbl</span><span class="p">():</span>
    <span class="c1"># Initialize a lookup table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Map type names to more human readable names</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;str_eq_1w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;short string (1 word)&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;str_bt_1w_5w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;short string (1 word to 5 words)&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;str_bt_5w_10w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;medium string (5 words to 10 words)&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;str_gt_10w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;short string (1 word)&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;numeric&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;boolean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;boolean&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;un_determined&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;un-determined type&#39;</span>

    <span class="k">return</span> <span class="n">lookup_table</span>


<span class="c1"># Get readable names for the types</span>
<span class="k">def</span> <span class="nf">_get_readable_type_name</span><span class="p">(</span><span class="n">column_type</span><span class="p">):</span>

    <span class="c1"># First get the look up table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="n">_get_type_name_lkp_tbl</span><span class="p">()</span>

    <span class="c1"># Check if the column type is in the dictionary</span>
    <span class="k">if</span> <span class="n">column_type</span> <span class="ow">in</span> <span class="n">lookup_table</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">column_type</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown type&#39;</span><span class="p">)</span>


<span class="c1"># get look up table to generate readable feature descriptions</span>
<span class="k">def</span> <span class="nf">_get_feature_name_lkp_tbl</span><span class="p">():</span>

    <span class="c1"># Initialize a lookup table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Map features to more human readable descriptions</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;lev_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Levenshtein Distance&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;lev_sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Levenshtein Similarity&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;jaro&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Jaro Distance&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;jaro_winkler&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Jaro-Winkler Distance&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;exact_match&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Exact Match&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;needleman_wunsch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Needleman-Wunsch Algorithm&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;smith_waterman&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Smith-Waterman Algorithm&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;abs_norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Absolute Norm&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;jaccard&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Jaccard Similarity&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;monge_elkan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Monge-Elkan Algorithm&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;cosine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Cosine Similarity&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;qgm_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1-grams&quot;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;qgm_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;2-grams&quot;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;qgm_3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;3-grams&quot;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;qgm_4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;4-grams&quot;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;dlm_dc0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Space Delimiter&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;dlm_wsp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Whitespace Delimiter&#39;</span>
    <span class="n">lookup_table</span><span class="p">[</span><span class="s1">&#39;N/A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Not Applicable: Types do not match&#39;</span>

    <span class="k">return</span> <span class="n">lookup_table</span>


<span class="c1"># Get readable names for the features</span>
<span class="k">def</span> <span class="nf">_get_readable_feature_name</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>

    <span class="c1"># First get the look up table</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="n">_get_feature_name_lkp_tbl</span><span class="p">()</span>

    <span class="n">readable_feature</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="c1"># If feature is just a string, return the readable name</span>
        <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">lookup_table</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Feature is not present in lookup table&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># If feature is a list, get the readable name of each part</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">feature</span><span class="p">:</span>
            <span class="c1"># Check if the feature is in the dictionary</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">lookup_table</span><span class="p">:</span>
                <span class="n">readable_feature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Feature is not present in lookup table&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">readable_feature</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">readable_feature</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">readable_feature</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Features should have either 0 or 2 (one for each table) tokenizers&#39;</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016, anhaidgroup.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>