

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>py_entitymatching 0.3.3 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> py_entitymatching
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-how_to_guide">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/whatisnew">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/installation">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#platforms">Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#c-compiler-required">C Compiler Required</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#installing-using-pip">Installing Using pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#installing-from-source-distribution">Installing from Source Distribution</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/overview">Overview of Supported EM Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#supported-em-problem-scenarios">Supported EM Problem Scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#two-fundamental-steps-in-the-em-process-blocking-and-matching">Two Fundamental Steps in the EM Process: Blocking and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#supported-em-workflows">Supported EM Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#the-development-and-production-stages">The Development and Production Stages</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#the-focus-of-the-current-package">The Focus of the Current Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/guides">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#a-quick-tour-of-jupyter-notebook">A Quick Tour of Jupyter Notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#end-to-end-em-workflows">End-to-End EM Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#stepwise-guides">Stepwise Guides</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/datastructures">Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#storing-tables-using-pandas-dataframes">Storing Tables Using Pandas Dataframes</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#storing-metadata-using-a-catalog">Storing Metadata Using a Catalog</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/steps_supp_em_workflows">Steps of Supported EM Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/read_csv_files">Reading the CSV Files from Disk</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/down_sampling">Down Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/profiling">Profiling Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#example-usage">Example Usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/data_exploration">Data Exploration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#openrefine">OpenRefine</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#pandastable">Pandastable</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/blocking">Specifying Blockers and Performing Blocking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#types-of-blockers-and-blocker-hierarchy">Types of Blockers and Blocker Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#built-in-blockers">Built-In Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#blackbox-blockers">Blackbox Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#rule-based-blockers">Rule-Based Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#combining-multiple-blockers">Combining Multiple Blockers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/create_feats_for_blocking">Creating Features for Blocking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#available-tokenizers-and-similarity-functions">Available Tokenizers and Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#obtaining-tokenizers-and-similarity-functions">Obtaining Tokenizers and Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#obtaining-attribute-types-and-correspondences">Obtaining Attribute Types and Correspondences</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#getting-a-set-of-features">Getting a Set of Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#adding-removing-features">Adding/Removing Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#summary-of-the-manual-feature-generation-process">Summary of the Manual Feature Generation Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ways-to-edit-the-manual-feature-generation-process">Ways to Edit the Manual Feature Generation Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#generating-features-automatically">Generating Features Automatically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/debugging_blocking">Debugging Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/sampling">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/labeling">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/split_train_test">Splitting Labeled Data into Training and Testing Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/create_feats_for_matching">Creating Features for Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-the-features-manually">Creating the Features Manually</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-the-features-automatically">Creating the Features Automatically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/extract_feat_vecs">Extracting Feature Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/imputing_missing_values">Imputing Missing Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/matching">Specifying Matchers and Performing Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ml-matchers">ML-Matchers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#rule-based-matchers">Rule-Based Matchers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/select_best_matcher">Selecting a ML-Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/debugging_matcher">Debugging ML-Matchers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#debugging-using-the-gui">Debugging Using the GUI</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#debugging-using-the-command-line">Debugging Using the Command Line</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#impact-of-imputing-missing-values">Impact of Imputing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/matchercombiner">Combining Predictions from Multiple Matchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/triggers">Using Triggers to Update Matching Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#match-triggers">Match Triggers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/evaluate_matching">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/misc">Miscellaneous</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#csv-format">CSV Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#metadata-file-format">Metadata File Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#writing-a-dataframe-to-disk-along-with-its-metadata">Writing a Dataframe to Disk Along With Its Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#writing-reading-other-types-of-py-entitymatching-objects">Writing/Reading Other Types of py_entitymatching Objects</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/api/overview">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-user_manual/api/actual_commands">Commands in py_entitymatching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/reading_and_writing_data">Reading and Writing Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/loading_and_saving_objects">Loading and Saving Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/handling_metadata">Handling Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/downsampling">Downsampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/data_exploration">Data Exploration</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/blocking">Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/debugging_blocker_output">Debugging Blocker Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/combining_blocker_outputs">Combining Blocker Outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/sampling">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/labeling">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/handling_features">Handling Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/creating_the_features_automatically">Creating the Features Automatically</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/creating_the_features_manually">Creating the Features Manually</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/adding_features">Adding Features to Feature Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/extracting_feature_vectors">Extracting Feature Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/imputing_missing_values">Imputing Missing Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_similarity_functions">Supported Similarity Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_tokenizers">Supported Tokenizers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/matching">Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/splitting_data_into_train_test">Splitting Data into Train and Test</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/supported_matchers">Supported Matchers</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#document-user_manual/api/selecting_matcher">Selecting Matcher</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/debugging_matcher">Debugging Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/triggers">Triggers</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/evaluating_the_matching_output">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#experimental-commands">Experimental Commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/dask_commands">Commands Implemented Using Dask</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#downsampling">Downsampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#blocking">Blocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#extracting-feature-vectors">Extracting Feature Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#ml-matchers">ML-Matchers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/tuners">Tuners for the Dask-based Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#downsampling">Downsampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#overlap-blocker">Overlap Blocker</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#document-user_manual/api/combiner">Matcher Combiner</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">How to Contribute</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="singlepage.html#document-contributing">Contributing to py_entitymatching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#where-to-start">Where to start?</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#bug-reports-and-enhancement-requests">Bug reports and enhancement requests</a></li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#working-with-the-code">Working with the code</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#version-control-git-and-github">Version control, Git, and GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#getting-started-with-git">Getting started with Git</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#forking">Forking</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-a-branch">Creating a branch</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#creating-a-development-environment">Creating a development environment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-to-the-documentation">Contributing to the documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#about-the-py-entitymatching-documentation">About the <em>py_entitymatching</em> documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#how-to-build-the-py-entitymatching-documentation">How to build the <em>py_entitymatching</em> documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-to-the-code-base">Contributing to the code base</a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#code-standards">Code standards</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#writing-tests">Writing tests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="singlepage.html#contributing-your-changes-to-py-entitymatching">Contributing your changes to <em>py_entitymatching</em></a><ul>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#committing-your-code">Committing your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#combining-commits">Combining commits</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#pushing-your-changes">Pushing your changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#review-your-code">Review your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#finally-make-the-pull-request">Finally, make the pull request</a></li>
<li class="toctree-l3"><a class="reference internal" href="singlepage.html#delete-your-merged-branch-optional">Delete your merged branch (optional)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">py_entitymatching</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>py_entitymatching 0.3.3 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-manual-for-py-entitymatching">
<h1>User Manual for py_entitymatching<a class="headerlink" href="#user-manual-for-py-entitymatching" title="Permalink to this headline">¶</a></h1>
<p>This document explains how to install, use, and contribute to the package.</p>
</div>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-how_to_guide"></span><div class="section" id="how-to-guide-to-do-entity-matching">
<h2>How to Guide To Do Entity Matching<a class="headerlink" href="#how-to-guide-to-do-entity-matching" title="Permalink to this headline">¶</a></h2>
<p>The initial draft of the how to guide to do entity matching can be found <a class="reference external" href="http://pradap-www.cs.wisc.edu/magellan/how-to-guide/how_to_guide_magellan.pdf">here.</a></p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/whatisnew"></span><div class="section" id="what-is-new">
<h2>What is New?<a class="headerlink" href="#what-is-new" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Compared to Version 0.3.2, the followings are new:</dt><dd><ul class="simple">
<li><p>Started tracking release changes in CHANGES.txt.</p></li>
<li><p>Minorly updated usage of Pandas to prevent a dependency on downgraded versions.</p></li>
<li><p>Added stricter scikit-learn dependency requirements to preserve old Imputer API; will change in future release.</p></li>
<li><p>Users can now provide metadata for blackbox features (ex. left_attribute, right_attribute, etc.).</p></li>
<li><p>This is the last version of py_entitymatching that will support Python 2 and Python 3.5.</p></li>
</ul>
</dd>
</dl>
</div>
<span id="document-user_manual/installation"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Python 2.7, 3.5, 3.6, or 3.7</p></li>
</ul>
</div>
<div class="section" id="platforms">
<h3>Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h3>
<p>py_entitymatching has been tested on Linux (Ubuntu Xenial 16.04.6), macOS (High Sierra 10.13.6),
and Windows 10.</p>
</div>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>pandas (provides data structures to store and manage tables)</p></li>
<li><p>scikit-learn (provides implementations for common machine learning algorithms)</p></li>
<li><p>joblib (provides multiprocessing capabilities)</p></li>
<li><p>pyqt5 (provides tools to build GUIs)</p></li>
<li><p>py_stringsimjoin (provides implementations for string similarity joins)</p></li>
<li><p>py_stringmatching (provides a set of string tokenizers and string similarity functions)</p></li>
<li><p>cloudpickle (provides functions to serialize Python constructs)</p></li>
<li><p>pyprind (library to display progress indicators)</p></li>
<li><p>pyparsing (library to parse strings)</p></li>
<li><p>six (provides functions to write compatible code across Python 2 and 3)</p></li>
<li><p>xgboost (provides an implementation for xgboost classifier)</p></li>
<li><p>pandas-profiling (provides implementation for profiling pandas dataframe)</p></li>
<li><p>pandas-table (provides data exploration tool for pandas dataframe)</p></li>
<li><p>openrefine (provides data exploration tool for tables)</p></li>
<li><p>ipython (provides better tools for displaying tables in notebooks)</p></li>
<li><p>scipy (dependency for skikit-learn)</p></li>
</ul>
<p>See the <cite>project README &lt;https://github.com/anhaidgroup/py_entitymatching/blob/master/README.rst&gt;</cite>
for more information.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using Python 2, py_entitymatching requires numpy less than 1.17; if using Python 3.5, numpy less than 1.19</p>
</div>
</div>
<div class="section" id="c-compiler-required">
<h3>C Compiler Required<a class="headerlink" href="#c-compiler-required" title="Permalink to this headline">¶</a></h3>
<p>Installing Using conda
Before installing this package, you need to make sure that you have a C compiler installed. This is necessary because this package contains Cython files. Go <a class="reference external" href="https://sites.google.com/site/anhaidgroup/projects/magellan/issues">here</a> for more information about how to check whether you already have a C compiler and how to install a C compiler. After you have confirmed that you have a C compiler installed, you are ready to install py_entitymatching.</p>
</div>
<div class="section" id="installing-using-pip">
<h3>Installing Using pip<a class="headerlink" href="#installing-using-pip" title="Permalink to this headline">¶</a></h3>
<p>To install the package using pip, execute the following
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span> <span class="n">py_entitymatching</span>
</pre></div>
</div>
<p>The above command will install py_entitymatching and all of its dependencies except
XGBoost, pandastable, openrefine, and PyQt5. This is because pip can only install the
dependency packages that are available in PyPI and PyQt5, XGBoost, pandastable are not
in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
</div>
<div class="section" id="installing-from-source-distribution">
<h3>Installing from Source Distribution<a class="headerlink" href="#installing-from-source-distribution" title="Permalink to this headline">¶</a></h3>
<p>Clone the py_entitymatching package from GitHub</p>
<blockquote>
<div><p>git clone  <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching.git">https://github.com/anhaidgroup/py_entitymatching.git</a></p>
</div></blockquote>
<p>Then,  execute the following commands from the package root:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>which installs py_stringmatching into the default Python directory on your machine. If you do not have installation permission for that directory then you can install the package in your
home directory as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>For more information see this StackOverflow <a class="reference external" href="http://stackoverflow.com/questions/14179941/how-to-install-python-packages-without-root-privileges">link</a>.</p>
<p>The above commands will install py_entitymatching and all of its
dependencies, except PyQt5 and XGBoost.</p>
<p>This is  because, similar to pip, setup.py can only install the dependency packages
that are available in PyPI and PyQt5, pandastable, XGBoost are not in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching supports a set of experimental commands that help users
create an EM workflow. Some of these commands will require installing Dask. To
install dask refer to this <a href="#id8"><span class="problematic" id="id9">`page &lt;http://dask.pydata.org/en/latest/install.html`_</span></a>.</p>
</div>
</div>
</div>
<span id="document-user_manual/overview"></span><div class="section" id="overview-of-supported-em-processes">
<h2>Overview of Supported EM Processes<a class="headerlink" href="#overview-of-supported-em-processes" title="Permalink to this headline">¶</a></h2>
<p>In this section we provide a high-level overview of the EM processes supported by
py_entitymatching. For more details, please read the document “How-To Guide to Entity Matching”
(will soon be available from the package website).</p>
<div class="section" id="supported-em-problem-scenarios">
<h3>Supported EM Problem Scenarios<a class="headerlink" href="#supported-em-problem-scenarios" title="Permalink to this headline">¶</a></h3>
<p>Entity matching (EM) has many problem variations: matching two tables, matching within a
single table, matching from a table into a knowledge base, etc. The package currently only
support matching two tables. Specifically, given two tables A and B of relational tuples,
find all tuple pairs (a in A, b in B) such that a and b refer to the same real-world
entity. The following figure shows an example of matching persons between two given tables.</p>
<a class="reference internal image-reference" href="_images/example-match-two-tables.png"><img alt="'An example of matching two tables'" class="align-center" src="_images/example-match-two-tables.png" style="width: 300.0px; height: 120.0px;" /></a>
<p>Of course, if you want to match tuples within a single table X, you can also use
the package, by matching X with X (you do not have to create another copy of X,
just provide X twice as the input if a command in the package requires two tables A
and B as the input).</p>
</div>
<div class="section" id="two-fundamental-steps-in-the-em-process-blocking-and-matching">
<h3>Two Fundamental Steps in the EM Process: Blocking and Matching<a class="headerlink" href="#two-fundamental-steps-in-the-em-process-blocking-and-matching" title="Permalink to this headline">¶</a></h3>
<p>In practice, tables A and B can be quite large, such as having 100K tuples each, resulting
in 10 billions tuple pairs across A and B. Trying to match all of these pairs is clearly
very expensive. Thus, in such cases the user often employs domain heuristics to quickly
remove obviously non-matched pairs, in a step called <em>blocking</em>, before matching the
remaining pairs, in a step called <em>matching</em>.</p>
<p>The following figure illustrates the above two fundamental steps. Suppose that we are
matching the two tables A and B in (a), where each tuple describes a person. The blocking
step can use a heuristic such as “if two tuples do not agree on state, then they cannot
refer to the same person” to quickly remove all such tuple pairs (this is typically
done using indexes, so the blocking step does not have to enumerate all tuple pairs
between A and B). In other words, the blocking step retains only the four tuple pairs
that agree on state, as shown in (b). The matching step in (c) then considers only these
tuple pairs and predicts for each of them a label “match” or “not-match”
(shown as “+” and “-” in the figure).</p>
<a class="reference internal image-reference" href="_images/example-blocking-matching.png"><img alt="'An example of blocking and matching'" class="align-center" src="_images/example-blocking-matching.png" style="width: 500.0px; height: 220.0px;" /></a>
</div>
<div class="section" id="supported-em-workflows">
<h3>Supported EM Workflows<a class="headerlink" href="#supported-em-workflows" title="Permalink to this headline">¶</a></h3>
<p>The current package supports EM workflows that consist of a blocking step followed by a matching step. Specifically, the package provides a set of blockers and a set of matchers (and the user can easily write his or her own blocker/matcher). Given two tables A and B to be matched, the user applies a blocker to the two tables to obtain a set of tuple pairs, then applies a matcher to these pairs to predict “match” or “no-match”. The user can use multiple blockers in the blocking step, and can combine them in flexible ways. The figure below illustrates both cases.</p>
<a class="reference internal image-reference" href="_images/example-workflow.png"><img alt="'An example of EM workflow'" class="align-center" src="_images/example-workflow.png" style="width: 617.5px; height: 90.25px;" /></a>
<p>Further, the current package supports both rule-based and learning-based matchers. Specifically, rule-based matchers will require the user to write domain specific match rules and learning-based matchers  will require the user to label a set of tuple pairs (as “match” or “no-match”), then use the labeled data to train matchers. In the future, we will consider extending the package to support more powerful EM workflows, such as using multiple matchers, or being able to add rules to process the output of the matchers.</p>
</div>
<div class="section" id="the-development-and-production-stages">
<h3>The Development and Production Stages<a class="headerlink" href="#the-development-and-production-stages" title="Permalink to this headline">¶</a></h3>
<p>In practice EM is typically carried out in two stages. In the development stage, the user tries to find an accurate EM workflow, often using data samples. In the production stage, the user then executes the discovered workflow on the entirety of data. The following figure illustrates the development stage, which is the focus of the current package. The figure also highlights the steps of the development stage that the current package supports.</p>
<p>In the figure, suppose we want to match two tables A and B, each having 1 million tuples. Trying to explore and discover an accurate workflow using these two tables would be too time consuming, because they are too big. Hence, the user will first “down sample” the two tables to obtain two smaller versions, shown as Tables A’ and B’ in the figure, each having 100K tuples, say (see the figure).</p>
<a class="reference internal image-reference" href="_images/example-dev-stage.png"><img alt="'An example of the development stage'" class="align-center" src="_images/example-dev-stage.png" style="width: 500.0px; height: 300.0px;" /></a>
<p>Next, suppose the package provides two blockers X and Y. Then the user will experiment with these blockers (for example, executing both on Tables A’ and B’ and examining their output) to select the blocker judged the best (according to some criterion). Suppose the user selects blocker X. Then next, he or she executes X on Tables A’ and B’ to obtain a set of candidate tuple pairs C.</p>
<p>Next, the user takes a sample S from C, and labels the pairs in S as “match” or “no-match” (see the figure). Let the labeled set be G, and suppose the package provides two matchers U and V. Suppose further that U and V are learning-based matchers (for example, one uses decision trees and the other uses logistic regression). Then in the next step, the user will use the labeled set G to perform cross validation for U and V. Suppose V produces higher matching accuracy (such as F1 score of 0.93, see the figure). Then the user will select V as the matcher, then apply V to the set C to predict “match” or “no-match”, shown as “+” or “-” in the figure. Finally, the user may perform quality check (by examining a sample of the predictions), then go back and debug and modify the previous steps as appropriate. This continues until the user is satisfied with the accuracy of the EM workflow.</p>
<p>Once the user has been satisfied with the EM workflow, the production stage begins. In this stage the user will execute the discovered workflow on the original tables A and B. Since these tables are very large, scaling is a major concern (and is typically solved using Hadoop or Spark). Other concerns include quality monitoring, exception handling, crash recovery, etc.</p>
</div>
<div class="section" id="the-focus-of-the-current-package">
<h3>The Focus of the Current Package<a class="headerlink" href="#the-focus-of-the-current-package" title="Permalink to this headline">¶</a></h3>
<p>The current py_entitymatching package focuses on helping the user with the development stage, that is, help him or her discover an accurate EM workflow. In the future, we will extend the package to also help the user with the production stage.</p>
</div>
</div>
<span id="document-user_manual/guides"></span><div class="section" id="guides">
<h2>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h2>
<p>The goal of this page  is to give you some concrete examples for using py_entitymatching.
These are examples with sample data that is already bundled along with the package. The
examples are in the form of Jupyter notebooks.</p>
<div class="section" id="a-quick-tour-of-jupyter-notebook">
<h3>A Quick Tour of Jupyter Notebook<a class="headerlink" href="#a-quick-tour-of-jupyter-notebook" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/index.html">This tutorial</a>
gives a quick tour on installing and using Jupyter notebook.</p>
</div>
<div class="section" id="end-to-end-em-workflows">
<h3>End-to-End EM Workflows<a class="headerlink" href="#end-to-end-em-workflows" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>EM workflow with blocking using a overlap blocker and matching using Random Forest
matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%201.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using a overlap blocker, selecting among multiple matchers,
using the selected matcher to predict matches, and evaluating the predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%202.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using multiple blockers (overlap and attribute equivalence
blocker), debugging the blocker output, selecting among multiple matchers, debugging the
matcher output, using the selected matcher to predict matches, and evaluating the
predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%203.ipynb">Jupyter notebook</a></p></li>
</ul>
</div>
<div class="section" id="stepwise-guides">
<h3>Stepwise Guides<a class="headerlink" href="#stepwise-guides" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Reading CSV files from disk: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Reading%20CSV%20Files%20from%20Disk.ipynb">Jupyter notebook</a></p></li>
<li><p>Down sampling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Down%20Sampling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data profiling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Profiling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data exploration: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Exploration.ipynb">Jupyter notebook</a></p></li>
<li><p>Blocking:</p>
<blockquote>
<div><ul class="simple">
<li><p>Using overlap blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Overlap%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using attribute equivalence blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Attr.%20Equivalence%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using rule-based blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Rule-Based%20Blocking.ipynb">Jupyter notebook</a></p></li>
<li><p>Using blackbox blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Blackbox%20Blocker.ipynb">Jupyter notebook</a></p></li>
<li><p>Combining multiple blockers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Combining%20Multiple%20Blockers.ipynb">Jupyter notebook</a></p></li>
<li><p>Debugging blocker output: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Debugging%20Blocker%20Output.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Handling features:</p>
<blockquote>
<div><ul class="simple">
<li><p>Generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Editing attribute types and generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Editing%20and%20Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Adding features to feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Adding%20Features%20to%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
<li><p>Removing features from feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Removing%20Features%20From%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Sampling and labeling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Sampling%20and%20Labeling.ipynb">Jupyter notebook</a></p></li>
<li><p>Matching:</p>
<blockquote>
<div><ul class="simple">
<li><p>Selecting the best learning-based matcher (involves splitting the labeled data, generating features,
instantiating multiple matchers, debugging the matcher output): <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Selecting%20the%20Best%20Learning%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Performing matching using rule-based matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Matching%20with%20a%20Rule-Based%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Improving matching results using triggers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Using%20Match%20Triggers%20to%20Improve%20Results.ipynb">Jupyter notebook</a></p></li>
<li><p>Evaluating the predictions from a matcher:  <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Evaluating%20the%20Selected%20Matcher.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<span id="document-user_manual/datastructures"></span><div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p>In py_entitymatching, we will need to store many tables and metadata associated
with it. It is important for you to know the data structures that are used to store
the tables and the metadata, so that you can manipulate them based on your need.</p>
<p>As a convention, we will use:</p>
<ul class="simple">
<li><p>A and B to refer to the original two tables to be matched,</p></li>
<li><p>C to refer to the candidate set table obtained from A and B after the blocking step,</p></li>
<li><p>S to refer to a sample taken from C, and</p></li>
<li><p>G to refer to a table that contains the tuple pairs in S and a golden label for each
pair (indicating the pair as matches or non-matches).</p></li>
</ul>
<div class="section" id="storing-tables-using-pandas-dataframes">
<h3>Storing Tables Using Pandas Dataframes<a class="headerlink" href="#storing-tables-using-pandas-dataframes" title="Permalink to this headline">¶</a></h3>
<p>We will need to store a lot of data as tables in py_entitymatching. We use pandas Dataframes to
represent tables (you can read more about pandas and pandas Dataframes <a class="reference external" href="http://pandas.pydata.org/">here</a>).</p>
<p><strong>Tuple:</strong> We often refer to a row of a table as tuple. Each tuple is just a row
in a Dataframe and this is of type pandas Series (you can read more about pandas Series
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html">here</a>).</p>
</div>
<div class="section" id="storing-metadata-using-a-catalog">
<h3>Storing Metadata Using a Catalog<a class="headerlink" href="#storing-metadata-using-a-catalog" title="Permalink to this headline">¶</a></h3>
<p><strong>Bare Minimum that You Should Know:</strong>
In py_entitymatching, we need to store a lot of metadata with a table such as
key and foreign key. We use a
new data structure, Catalog, to store metadata. You need not worry
about instantiating this object (it gets automatically instantiated when py_entitymatching
gets loaded in Python memory) or manipulating this object directly.</p>
<p>All the py_entitymatching commands correctly handle the metadata in the Catalog,
and for you, there are commands to manipulate the Catalog (please see
<a class="reference internal" href="singlepage.html#label-handling-metadata"><span class="std std-ref">Handling Metadata</span></a> section for the supported commands).</p>
<p><strong>If You Want to Read More:</strong>
As we mentioned earlier,  we need to store a lot of metadata with a table. Here are a few examples:</p>
<ul class="simple">
<li><p>Each table in py_entitymatching should have a key, so that we can easily identify the tuples.
Keys are also critical later for debugging, provenance, etc. Key is a metadata that we
want to store for a table.</p></li>
<li><p>The blocking step will create tuple pairs from two tables A and B. For example,
suppose we have table A(aid, a, b) and table B(bid, x, y), then the tuple pairs can be
stored in a candidate set table C(cid, aid, bid, a, b, x, y). This table could be very
big, taking up a lot of space in memory. To save space, we may want to just store C as
C(cid, aid, bid) and then have pointers back to tables A and B. The two pointers back
to A and B are metadata that we may want to store for table C. Specifically, the
metadata for C include key (<cite>cid</cite>) and foreign keys (<cite>aid</cite>, <cite>bid</cite>) to the base tables
(<cite>A</cite>, <cite>B</cite>).</p></li>
</ul>
<p>There are many other examples of metadata that we may want to store for a table. Though
pandas Dataframes is a good choice for storing data as tables, it does not provide a
robust way to store metadata (for more discussion on this topic, please look at <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2485">this thread</a>).
To tackle this, we have a new data structure, <cite>Catalog</cite> to store the metadata for tables.</p>
<p>Conceptually, Catalog is a dictionary, where the keys are unique identifiers for
each Dataframe and the values are dictionaries containing metadata.
This dictionary can have different kinds of keys that point to metadata.
Examples of such keys are:</p>
<ul class="simple">
<li><p>key: the name of the key attribute of the table.</p></li>
<li><p>ltable: pointer to the left table (see below).</p></li>
<li><p>rtable: pointer to the right table (see below).</p></li>
</ul>
<p>The kind of metadata stored for a table would depend on the table itself. For example,
the input tables must have a key and this can be the only metadata.</p>
<p>But, if we consider table C (which is obtained by performing blocking on input tables A
and B), this table can be very large, so we typically represent it using a view over
two tables A and B. Such a table C will have the following attributes:</p>
<ul class="simple">
<li><p>_id (key attribute of table C).</p></li>
<li><p>ltable_aid (aid is the key attribute in table A).</p></li>
<li><p>rtable_bid (bid is the key attribute in table B).</p></li>
<li><p>some attributes from A and B.</p></li>
</ul>
<p>The metadata dictionary for table C will have at least these fields:</p>
<ul class="simple">
<li><p>key: _id.</p></li>
<li><p>ltable: points to table A.</p></li>
<li><p>rtable: points to table B.</p></li>
<li><p>fk_ltable: ltable_aid (that is, ltable.aid is a foreign key of table A).</p></li>
<li><p>fk_rtable: rtable_bid.</p></li>
</ul>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Tables in py_entitymatching are represented as pandas Dataframes.</p></li>
<li><p>The metadata for tables are stored in a separate data structure called Catalog.</p></li>
<li><p>The kind of metadata stored will depend on the table (for example input table will have key,
and the table from blocking will have key, ltable, rtable, fk_table, fk_rtable).</p></li>
<li><p>So there are five reserved keywords for metadata: key, ltable, rtable, fk_ltable,
fk_rtable. You should not use these names to store metadata for other application
specific purposes.</p></li>
</ul>
</div>
</div>
<span id="document-user_manual/steps_supp_em_workflows"></span><div class="section" id="steps-of-supported-em-workflows">
<h2>Steps of Supported EM Workflows<a class="headerlink" href="#steps-of-supported-em-workflows" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/read_csv_files"></span><div class="section" id="reading-the-csv-files-from-disk">
<h3>Reading the CSV Files from Disk<a class="headerlink" href="#reading-the-csv-files-from-disk" title="Permalink to this headline">¶</a></h3>
<p>Currently, py_entitymatching only asupports reading CSV files from disk.</p>
<p><strong>The Minimal That You Should Do:</strong> First, you must store the input tables as CSV files
in disk. Please look at section <a class="reference internal" href="singlepage.html#label-csv-format"><span class="std std-ref">CSV Format</span></a> to learn more
about CSV format. An example of a CSV file will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94121</span>
</pre></div>
</div>
<p>Next, each table in py_entitymatching must have a key column. If the table already
has a key column, then you can read the CSV file and set the key column as like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ID is the key column in table.csv</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the table does not have a key column, then you can read the CSV file, add a
key column and set the added key column like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read the CSV file</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
<span class="c1"># Add a key column with name &#39;ID&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="c1"># Set &#39;ID&#39; as the key column</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>If You Want to Read and Play Around More:</strong> In general, the command
<a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a> looks for a file (with the same file name
as the <cite>CSV</cite> file) with <cite>.metadata</cite> extension in the same directory containing the
metadata. If the file containing metadata information is not present, then
<a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a> will proceed just reading the CSV file
as mentioned in the command.</p>
<p>To update the metadata for a table, using a metadata file, first, you must manually create
this file and specify the metadata for a table and then call
<a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a>. The command will automatically read the metadata from the
file and update the Catalog.</p>
<p>For example, if you read <cite>table.csv</cite> then <a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a>
looks for <cite>table.metadata</cite> file. The contents of <cite>table.metadata</cite> may look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>Each line in the file starts with <cite>#</cite>. The metadata is written as <cite>key=value</cite> pairs,
one in each line. The contents of the above file says that <cite>ID</cite> is the key attribute
(for the table in the file <cite>table.csv</cite>).</p>
<p>The table mentioned in the above example along with the metadata file
stored in the same directory can be read as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once, the table is read, you can check to see which
attribute of the table is a key using <a class="reference internal" href="singlepage.html#py_entitymatching.get_key" title="py_entitymatching.get_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_key()</span></code></a> command as
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   &#39;ID&#39;</span>
</pre></div>
</div>
<p>As you see, the key for the table is updated correctly as ‘ID’.</p>
<p>See <a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a> for more details.</p>
</div>
<span id="document-user_manual/down_sampling"></span><div class="section" id="down-sampling">
<h3>Down Sampling<a class="headerlink" href="#down-sampling" title="Permalink to this headline">¶</a></h3>
<p>Once the tables to be matched are read, they must be down sampled if the number of
tuples in them are large (for example, 100K+ tuples). This is because working with
large tables can be very time consuming (as any operation performed would have
to process these large tables).</p>
<p>Random sampling however does not work, because the sampled may end up sharing very
few matches, especially if the number of matches between the
input tables are small to begin with.</p>
<p>In py_entitymatching, you can use sample the input tables using <cite>down_sample</cite> command.
This command samples the input tables intelligently that ensures a reasonable number of
matches between them.</p>
<p>If <cite>A</cite> and <cite>B</cite> are the input tables, then you can use <cite>down_sample</cite> command as shown
below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y_param</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Conceptually, the command takes in two original input tables, <cite>A</cite>, <cite>B</cite> (and some parameters),
and produces two sampled tables, <cite>sample_A</cite> and <cite>sample_B</cite>.
Specifically, you must set the <cite>size</cite> to be the number of tuples that
should be sampled from <cite>B</cite> (this will be the size of <cite>sample_B</cite> table) and set the
<cite>y_param</cite> to be the number of tuples to be selected from <cite>A</cite> (for each tuple in
<cite>sample_B</cite> table). The command internally uses a
heuristic to ensure a reasonable number of matches between <cite>sample_A</cite> and <cite>sample_B</cite>.</p>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.down_sample" title="py_entitymatching.down_sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">down_sample()</span></code></a> for more
details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the input tables must be loaded in memory before the user can down
sample.</p>
</div>
</div>
<span id="document-user_manual/profiling"></span><div class="section" id="profiling-data">
<h3>Profiling Data<a class="headerlink" href="#profiling-data" title="Permalink to this headline">¶</a></h3>
<p>Profiling data is used to help users get general information about their data.
Before working with the data, it is useful for a user to have a high level
understanding of the data because he or she will be able to take advantage of
the the general trends to successfully and efficiently complete the rest of
the workflow.</p>
<p>Data profiling specifically can show users important statistics such as type,
uniqueness, missing values, quartile statistics, mean, mode, standard deviation,
sum, median absolute deviation, coefficient of variation, kurtosis, skewness.
It can also display information to the user visually such as in a histogram.</p>
<p>We recommend using the python package pandas-profiling because it is simple
and easy to use. More information about the package can be found on the github
page at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
<div class="section" id="example-usage">
<h4>Example Usage<a class="headerlink" href="#example-usage" title="Permalink to this headline">¶</a></h4>
<p>After reading in a CSV file into a Dataframe, pandas-profiling shows the user a
report containing useful profiling information. For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The user can also check to see if any variables are highly correlated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check for rejected variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rejected_variables</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">get_rejected_variables</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>The report generated can also be saved into an html file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to a variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to an html file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outputfile</span><span class="o">=</span><span class="s2">&quot;/tmp/myoutputfile.html&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information about pandas-profiling please go to the github page
at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
</div>
</div>
<span id="document-user_manual/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<p>Data exploration is an important part of the entity matching workflow because it
gives the user a chance to look at the actual data closely. Data exploration
allows the user to inspect the individual records and features present in the
table so that he or she can understand the important trends and relationships
present in the data. A complete understanding of the data gives the user an
advantage later on in the entity matching workflow.</p>
<div class="section" id="openrefine">
<h4>OpenRefine<a class="headerlink" href="#openrefine" title="Permalink to this headline">¶</a></h4>
<p>OpenRefine is a data exploration tool that is compatible with Python &gt;= 2.7 or
Python &gt;= 3.4. More information about OpenRefine can be found at its github page
at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine">https://github.com/OpenRefine/OpenRefine</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>OpenRefine is not included with py_entitymatching and must be downloaded and
installed separately. The installation instructions can be found at
<a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
</div>
<div class="section" id="using-openrefine">
<h5>Using OpenRefine<a class="headerlink" href="#using-openrefine" title="Permalink to this headline">¶</a></h5>
<p>Before using OpenRefine, you must start the application to start an OpenRefine
server. The explanations for doing so are explained after the installation
instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
<p>Once the application has created a server, copy the URL from the address bar of
the OpenRefine browser (default is <a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a> ). Then the data can
be explored as in the example below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save the project back to our dataframe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calling export_pandas_frame will automatically delete the OpenRefine project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">export_pandas_frame</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pandastable">
<h4>Pandastable<a class="headerlink" href="#pandastable" title="Permalink to this headline">¶</a></h4>
<p>Pandastable is a data exploration tool available for python &gt;=3.4 that allows users
to view and manipulate data. More information about pandastable can be found at
<a class="reference external" href="https://github.com/dmnfarrell/pandastable">https://github.com/dmnfarrell/pandastable</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pandastable is not packaged along with py_entitymatching. You can install
pandastable using pip as show below:</p>
<blockquote>
<div><p>$ pip install pandastable</p>
</div></blockquote>
<p>or conda as shown below:</p>
<blockquote>
<div><p>$ conda install -c dmnfarrell pandastable=0.7.1</p>
</div></blockquote>
</div>
<div class="section" id="using-pandastable">
<h5>Using pandastable<a class="headerlink" href="#using-pandastable" title="Permalink to this headline">¶</a></h5>
<p>Pandastable can be easily be used with the wrappers included with py_entitymatching.
The following example shows how:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import py_entitymatching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Explore the data using pandastable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-user_manual/blocking"></span><div class="section" id="specifying-blockers-and-performing-blocking">
<h3>Specifying Blockers and Performing Blocking<a class="headerlink" href="#specifying-blockers-and-performing-blocking" title="Permalink to this headline">¶</a></h3>
<p>In this section, we discuss how you can specify blockers and perform blocking.</p>
<div class="section" id="types-of-blockers-and-blocker-hierarchy">
<h4>Types of Blockers and Blocker Hierarchy<a class="headerlink" href="#types-of-blockers-and-blocker-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>Once the tables are loaded and downsampled, most often you have to do blocking.
Note that by <em>blocking</em> we mean to block a <em>tuple pair</em> from going through to the
matching step. When applied to a tuple pair, a blocker returns <em>True</em> if the pair
should be blocked. You must know conceptually the types of blockers and
the blocker hierarchy in py_entitymatching to extend or modify them based on your need.</p>
<p>There are two types of blockers: (1) tuple-level, and (2) global. A tuple-level blocker
can examine a tuple pair in isolation and decide if it should be admitted to the next
stage. For example, an attribute equivalence blocker is a tuple-level blocker. A global
blocker cannot make this decision in isolation. It would need to examine a set of other
pairs as well. For example, a sorted neighborhood blocker applied over an union of the
input tables is a global blocker. Currently, py_entitymatching supports only
tuple-level blockers.</p>
<p>The blockers can be combined in complex ways, such as</p>
<ul class="simple">
<li><p>apply blocker <em>b1</em> to the two tables</p></li>
<li><p>apply blocker <em>b2</em> to the two tables</p></li>
<li><p>apply blocker <em>b3</em> to the output of <em>b1</em></p></li>
</ul>
<p>Further, you may just want to apply a blocker to just a pair of tuples, to see how
the blocker works.</p>
<p>In py_entitymatching, there is a Blocker class from which a set of concrete blockers
are inherited. These concrete blockers implement the following methods:</p>
<ul class="simple">
<li><p>block_tables (apply to input tables A and B)</p></li>
<li><p>block_candset (apply to an output from another blocker (e.g. table C))</p></li>
<li><p>block_tuples (apply to a tuple pair to check if it will survive blocking)</p></li>
</ul>
<p>In py_entitymatching, there are four concrete blockers implemented: (1) attribute
equivalence blocker, (2) overlap blocker, (3) rule-based blocker, and (4) black box
blocker. All the functions implemented in the concrete blockers are metadata aware.</p>
<p>The class diagram of Blocker and the concrete blockers inherited from it is shown below:</p>
<a class="reference internal image-reference" href="_images/blocker_hierarchy.png"><img alt="'Blocker Hierarchy'" src="_images/blocker_hierarchy.png" style="width: 1162.0px; height: 259.0px;" /></a>
</div>
<div class="section" id="built-in-blockers">
<h4>Built-In Blockers<a class="headerlink" href="#built-in-blockers" title="Permalink to this headline">¶</a></h4>
<p>Built-in blockers are those that have been built into py_entitymatching and you can just
simply call them. <em>py_entitymatching</em> currently offers three built-in blockers.</p>
<p><strong>Attribute Equivalence Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in attribute equivalence blocker
takes an attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that
is, drop the tuple pair) if <cite>x</cite> and <cite>y</cite> are not of the same value.</p>
<p>An example of using the above function is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="py_entitymatching.AttrEquivalenceBlocker.block_tables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>. An example of using
<cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="py_entitymatching.AttrEquivalenceBlocker.block_candset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="py_entitymatching.AttrEquivalenceBlocker.block_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
<p><strong>Overlap Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in overlap blocker takes an
attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that is, drop
the tuple pair) if <cite>x</cite> and <cite>y</cite> do not share any token (where the token is a word or
a q-gram).</p>
<p>As part of the pre-processing for this blocker, the strings are first converted to lowercase.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.OverlapBlocker.block_tables" title="py_entitymatching.OverlapBlocker.block_tables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.OverlapBlocker.block_candset" title="py_entitymatching.OverlapBlocker.block_candset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.OverlapBlocker.block_tuples" title="py_entitymatching.OverlapBlocker.block_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
<p><strong>Sorted Neighborhood Blocker</strong></p>
<p>WARNING: THIS IS AN EXPERIMENTAL COMMAND. THIS COMMAND IS NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> works in the following manner.
First, for table A, <cite>block_tables</cite> creates a blocking attribute for every tuple using the output of <cite>l_block_attr</cite>.
Next, for table B, <cite>block_tables</cite> similarly creates a blocking attribute using the output of <cite>r_block_attr</cite>.
Then, tables A and B are combined and sorted on the blocking attribute.</p>
<p>Finally, a sliding window of size <cite>window_size</cite> is passed through the sorted dataset.
If two tuples are within <cite>window_size</cite> positions of each other in sorted order, and the two tuples
come from different tables, then the two tuples are returned in the candidate set.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sn</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">SortedNeighborhoodBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">3</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.SortedNeighborhoodBlocker.block_tables" title="py_entitymatching.SortedNeighborhoodBlocker.block_tables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>Unlike the other two blockers, since the sorted neighborhood blocker requires the sorted order
of all tuples in the database, <cite>block_candset</cite> and <cite>block_tuples</cite> are not applicable and will raise an assertion if called.</p>
<p>Two things to note.
First, consider the trade-off of possible values to <cite>window_size</cite>.
If the size is too small, actually-matching tuples will not be returned in the candidate set (and thus, missed).
If the window size is very large, the resulting candidate set will also be excessively large, hurting performance.
The exact size needed is unique to each dataset.</p>
<p>Second, if <cite>window_size</cite> is smaller than a range of matching tuples, and actually-matching tuples will be missed, not be returned in the candidate set.
However, if the blocking attribute is not sufficient to make a unique sorted order, than the resulting sorted order is one of a set of potential sorted orders.
If the method of sorting changes, for instance if more cores are used, a different sorted order may be returned.
This sorted order may result in a different candidate set being returned.
To avoid this situation it is recommended to add some uniqueness into the blocking attribute (such as the ID), so that there is only one correct sorted order.
This will help ensure the same set of results are returned from the same inputs.
An example of this is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">l_output_prefix</span><span class="o">=</span><span class="s1">&#39;l_&#39;</span><span class="p">,</span> <span class="n">r_output_prefix</span><span class="o">=</span><span class="s1">&#39;r_&#39;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example a new attribute <cite>birth_year_plus_id</cite> is used as the blocking attribute, and will always have the same sorted order.</p>
</div>
<div class="section" id="blackbox-blockers">
<h4>Blackbox Blockers<a class="headerlink" href="#blackbox-blockers" title="Permalink to this headline">¶</a></h4>
<p>By <cite>blackbox blockers</cite> we mean that the user supplies a Python function which
encodes blocking for a tuple pair. Specifically, the Python function will take
in two tuples and returns True if the tuple pair needs to be blocked, else
returns False. To use a blackbox blocker, first you must write a
blackbox blocker function.</p>
<p>An example of blackbox blocker function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that there is a &#39;name&#39; attribute in the input tables</span>
    <span class="c1"># and each value in it has two words</span>
    <span class="n">l_last_name</span> <span class="o">=</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_last_name</span> <span class="o">=</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">l_last_name</span> <span class="o">!=</span> <span class="n">r_last_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Then instantiate a <cite>blackbox blocker</cite> and set the blocking function function as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, you can call <cite>block_tables</cite> on the input tables. Conceptually, <cite>block_tables</cite> would
apply the blackbox blocker function on the Cartesian product of the input tables A and B, and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.BlackBoxBlocker.block_tables" title="py_entitymatching.BlackBoxBlocker.block_tables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.BlackBoxBlocker.block_candset" title="py_entitymatching.BlackBoxBlocker.block_candset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>Further, <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.BlackBoxBlocker.block_tuples" title="py_entitymatching.BlackBoxBlocker.block_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="rule-based-blockers">
<h4>Rule-Based Blockers<a class="headerlink" href="#rule-based-blockers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for blocking purposes) using rule-based blocker.
If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>block_f</cite>. Then you will be able
to instantiate a rule-based blocker and add rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_f</cite> is a set of features stored as a Dataframe (see section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The blocker is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be blocked.</p>
<p>Once the rules are specified, you can call <cite>block_tables</cite> on the input tables.
Conceptually, <cite>block_tables</cite> would
apply the rule-based blocker function on the Cartesian product of the input tables A and B and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.RuleBasedBlocker.block_tables" title="py_entitymatching.RuleBasedBlocker.block_tables"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.RuleBasedBlocker.block_candset" title="py_entitymatching.RuleBasedBlocker.block_candset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.RuleBasedBlocker.block_tuples" title="py_entitymatching.RuleBasedBlocker.block_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="combining-multiple-blockers">
<h4>Combining Multiple Blockers<a class="headerlink" href="#combining-multiple-blockers" title="Permalink to this headline">¶</a></h4>
<p>If you use multiple blockers, then you have to combine them to get a
consolidated candidate set. There are many different ways to combine the candidate sets
such as doing union, majority vote, weighted vote, etc. Currently, py_entitymatching
only supports union-based combining.</p>
<p>In py_entitymatching, <cite>combine_blocker_outputs_via_union</cite> is used to do union-based
combining.</p>
<p>An example of using <cite>combine_blocker_outputs_via_union</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes in a list of blocker outputs (i.e. pandas Dataframes) and
produces a consolidated table. The output table contains the union of tuple pair ids and
other attributes from the input list.</p>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.combine_blocker_outputs_via_union" title="py_entitymatching.combine_blocker_outputs_via_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_blocker_outputs_via_union()</span></code></a>
for more details.</p>
</div>
</div>
<span id="document-user_manual/create_feats_for_blocking"></span><div class="section" id="creating-features-for-blocking">
<span id="label-create-features-blocking"></span><h3>Creating Features for Blocking<a class="headerlink" href="#creating-features-for-blocking" title="Permalink to this headline">¶</a></h3>
<p>Recall that when doing blocking, you can use built-in blockers,
blackbox blockers, or rule-based blockers. For rule-based blockers,
you have to create a set of features. While creating features, you will have to
refer to tokenizers, similarity functions, and attributes of the tables.
Currently, in py_entitymatching, there are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically generate a set of features (then you can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<p>Note that features will also be used in the matching process, as we
will discuss later.</p>
<p>If you are interested in just letting the system to automatically
generate a set of features, then please see <a class="reference internal" href="#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>.</p>
<p>If you want to generate features on your own, please read below.</p>
<div class="section" id="available-tokenizers-and-similarity-functions">
<h4>Available Tokenizers and Similarity Functions<a class="headerlink" href="#available-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>A tokenizer is a function that takes a string and optionally a number
of other arguments, then tokenizes the string and returns a set of tokens.
Currently, the following tokenizers are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Alphabetic</p></li>
<li><p>Alphanumeric</p></li>
<li><p>White space</p></li>
<li><p>Delimiter based</p></li>
<li><p>Qgram based</p></li>
</ul>
<p>A similarity function takes two arguments (can be strings, numeric values, etc.),
which are typically two attribute values such
as two book titles, then returns an output value which is typically a similarity score
between the two attribute values. Currently, the following similarity functions
are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Affine</p></li>
<li><p>Hamming distance</p></li>
<li><p>Jaro</p></li>
<li><p>Jaro-Winkler</p></li>
<li><p>Levenshtein</p></li>
<li><p>Monge-Elkan</p></li>
<li><p>Needleman-Wunsch</p></li>
<li><p>Smith-Waterman</p></li>
<li><p>Jaccard</p></li>
<li><p>Cosine</p></li>
<li><p>Dice</p></li>
<li><p>Overlap coefficient</p></li>
<li><p>Exact match</p></li>
<li><p>Absolute norm</p></li>
</ul>
</div>
<div class="section" id="obtaining-tokenizers-and-similarity-functions">
<h4>Obtaining Tokenizers and Similarity Functions<a class="headerlink" href="#obtaining-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>First you need to get tokenizers and similarity functions to refer them in features.
In py_entitymatching, you can use
<cite>get_tokenizers_for_blocking</cite> to get all the tokenizers available for blocking purposes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_t</cite> is a dictionary where keys are tokenizer names
and values are tokenizer functions in Python. You can inspect <cite>block_t</cite> and delete/add
tokenizers as appropriate. The above command will return single-argument tokenizers,
i.e., those that take a string then produce a set of tokens.</p>
<p>Each of the keys of the default dictionary returned to ‘block_t’ by
‘get_tokenizers_for_blocking’ represent a tokenizer that can be used by similarity
functions. The keys and the respective tokenizer they represent are shown below:</p>
<ul class="simple">
<li><p>alphabetic: Alphabetic tokenizer</p></li>
<li><p>alphanumeric: Alphanumeric tokenizer</p></li>
<li><p>dlm_dc0: Delimiter tokenizer using spaces as the delimiter</p></li>
<li><p>qgm_2: Two Gram tokenizer</p></li>
<li><p>qgm_3: Three Gram tokenizer</p></li>
<li><p>wspace: Whitespace tokenizer</p></li>
</ul>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_blocking()</span></code></a>
for more details.</p>
<p>Similarly, the user can use <cite>get_sim_funs_for_blocking</cite> to get all the similarity
functions available for blocking purposes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_s</cite> is a dictionary where keys are similarity function names
and values are similarity functions in Python. Similar to <cite>block_t</cite>, you can
inspect <cite>block_s</cite> and delete/add similarity functions as appropriate.</p>
<p>Each of the keys of the default dictionary returned to ‘block_s’ by
‘get_sim_funs_for_blocking’ represent a similarity function. The keys and the
respective similarity function they represent are shown below:</p>
<ul class="simple">
<li><p>abs_norm: Absolute Norm</p></li>
<li><p>affine: Affine Transformation</p></li>
<li><p>cosine: Cosine Similarity</p></li>
<li><p>dice: Dice similarity Coefficient</p></li>
<li><p>exact_match: Exact Match</p></li>
<li><p>hamming_dist: Hamming Distance</p></li>
<li><p>hamming_sim: Hamming Similarity</p></li>
<li><p>jaccard: Jaccard Similarity</p></li>
<li><p>jaro: Jaro Distance</p></li>
<li><p>jaro_winkler: Jaro-Winkler Distance</p></li>
<li><p>lev_dist: Levenshtein Distance</p></li>
<li><p>lev_sim: Levenshtein Similarity</p></li>
<li><p>monge_elkan: Monge-Elkan Algorithm</p></li>
<li><p>needleman_wunsch: Needleman-Wunsch Algorithm</p></li>
<li><p>overlap_coeff: Overlap Coefficient</p></li>
<li><p>rel_diff: Relative Difference</p></li>
<li><p>smith_waterman: Smith-Waterman Algorithm</p></li>
</ul>
<p>Please look at the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_sim_funs_for_blocking()</span></code></a>
for more details.</p>
</div>
<div class="section" id="obtaining-attribute-types-and-correspondences">
<h4>Obtaining Attribute Types and Correspondences<a class="headerlink" href="#obtaining-attribute-types-and-correspondences" title="Permalink to this headline">¶</a></h4>
<p>In the next step, you need to obtain type and correspondence information about A and B
so that the features can be generated.</p>
<p>First, you need to obtain the types of attributes in A and B,
so that the right tokenizers/similarity functions can be applied to each of them.
In py_entitymatching, you can use <cite>get_attr_types</cite> to get the attribute types.
An example of using <cite>get_attr_types</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>atypes1</cite> and <cite>atypes2</cite> are dictionaries. They contain, the type of
attribute in each of the tables. Note that this <cite>type</cite> is different from basic
Python types. Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_types()</span></code></a> for more details.</p>
<p>Next, we need to obtain correspondences between the attributes of A and B,
so that the features can be generated based on those correspondences.
In py_entitymatching, you can use <cite>get_attr_corres</cite> to get the attribute
correspondences.</p>
<p>An example of using <cite>get_attr_corres</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_c</cite> is a dictionary containing attribute correspondences.
Currently, py_entitymatching returns attribute correspondences only based on the exact
match of attribute names. You can inspect <cite>block_c</cite> and modify the attribute
correspondences. Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_corres()</span></code></a> for more details.</p>
</div>
<div class="section" id="getting-a-set-of-features">
<span id="label-get-a-set-of-features-manual"></span><h4>Getting a Set of Features<a class="headerlink" href="#getting-a-set-of-features" title="Permalink to this headline">¶</a></h4>
<p>Recall that so far we have obtained:</p>
<ul class="simple">
<li><p>block_t, the set of tokenizers,</p></li>
<li><p>block_s, the set of sim functions</p></li>
<li><p>atypes1 and atypes2, the types of attributes in A and B</p></li>
<li><p>block_c, the correspondences of attributes in A and B</p></li>
</ul>
<p>Next, to obtain a set of features, you can use <cite>get_features</cite> command.
An example of using <cite>get_features</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Briefly, this function will go through the correspondences. For each
correspondence <cite>m</cite>, it examines the types of the involved attributes,
then apply the appropriate tokenizers and similarity functions to generate
all appropriate features for this correspondence. The features are returned as
a Dataframe. Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.get_features" title="py_entitymatching.get_features"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features()</span></code></a> for more details.</p>
</div>
<div class="section" id="adding-removing-features">
<span id="label-add-remove-features"></span><h4>Adding/Removing Features<a class="headerlink" href="#adding-removing-features" title="Permalink to this headline">¶</a></h4>
<p>Given the set of features <cite>block_f</cite> as a pandas Dataframe, you can delete certain features,
add new features.</p>
<p>Deletion of a feature is straightforward, all that you have to do is delete the row
from the feature table corresponding to the feature. You can use <cite>drop</cite> command
from pandas Dataframe for this purpose. Please look at this
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html">API reference link</a>
for more details.</p>
<p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define a feature declartively and add it to
feature table.</p>
<p><strong>Adding a Blackbox Function as Feature</strong></p>
<p>To create and add a blackbox function as a feature, first you must define it. Specifically,
the function must take in two tuples as input and return a numeric value. An example of
a blackbox function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the feature table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.add_blackbox_feature" title="py_entitymatching.add_blackbox_feature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_blackbox_feature()</span></code></a> for more details.</p>
<p><strong>Adding a Feature Declaratively</strong></p>
<p>Another way to add features is to write a feature expression in
a <cite>declarative</cite> way. py_entitymatching will then compile it into a feature. For
example, you can declaratively create and add a feature like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple[&quot;name&quot;]), qgm_3(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <cite>block_t</cite> and <cite>block_s</cite> refer to the dictionaries containing a set of
tokenizers and similarity functions for blocking. Additionally, ‘jaccard’ refers
to the key in ‘block_s’ that represents the Jaccard Similarity function and
‘qgm_3’ refers to the key in ‘block_t’ that represents a three gram tokenizer.
The keys in ‘block_t’ and ‘block_s’ and which function or tokenizer they
represent are explained above in the Obtaining Tokenizers and Similarity Functions
section.</p>
<p>Conceptually, the first command, <cite>get_feature_fn</cite>, creates a feature which is a Python function
that will take two tuples <cite>ltuple</cite> and <cite>rtuple</cite>, get the attribute publisher from <cite>ltuple</cite>,
issuer from <cite>rtuple</cite>, tokenize them, then compute jaccard score.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The feature must refer the tuple from the left table (say A) as <strong>ltuple</strong> and
the tuple from the right table (say B) as <strong>rtuple</strong>.</p>
</div>
<p>The second command, <cite>add_feature</cite> tags the feature with the specified name,
and adds it to the feature table.</p>
<p>As described, the feature that was just created is <em>independent</em> of any table
(eg A and B). Instead, it expects as the input two tuples: ltuple and rtuple.</p>
<p>You can also create more complex features. Specifically,
you are allowed to define arbitrary complex expression involving function names from
<cite>block_t</cite> and <cite>block_s</cite>, and attribute names from ltuple and rtuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create your own similarity functions and tokenizers for your custom features.
For example, you can create a similarity function that changes all strings to lowercase
before checking if they are equivalent.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function converts the two strings to lowercase before checking if they are an exact match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_lowercase</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">l_attr</span> <span class="o">=</span> <span class="n">l_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">r_attr</span> <span class="o">=</span> <span class="n">r_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>You can then add a feature declarativly with your new similarity function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new similarity function is added to block_s and then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;match_lowercase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_lowercase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;match_lowercase(ltuple[&quot;name&quot;], rtuple[&quot;name&quot;])&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_match_lowercase&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to create features with your own similarity functions that require
tokenizers. The next example shows how to create a custom tokenizer that returns only
the first and last words of a string.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This custom tokenizer returns the first and last words of a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_tok</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">all_toks</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">toks</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_toks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_toks</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">all_toks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">toks</span>
</pre></div>
</div>
<p>Next, a similarity function that can utilize the new tokenizer is created. This example
shows how to create a similarity function that raises the score if the first words match
and raises the score by one if the second words match.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function compares two tokens from each set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Greater weight is placed on the equality of the first token.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_sim</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">score</span>
</pre></div>
</div>
<p>Finally, with the tokenizer and similarity functions defined, the new feature can be
created and added.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new tokenizer is added to block_t and the new similarity function is added to block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span><span class="p">[</span><span class="s1">&#39;first_last_tok&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_tok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;first_last_sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;first_last_sim(first_last_tok(ltuple[&quot;name&quot;]), first_last_tok(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_fls_flt_flt&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code></a> and <a class="reference internal" href="singlepage.html#py_entitymatching.add_feature" title="py_entitymatching.add_feature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_feature()</span></code></a>
for more details.</p>
</div>
<div class="section" id="summary-of-the-manual-feature-generation-process">
<h4>Summary of the Manual Feature Generation Process<a class="headerlink" href="#summary-of-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of commands for the entire manual feature generation process.</p>
<p>To generate features, you must execute the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <cite>block_f</cite> points to a Dataframe containing features as rows.</p>
</div>
<div class="section" id="ways-to-edit-the-manual-feature-generation-process">
<h4>Ways to Edit the Manual Feature Generation Process<a class="headerlink" href="#ways-to-edit-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of ways to edit the variables used in feature generation process.</p>
<ul>
<li><p>The <cite>block_t</cite>, <cite>block_s</cite>, <cite>atypes1</cite>, <cite>atypes2</cite>, <cite>block_c</cite> are dictionaries. You
can modify these variables based on your need, to add/remove tokenizers,
similarity functions, attribute correspondences, etc.</p></li>
<li><p><cite>block_f</cite> is a Dataframe. You can remove a feature by just deleting the corresponding
tuple from the Dataframe.</p></li>
<li><p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define the feature declartively and add it to
feature table.
To add a blackbox feature, first write a blackbox function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>To add a feature declaratively, first write a feature expression and compile it to feature
using <cite>get_feature_fn</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_feature</cite> like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="generating-features-automatically">
<span id="label-gen-feats-automatically"></span><h4>Generating Features Automatically<a class="headerlink" href="#generating-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>Recall that to get the features for blocking, eventually you
must execute the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>atypes1</cite>/<cite>atypes2</cite> are the attribute types of A and B, <cite>block_c</cite> is
the correspondences between their attributes, <cite>block_t</cite> is the set of tokenizers,
and <cite>block_s</cite> is the set of similarity functions.</p>
<p>If you don’t want to go through the hassle of creating these intermediate
variables, then you can execute the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The system will automatically generate a set of features and return it as
as a Dataframe which you can then use for blocking purposes. This Dataframe
contains a few attributes that require further explanation, specifically
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, and ‘simfunction’. There are
two types of similarity functions, those that use tokenizers and those that
do not. Some similarity functions use tokenizers and all such features must
designate a tokenizer for both the left table attribute in
‘left_attr_tokenizer’ and for the right table attribute in
‘right_attr_tokenizer’. The ‘simfunction’ attribute refers to the name of
the function and comes from the keys in ‘block_s’. The various keys and the
actual functions they correspond to are explained in the Obtaining
Tokenizers and Similarity Functions section above.</p>
<p>The command <cite>get_features_for_blocking</cite> will set the following variables: <cite>_block_t</cite>,
<cite>_block_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, and <cite>_block_c</cite>. You can access these variables like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_c</span>
</pre></div>
</div>
<p>You can examine these variables, modify them as appropriate, and
then perhaps re-generate the set of features using <cite>get_features</cite> command.</p>
<p>Please look at the API reference of
<a class="reference internal" href="singlepage.html#py_entitymatching.get_features_for_blocking" title="py_entitymatching.get_features_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_blocking()</span></code></a> for more details.</p>
</div>
</div>
<span id="document-user_manual/debugging_blocking"></span><div class="section" id="debugging-blocking">
<h3>Debugging Blocking<a class="headerlink" href="#debugging-blocking" title="Permalink to this headline">¶</a></h3>
<p>In a typical entity matching workflow, you will load in the two tables to
match, sample them (if required) and use a blocker to remove obvious non-matches.
But it is often not clear whether the blocker drops only non-matches or it
also removes a lot of potential matches.</p>
<p>In such cases, it is important to debug the output of blocker. In
py_entitymatching, <cite>debug_blocker</cite> command can be used for that purpose.</p>
<p>The <cite>debug_blocker</cite> command takes in two input tables A, B, blocker output C
and returns a table D containing a set of tuple pairs that are
potential matches and yet are not present in the blocker output
C. Table D also contains similarity measure computed for each reported
tuple pair (as its second column).</p>
<p>You can examine these potential matches in table D. If you
find that many of them are indeed true matches, then that means the
blocker may have removed too many true matches. In this case you
may want to <cite>relax</cite> the blocker by modifying its parameters, or
choose a different blocker. On the other hand, if you do not
find many true matches in table D, then it could be the case that the
blocker has done a good job and preserve all the matches (or most of
the matches) in the blocker output C.</p>
<p>In the <cite>debug_blocker</cite>, you can optionally specify attribute correspondences between
the input tables A and B. If it is not specified, then attribute correspondences
will be a list of attribute pairs with the exact same names in A and B.</p>
<p>The debugger will use only the attributes mentioned in these attribute
correspondences to try to find potentially matching pairs and place
those pairs into D. Thus, our recommendation is that (a) if the tables
have idential schemas or share a lot of attributes with the same
names, then do not specify the attribute correspondences, in this
case the debugger will use all the attributes with the same name between the two
schemas, (b) otherwise think about what attribute pairs you want to see the
debugger use, then specify those as attribute correspondences.</p>
<p>An example of using <cite>debug_blocker</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.debug_blocker" title="py_entitymatching.debug_blocker"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_blocker()</span></code></a>
for more details.</p>
<p>The blocker debugger is implemented in Cython. In case this version of the
command is not working properly, there is also a python version of the command,
called <cite>backup_debug_blocker</cite>, available that can be used instead. Please refer
to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.backup_debug_blocker" title="py_entitymatching.backup_debug_blocker"><code class="xref py py-meth docutils literal notranslate"><span class="pre">backup_debug_blocker()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/sampling"></span><div class="section" id="sampling">
<span id="label-sampling"></span><h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers or evaluate matchers, you need to
create labeled data. To create labeled data, first you need to sample of candidate set
pairs and then label them.</p>
<p>In <em>py_stringmatching</em>, you can use <cite>sample_table</cite> to get a sample. The command does
uniform random sampling without replacement. An example of using <cite>sample_table</cite> is shown
below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The command will first create a copy of the input table, sample the specified number of
tuple pairs from the copy, update the metadata and return the sampled table.</p>
<p>For more details, please look into the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.sample_table" title="py_entitymatching.sample_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sample_table()</span></code></a></p>
</div>
<span id="document-user_manual/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<p>The command <cite>label_table</cite> can be used to label the samples (see section
<a class="reference internal" href="singlepage.html#label-sampling"><span class="std std-ref">Sampling</span></a>). An example of using <cite>label_table</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first create a copy of the input table <cite>S</cite>, update
the metadata, add a column with the
specified column name (in <cite>label_col_name</cite> parameter) fill it with 0 (i.e non-matches)
and open a GUI for you to update the labels. You must specify 0 for non-matches and
1 for matches. Once you close the GUI, the updated table will be returned.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.label_table" title="py_entitymatching.label_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">label_table()</span></code></a>
for more details.</p>
</div>
<span id="document-user_manual/split_train_test"></span><div class="section" id="splitting-labeled-data-into-training-and-testing-sets">
<h3>Splitting Labeled Data into Training and Testing Sets<a class="headerlink" href="#splitting-labeled-data-into-training-and-testing-sets" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you will have to split data for
multiple purposes. Some examples are:</p>
<p>1. Split labeled data into development and test. Th development
set is used to come up with right features for learning-based matcher, and
<cite>test</cite> set is used to evaluate the matcher.</p>
<p>2. Split feature vectors into a train and test set. The train
set is used to train the learning-based matcher and test set is used
for evaluation.</p>
<p>py_entitymatching provides <cite>split_train_test</cite> command for the above need.
An example of using <cite>split_train_test</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>split_train_test</cite> returns a dictionary with two keys: train, and test.
The value for the key <cite>train</cite> is a Dataframe containing tuples
allocated from the input table based on train_proportion.
Similarly, the value for the key <cite>test</cite> is a Dataframe containing
tuples for evaluation. An example of getting train and test Dataframes from the output
of <cite>split_train_test</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">devel_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Setting the value for train proportion would depend on the
context of its use. For instance, if the data is split for machine learning
purposes then train proportion is typically larger than the
test.
The most commonly used values of train_proportion are between
0.5 and 0.8.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.split_train_test" title="py_entitymatching.split_train_test"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split_train_test()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/create_feats_for_matching"></span><div class="section" id="creating-features-for-matching">
<span id="label-create-feats-matching"></span><h3>Creating Features for Matching<a class="headerlink" href="#creating-features-for-matching" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers, then you cannot just operate on the
labeled set of tuple pairs. For each tuple in the labeled, you need to convert it
into a feature vector which consists of a list of numerical/categorical features. To do
this, first we need to create a set of features.</p>
<p>There are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically create a set of features (then the user can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<p>This is very similar to manual feature creation process for blocking (see section
<a class="reference internal" href="singlepage.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>) except the features are created for
matching purposes.
In brief, you can execute the following sequence of commands in py_entitymatching
to create the features manually:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Further, you can add or delete features as see saw in section
<a class="reference internal" href="singlepage.html#label-add-remove-features"><span class="std std-ref">Adding/Removing Features</span></a>.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_matching()</span></code></a>
and <a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a> for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching returns the same set of features for blocking and matching purposes.</p>
</div>
</div>
<div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>If you do not want to go through the hassle of creating the features manually, then
the user can generate the features automatically. This is very similar to automatic
feature creation process for blocking (see section <a class="reference internal" href="singlepage.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>).</p>
<p>In py_entitymatching, you can use <cite>get_features_for_matching</cite> to generate features
for matching purposes automatically. An example of using <cite>get_features_for_matching</cite> is
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to what we saw in section <a class="reference internal" href="singlepage.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a> for blocking, the
command will set the following variables: <cite>_match_t</cite>, <cite>_match_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, <cite>_match_c</cite>
and they can be accessed like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_c</span>
</pre></div>
</div>
<p>You can to examine these variables, modify them as appropriate, and then
perhaps regenerate a set of features.
Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.get_features_for_matching" title="py_entitymatching.get_features_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_matching()</span></code></a>
for more details.</p>
</div>
</div>
<span id="document-user_manual/extract_feat_vecs"></span><div class="section" id="extracting-feature-vectors">
<h3>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h3>
<p>Once you have created a set of features, you use them to convert labeled sample to feature
vectors. In py_entitymatching, you can use <cite>extract_feature_vecs</cite> to convert
labeled sample to feature vectors using the features created
(see section <a class="reference internal" href="singlepage.html#label-create-feats-matching"><span class="std std-ref">Creating Features for Matching</span></a>).</p>
<p>An example of using <cite>extract_feature_vecs</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes the labeled data (<cite>G</cite>), applies the feature functions (in <cite>match_f</cite>)
to each tuple in G to create a Dataframe, adds the <cite>attrs_before</cite> and <cite>attrs_after</cite>
columns, updates the metadata and returns the resulting Dataframe.</p>
<p>If there is one (or several columns) in labeled data that contains the labels, then those need
to be explicitly specified in <cite>attrs_after</cite>, if you want them them to copy over.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.extract_feature_vecs" title="py_entitymatching.extract_feature_vecs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_feature_vecs()</span></code></a>
for more details.</p>
</div>
<span id="document-user_manual/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h3>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h3>
<p>While doing supoervised learning-based matching, you would need to create labeled sample,
convert the sample into table of feature vectors, fill in the missing values, select
a machine learning (ML) model and use it to produce matches.</p>
<p>The step of filling in the missing values (also called imputing
missing values) is important and necessary. If there are missing values in the input
tables A and B, then they would be passed on to candidate set and most
likely to the feature vectors. In py_entitymatching, if the feature vectors
contain missing values, then most of the ML algorithms would not work
as they rely on scikit-learn package to provide ML-algorithm
implementations (and their implementations would not work if the
feature vectors contain NaN’s).</p>
<p>To avoid missing value problem in the feature vectors, you must impute the values
of the NaN’s. There are many different ways to impute missing values such as
filling the NaN’s (in the whole table or just some columns) with a constant value,
or fill the NaN’s with an aggregate value (mean, median, etc.).</p>
<p>Since the table is represented as a pandas Dataframe, there are two common ways to impute
missing values: (1) use <cite>fillna</cite> method from pandas Dataframe, and (2) impute missing
values using <cite>Imputer</cite> from Scikit-learn package.</p>
<p>But there are two problems that we have to tackle if we have to using the above commands
or objects directly:</p>
<ul class="simple">
<li><p>They are not metadata aware, so the user has to explicitly take care of it.</p></li>
<li><p>The Dataframe type that gets imputed typically contains attributes such as key, foreign
keys to A and B. The user must have to rightly project them out to impute missing
values using aggregates.</p></li>
</ul>
<p>In py_entitymatching, we propose a hybrid method to impute missing values. To fill NaN’s
with a constant value use <cite>fillna</cite> command from pandas Dataframe. Please look at the
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html">API reference of fillna</a>
for more details. An example of using <cite>fillna</cite> to the whole table is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>H</cite> is a Dataframe containing feature vectors, 0 is the constant value that
to be filled in, and <cite>inplace=True</cite> means that the updation should be done in place
(i.e., without creating a copy). It is important to set <cite>inplace=True</cite> as we do not want
the metadata for H in Catalog to be corrupted.</p>
<p>Another example of using <cite>fillna</cite> on a column is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, in the above <cite>inplace</cite> should be specified as False, this is because
the output is getting assigned to a column in the old Dataframe <cite>H</cite> and the metadata
of <cite>H</cite> does not get affected.</p>
<p>To fill NaN’s with an aggregate value, in py_entitymatching you can use <cite>impute_table</cite>
command. It is a wrapper around scikit-learn’s <cite>Imputer</cite> object (to make it metadata aware).
An example of using <cite>impute_table</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If all the values in a column or a row are NaN’s, then the above aggregation
strategy will not work (i.e. we cannot compute the mean and use it to fill the
missing values). In such cases, you need to specify a value in <cite>val_all_nans</cite>
parameter and the command will use this value to fill in all the missing values.</p>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.impute_table" title="py_entitymatching.impute_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">impute_table()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/matching"></span><div class="section" id="specifying-matchers-and-performing-matching">
<h3>Specifying Matchers and Performing Matching<a class="headerlink" href="#specifying-matchers-and-performing-matching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
<p>Once yor convert the labeled sample  into a table of feature vectors (and their
labels), the we can  can create and apply matchers to the feature vectors.
Currently py_entitymatching supports only ML-based matchers. Implementation wise,
a Matcher is defined as a Python class with certain methods (and some common
utility functions) and all concrete blockers inherit from this Matcher class and
override the methods. Specifically, each concrete matcher will implement at least
the following methods:</p>
<ul class="simple">
<li><p>fit (for training)</p></li>
<li><p>predict (for prediction)</p></li>
</ul>
<div class="section" id="creating-learning-based-matchers">
<h5>Creating Learning-Based Matchers<a class="headerlink" href="#creating-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>In py_entitymatching, there are seven concrete ML-matchers implemented: (1) naive bayes,
(2) logistic regression, (3) linear regression, (4) support vector machine, (5) decision
trees, (6) random forest, and (7) xgboost matcher.</p>
<p>These concrete matchers are just wrappers of scikit-learn matchers or that supports
scikit-learn wrappers (for eg., xgboost) and this is because
the fit/predict methods in scikit-learn are not metadata aware. The concrete matchers
make the scikit-learn matchers metadata aware.</p>
<p>Each matcher can be created by calling its constructor. Since these matchers are
just the wrappers of scikit-learn matchers, the parameters that can be given to
scikit-learn matchers can be to given to the matchers in py_entitymatching.
For example, a user can create a Decision Tree matcher like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to <a class="reference internal" href="singlepage.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DTMatcher()</span></code></a>, <a class="reference internal" href="singlepage.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RFMatcher()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.NBMatcher" title="py_entitymatching.NBMatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">NBMatcher()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">LogisticRegressionMatcher()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">LinearRegressionMatcher()</span></code>, <a class="reference internal" href="singlepage.html#py_entitymatching.SVMMatcher" title="py_entitymatching.SVMMatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SVMMatcher()</span></code></a>, and
<a class="reference internal" href="singlepage.html#py_entitymatching.XGBoostMatcher" title="py_entitymatching.XGBoostMatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XGBoostMatcher()</span></code></a>
for more details.</p>
</div>
<div class="section" id="training-learning-based-matchers">
<h5>Training Learning-Based Matchers<a class="headerlink" href="#training-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is instantiated, you can train the matcher using the
<cite>fit</cite> command. An example of using the <cite>fit</cite> command for Decision Tree matcher
is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other variants of <cite>fit</cite> method. As an example, Please refer to
<a class="reference internal" href="singlepage.html#py_entitymatching.DTMatcher.fit" title="py_entitymatching.DTMatcher.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for more details.</p>
</div>
<div class="section" id="applying-learning-based-matchers">
<h5>Applying Learning-Based Matchers<a class="headerlink" href="#applying-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is trained, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command for Decision Tree matcher
is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">probs_attr</span><span class="o">=</span><span class="s1">&#39;proba&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="go">inplace=True)</span>
</pre></div>
</div>
<p>There are other variants of <cite>predict</cite> method. As an example, Please refer to
<a class="reference internal" href="singlepage.html#py_entitymatching.DTMatcher.predict" title="py_entitymatching.DTMatcher.predict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code></a> for more details.</p>
</div>
</div>
<div class="section" id="rule-based-matchers">
<h4>Rule-Based Matchers<a class="headerlink" href="#rule-based-matchers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for matching purposes) using the rule-based
matcher. If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a rule-based matcher and add rules.</p>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features for matching, you can create rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BooleanRuleMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be a match.</p>
<p>Rules can also be deleted once they have been added to the matcher:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules in a matcher can be found using the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-rule-based-matcher">
<h5>Applying Rule-Based Matcher<a class="headerlink" href="#applying-rule-based-matcher" title="Permalink to this headline">¶</a></h5>
<p>Once the rules are specified, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>predict</cite> method, please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/select_best_matcher"></span><div class="section" id="selecting-a-ml-matcher">
<h3>Selecting a ML-Matcher<a class="headerlink" href="#selecting-a-ml-matcher" title="Permalink to this headline">¶</a></h3>
<p>Once you have created different concrete ML matchers, then you have to choose one of
them for matching purposes. There are many different criteria by which one can
decide to choose a matcher such as <cite>akaike information criterion</cite>, <cite>bayesian information
criterion</cite>, <cite>k-fold cross validation</cite>, etc. Currently py_entitymatching supports
k-fold cross validation and other approaches are left for future work.</p>
<p>Conceptually, the command to select a matcher would take in the following inputs:</p>
<ul class="simple">
<li><p>List of ML matchers.</p></li>
<li><p>Training data (feature vector).</p></li>
<li><p>A column of labels that correspond to the feature vectors in the training data.</p></li>
<li><p>Number of folds.</p></li>
</ul>
<p>And it would produce the following output:</p>
<ul class="simple">
<li><p>Selected matcher.</p></li>
<li><p>Statistics such as mean accuracy of all input matchers.</p></li>
</ul>
<p>In py_entitymatching, <cite>select_matcher</cite> command addresses the above needs. An
example of using <cite>select_matcher</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above the output, <cite>result</cite> is a dictionary containing three keys: (1) selected_matcher,
(2) cv_stats, and (3) drill_down_cv_stats. <cite>selected_matcher</cite> is the selected ML-based matcher,
<cite>cv_stats</cite> is a Dataframe which includes the average cross validation scores for each matcher
and for each metric, and ‘drill_down_cv_stats’ is a dictionary where each key is a metric that
includes the cross validation statistics for each fold.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.select_matcher" title="py_entitymatching.select_matcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_matcher()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/debugging_matcher"></span><div class="section" id="debugging-ml-matchers">
<h3>Debugging ML-Matchers<a class="headerlink" href="#debugging-ml-matchers" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you would like to choose a matcher that produces the desired
precision, recall or F1 numbers. If a matcher does not produce the desired accuracy, then
you would like to debug the matcher. py_entitymatching supports two ways to
debug: (1) using the GUI, and (2) using the command line.</p>
<div class="section" id="debugging-using-the-gui">
<h4>Debugging Using the GUI<a class="headerlink" href="#debugging-using-the-gui" title="Permalink to this headline">¶</a></h4>
<p>py_entitymatching supports debugging using the GUI for a subset of ML-based matchers.
Specifically, it supports debugging Decision Tree matcher and Random Forest matcher.
You can use <cite>vis_debug_dt</cite> and <cite>vis_debug_rf</cite> to debug Decision Tree matcher
and Random Forest matcher respectively.</p>
<p>An example of using <cite>vis_debug_dt</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The command would display a GUI containing evaluation summary and an option to see tuples
flagged as <cite>false positives</cite> or <cite>false negatives</cite>. If you select <cite>false positives</cite>
then false positive tuple pairs would be displayed in the adjoining window. Similarly,
if <cite>false negatives</cite> is selected then false negative tuple pairs would be
displayed. By default, <cite>false positives</cite> is selected.
Each tuple pair is displayed with two buttons: <cite>show</cite> and <cite>debug</cite>. If you click on
<cite>show</cite>, then individual tuples (of that tuple pair) are displayed in a separate window.
If you click on <cite>debug</cite>, then a window with individual tuples and the
path taken by the feature vector in the Decision Tree that leads to the predicted value
is displayed.</p>
<p>The usage of <cite>vis_debug_rf</cite> is same as <cite>vis_debug_dt</cite>. The command would display a GUI
similar to <cite>vis_debug_dt</cite>, except the debug window would list a set of trees. You can
expand each tree to see the path taken by the features in that tree.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.vis_debug_dt" title="py_entitymatching.vis_debug_dt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_dt()</span></code></a> and
<a class="reference internal" href="singlepage.html#py_entitymatching.vis_debug_rf" title="py_entitymatching.vis_debug_rf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_rf()</span></code></a> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random Forest matcher using GUI,
then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>In the displayed GUI, check precision and recall numbers in evaluation summary.</p></li>
<li><p>If the user wants to improve precision, then he/she should choose to see false positives.</p></li>
<li><p>If the user wants to improve recall, then he/she should choose to see false negatives.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs,
you can click on the <cite>show</cite> button to see the tuples from the left and right tables.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs, you can choose a tuple
and click on the <cite>debug</cite> button to see the detailed evaluation path of that tuple.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are
cleaning  the input data, adding more features, adding more training data, trying a
different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="debugging-using-the-command-line">
<h4>Debugging Using the Command Line<a class="headerlink" href="#debugging-using-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>Similar to debugging using the GUI, py_entitymatching supports command line debugging for two
ML matchers: Decision Tree and Random Forest. Currently, py_entitymatching  supports
command line debugging only using tuple pairs, other approaches are left for future work.</p>
<p>You can use <cite>debug_decisiontree_matcher</cite> and <cite>debug_randomforest_matcher</cite> to debug
Decision Tree matcher and Random Forest matcher respectively.</p>
<p>An example of using <cite>debug_decisiontree_matcher</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, the debug command prints the path taken by the feature vector, its
evaluation status at each node and the actual feature value at each node.</p>
<p>The usage of <cite>debug_randomforest_matcher</cite> is same as <cite>debug_decisiontree_matcher</cite>.
Similar to <cite>debug_decisiontree_matcher</cite> command, it prints the path taken by the feature
vector, except that it displays the path taken in each tree of the Random Forest.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.debug_decisiontree_matcher" title="py_entitymatching.debug_decisiontree_matcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_decisiontree_matcher()</span></code></a>
and <a class="reference internal" href="singlepage.html#py_entitymatching.debug_randomforest_matcher" title="py_entitymatching.debug_randomforest_matcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_randomforest_matcher()</span></code></a> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random
Forest matcher using the command line, then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>Evaluate the accuracy of predictions using user created labels. The evaluation can
be done using <a class="reference internal" href="singlepage.html#py_entitymatching.eval_matches" title="py_entitymatching.eval_matches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code></a> command.</p></li>
<li><p>If you want to improve precision, then he/she should debug false positives.</p></li>
<li><p>If you want to improve recall, then he/she should debug false negatives.</p></li>
<li><p>You should then retrieve the tuples from the tuple id pairs listed in evaluation
summary, and debug using the commands described above.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are clean
the input data, add more features, add more training data, try different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="impact-of-imputing-missing-values">
<h4>Impact of Imputing Missing Values<a class="headerlink" href="#impact-of-imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<p>You should be aware of the following subtleties as it would
have an impact when he/she imputes values to feature vector set:</p>
<p>1. When you use the GUI for debugging, you would first choose to see
false positives/false negatives and then you would click the <cite>debug</cite> button to debug
that tuple pair. In this case, the feature vector in that row is given as input to find the path
traversed in the Decision Tree. If you had imputed the feature vector set to get
rid of NaN’s, then the imputed values would be considered to find the path traversed.</p>
<p>2. When you use the command line for debugging, then you would first evaluate the
predictions, select false positive or false negative tuple pairs to debug, retrieve the
tuples from the left and right tables and finally give them as input to command line
debugger commands. If you had imputed the feature vector set to get rid of NaN’s (using
a aggregate strategy), then imputed values would not be known to the debugger.</p>
<p>So if the input tables have NaN’s, then the output of the command line debugger would only
be partially correct (i.e., the displayed predicates would be correct, but the predicate
outcome may differ between current tuple pair and the actual feature vector used during
prediction).</p>
</div>
</div>
<span id="document-user_manual/matchercombiner"></span><div class="section" id="combining-predictions-from-multiple-matchers">
<h3>Combining Predictions from Multiple Matchers<a class="headerlink" href="#combining-predictions-from-multiple-matchers" title="Permalink to this headline">¶</a></h3>
<p>In the matching step, if you use multiple matchers then you will have to combine the
predictions from them to get a consolidated prediction. There are many different ways
to combine these predictions such as weighted vote, majority vote, stacking, etc.
Currently, py_entitymatching supports majority and weighted voting-based combining.
These combiners are experimental and not tested.</p>
<p>An example of using majority voting-based combining is shown below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv_combiner</span> <span class="o">=</span> <span class="n">MajorityVote</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;rf_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;nb_predictions&#39;</span><span class="p">]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions (from different matchers) the prediction that
occurs most is returned as the consolidated prediction. If there is no clear winning
prediction (for example, 0 and 1 occuring equal number of times) then 0 is returned.</p>
<p>An example of using weighted voting-based combining is shown below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wv_combiner</span> <span class="o">=</span> <span class="n">WeightedVote</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span>
<span class="go">&#39;rf_predictions&#39;, &#39;nb_predictions&#39;]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions, each prediction is given a
weight, we compute a weighted sum of these predictions and compare the result to a
threshold. If the result is greater than or equal to the threshold then the
consolidated prediction is returned as 1 (i.e., a match) else returned as 0 (no-match).</p>
</div>
<span id="document-user_manual/triggers"></span><div class="section" id="using-triggers-to-update-matching-results">
<h3>Using Triggers to Update Matching Results<a class="headerlink" href="#using-triggers-to-update-matching-results" title="Permalink to this headline">¶</a></h3>
<div class="section" id="match-triggers">
<h4>Match Triggers<a class="headerlink" href="#match-triggers" title="Permalink to this headline">¶</a></h4>
<p>Once you have used a matcher to predict results on a table, you might find
that there is some pattern of false positives or false negatives. Often, it
is useful to be able to create a set of rules to reevaluate tuple pair
predictions to correct these patterns of mistakes.</p>
<div class="section" id="creating-the-trigger">
<h5>Creating the Trigger<a class="headerlink" href="#creating-the-trigger" title="Permalink to this headline">¶</a></h5>
<p>Each trigger can be created by calling its constructor. For example, a user can
create a trigger like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
</pre></div>
</div>
<p>Please refer to <a class="reference internal" href="singlepage.html#py_entitymatching.MatchTrigger" title="py_entitymatching.MatchTrigger"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MatchTrigger()</span></code></a> for more details.</p>
<p>If you have already used a matcher, you should have already created a set of features
for matching. More information on this can be found in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a match trigger and add rules.</p>
</div>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features, you can create rules like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the result for the tuple pair will
be true.</p>
<p>You also need to add a condition status and action when using match triggers. If the
result is the same value as the condition status, then the action will be carried out.
For example, the action and condition status can be declared like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The condition status and action in the above example mean that if the rules in the
trigger return the value False, then the prediction will be changed to a 0.</p>
<p>Rules can also be deleted once they have been added:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules can be found using the following commands:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-the-triggers">
<h5>Executing the Triggers<a class="headerlink" href="#executing-the-triggers" title="Permalink to this headline">¶</a></h5>
<p>Once the rules, condition status, and action have been specified, the trigger can be
used to refine the predictions. An example of using the execute command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;prediction_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>execute</cite> method, please refer to
<a class="reference internal" href="singlepage.html#py_entitymatching.MatchTrigger.execute" title="py_entitymatching.MatchTrigger.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/evaluate_matching"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<p>Once you have predicted matches using ML-based matcher, then you would have to
evaluate the matches. py_entitymatching supports <cite>eval_matches</cite> command for that
purpose.</p>
<p>An example of using <cite>eval_matches</cite> command is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>eval_summary</cite> is a dictionary containing accuracy numbers (such as
precision, recall, F1, etc) and the list of false positives/negatives.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.eval_matches" title="py_entitymatching.eval_matches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code></a> for
more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/misc"></span><div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>This section covers some miscellaneous things in py_entitymatching.</p>
<div class="section" id="csv-format">
<span id="label-csv-format"></span><h3>CSV Format<a class="headerlink" href="#csv-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV format is selected because it’s well known and can be read by numerous external
programs. Further, it can be easily inspected and edited by the users.
You can read more about CSV formats <a class="reference external" href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.</p>
<p>There are two common CSV formats that are used to store CSV files: one with attribute
names in the first line, and one without. Both these formats are supported by py_entitymatching.</p>
<p>An example of a CSV file with attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
<p>An example of a CSV file with out attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-file-format">
<h3>Metadata File Format<a class="headerlink" href="#metadata-file-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV file can be accompanied with a metadata file containing the metadata information
of the table. Typically, it contains information such as key, foreign key, etc.
The metadata file is expected to be of the same name as the CSV file but with <cite>.metadata</cite>
extension. For example, if the CSV file <cite>table_A.csv</cite> contains table A’s data, then
<cite>table_A.metadata</cite> will contain table A’s metadata. So, the metadata is
associated based on the names of the files. The metadata file contains key-value pairs
one per line and each line starts with ‘#’.</p>
<p>An example of metadata file is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>In the above, the pair key=ID states that ID is the key attribute.</p>
</div>
<div class="section" id="writing-a-dataframe-to-disk-along-with-its-metadata">
<h3>Writing a Dataframe to Disk Along With Its Metadata<a class="headerlink" href="#writing-a-dataframe-to-disk-along-with-its-metadata" title="Permalink to this headline">¶</a></h3>
<p>To write a Dataframe to disk along with its metadata, you can use <cite>to_csv_metadata</cite>
command in py_entitymatching. An example of using <cite>to_csv_metadata</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./table_A.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first write Dataframe pointed by <cite>A</cite> to <cite>table_A.csv</cite> file in the
disk (in CSV format), next it will write the metadata of <cite>table A</cite> stored in the Catalog
to <cite>table_A.metadata</cite> file in the disk.</p>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.to_csv_metadata" title="py_entitymatching.to_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_csv_metadata()</span></code></a> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once the Dataframe is written to disk along with metadata, it can read using <a class="reference internal" href="singlepage.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a> command.</p>
</div>
</div>
<div class="section" id="writing-reading-other-types-of-py-entitymatching-objects">
<h3>Writing/Reading Other Types of py_entitymatching Objects<a class="headerlink" href="#writing-reading-other-types-of-py-entitymatching-objects" title="Permalink to this headline">¶</a></h3>
<p>After creating a blocker or feature table, it is desirable to have a
way to persist the objects to disk for future use. py_entitymatching provides
two commands for that purpose: <cite>save_object</cite> and <cite>load_object</cite>.</p>
<p>An example of using <cite>save_object</cite> is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">([</span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>load_object</cite> loads the stored object from disk. An example of using <cite>load_object</cite> is
shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="singlepage.html#py_entitymatching.save_object" title="py_entitymatching.save_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code></a> and
<a class="reference internal" href="singlepage.html#py_entitymatching.save_object" title="py_entitymatching.save_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code></a> for more details.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/overview"></span><div class="section" id="overview-of-command-organization">
<h2>Overview of Command Organization<a class="headerlink" href="#overview-of-command-organization" title="Permalink to this headline">¶</a></h2>
<p>The commands are organized into two parts. First, the commands that the user will typically use to
create an entity matching workflow. Second, a set of experimental commands that are expected to be
useful to create an entity matching workflow. Specifically, it includes commands  such
as  dask-based implementations for blockers and combining predictions from a set of matchers.
However, the experimental commands are not tested, so use these commands at your own risk.</p>
</div>
<span id="document-user_manual/api/actual_commands"></span><div class="section" id="commands-in-py-entitymatching">
<h2>Commands in py_entitymatching<a class="headerlink" href="#commands-in-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/reading_and_writing_data"></span><div class="section" id="reading-and-writing-data">
<h3>Reading and Writing Data<a class="headerlink" href="#reading-and-writing-data" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.read_csv_metadata">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">read_csv_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/parsers.html#read_csv_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.read_csv_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a CSV (comma-separated values) file into a pandas DataFrame
and update the catalog with the metadata. The CSV files typically contain
data for the input tables or a candidate set.</p>
<p>Specifically, this function first reads the CSV file from the given file
path into a pandas DataFrame, by using pandas’ in-built ‘read_csv’
method. Then, it updates the catalog with the metadata. There are three
ways to update the metadata: (1) using a metadata file, (2) using the
key-value parameters supplied in the function, and (3) using both
metadata file and key-value parameters.</p>
<p>To update the metadata in the catalog using the metadata file,
the function will look for a file in the same directory with  same file name
but with a  specific extension. This extension can be optionally given by
the user (defaults to ‘.metadata’). If the metadata  file is  present,
the function will read and update the catalog appropriately. If  the
metadata file is not present, the function will issue a warning that the
metadata file is not present.</p>
<p>The metadata information can also be given as parameters to the function
(see description of arguments for more details). If given, the function
will update the catalog with the given information.</p>
<p>Further, the metadata can partly reside in the metdata file and partly as
supplied parameters. The function will take a union of the two and
update the catalog appropriately.
If the same metadata is given in both the metadata file
and the function, then the metadata in the function takes precedence over
the metadata given in the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<em>string</em>) – The CSV file path</p></li>
<li><p><strong>kwargs</strong> (<em>dictionary</em>) – A Python dictionary containing key-value arguments.
There are a few key-value pairs that are specific to
read_csv_metadata and  all the other key-value pairs are passed
to pandas read_csv method</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame read from the input CSV file.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If a file does not exist in the
    given <cite>file_path</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><em>Example 1:</em> Read from CSV file and set metadata</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # &#39;id&#39;</span>
</pre></div>
</div>
<p><em>Example 2:</em>  Read from CSV file (with metadata file in the same directory</p>
<blockquote>
<div><p>Let the metadata file contain the following contents:</p>
<blockquote>
<div><p>#key = id</p>
</div></blockquote>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.to_csv_metadata" title="py_entitymatching.to_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_csv_metadata()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.to_csv_metadata">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">to_csv_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/parsers.html#to_csv_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.to_csv_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the DataFrame contents to a CSV file and the DataFrame’s metadata
(to a separate text file).</p>
<p>This function writes the DataFrame contents to a CSV file in
the given file path. It uses ‘to_csv’ method from pandas to write
the CSV file. The metadata contents are written to the same directory
derived from the file path but with the different extension. This
extension can be optionally given by the user (with the default value
set to .metadata).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be written to disk.</p></li>
<li><p><strong>file_path</strong> (<em>string</em>) – The file path to which the DataFrame contents
should be written. Metadata is written with the same file name
with the extension given by the user (defaults to ‘.metadata’).</p></li>
<li><p><strong>kwargs</strong> (<em>dictionary</em>) – A Python dictionary containing key-value pairs.
There is one key-value pair that is specific to
to_csv_metadata: metadata_extn. All the other key-value pairs
are passed to pandas to_csv function.
Here the metadata_extn is the metadata
extension (defaults to ‘.metadata’), with which
the metadata file must be written.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the files were written
successfully.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type  pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If DataFrame cannot be written to the given
    <cite>file_path</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/loading_and_saving_objects"></span><div class="section" id="loading-and-saving-objects">
<h3>Loading and Saving Objects<a class="headerlink" href="#loading-and-saving-objects" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.load_table">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">load_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">metadata_ext</span><span class="o">=</span><span class="default_value">'.pklmetadata'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/pickles.html#load_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.load_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a pickled DataFrame from a file along with its metadata.</p>
<p>This function loads a DataFrame from a file stored in pickle format.</p>
<p>Further, this function looks for a metadata file with the same file name
but with an extension given by the user (defaults to ‘.pklmetadata’. If the
metadata file is present, the function will update the metadata for that
DataFrame in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<em>string</em>) – The file path to load the file from.</p></li>
<li><p><strong>metadata_ext</strong> (<em>string</em>) – The metadata file extension (defaults to
‘.pklmetadata’) that should be used to generate metadata file name.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If the loading is successful, the function will return a pandas
DataFrame read from the file. The catalog will be updated with the
metadata read from the metadata file (if the file was present).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>metadata_ext</cite> is not of type string.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_table</span><span class="p">(</span><span class="s1">&#39;./A.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_table</span><span class="p">(</span><span class="s1">&#39;./A.pkl&#39;</span><span class="p">,</span> <span class="n">metadata_ext</span><span class="o">=</span><span class="s1">&#39;.pklmeta&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.save_table" title="py_entitymatching.save_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save_table()</span></code></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is different from read_csv_metadata in two aspects.
First, this function currently does not support reading in candidate
set tables, where there are more metadata such as ltable,
rtable than just ‘key’, and conceptually the user is expected to
provide ltable and rtable information while calling this function. (
this support will be added shortly). Second, this function loads the
table stored in a pickle format.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.save_table">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">save_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">metadata_ext</span><span class="o">=</span><span class="default_value">'.pklmetadata'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/pickles.html#save_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.save_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a DataFrame to disk along with its metadata in a pickle format.</p>
<p>This function saves a  DataFrame to disk along with its metadata from
the catalog.</p>
<p>Specifically, this function saves the DataFrame in the given
file path, and saves the metadata in the same directory (as the
file path) but with a different extension. This extension can be
optionally given by the user (defaults to ‘.pklmetadata’).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be saved.</p></li>
<li><p><strong>file_path</strong> (<em>string</em>) – The file path where the DataFrame must be stored.</p></li>
<li><p><strong>metadata_ext</strong> (<em>string</em>) – The metadata extension that should be used while
storing the metadata information. The default value is
‘.pklmetadata’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the DataFrame is successfully
saved.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>metadata_ext</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If a file cannot written in the given <cite>file_path</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_table</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./A.pkl&#39;</span><span class="p">)</span> <span class="c1"># will store two files ./A.pkl and ./A.pklmetadata</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_table</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./A.pkl&#39;</span><span class="p">,</span> <span class="n">metadata_ext</span><span class="o">=</span><span class="s1">&#39;.pklmeta&#39;</span><span class="p">)</span> <span class="c1"># will store two files ./A.pkl and ./A.pklmeta</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.load_table" title="py_entitymatching.load_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_table()</span></code></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is a bit different from to_csv_metadata, where the
DataFrame is stored in a CSV file format. The CSV file format can be
viewed using a text editor. But a DataFrame stored using ‘save_table’ is
stored in a special format, which cannot be viewed with a text editor.
The reason we have save_table is, for larger DataFrames it is
efficient to pickle the DataFrame to disk than writing the DataFrame
in CSV format.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.load_object">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">load_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/pickles.html#load_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.load_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a Python object from disk.</p>
<p>This function loads py_entitymatching objects from disk such as
blockers, matchers, feature table, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_path</strong> (<em>string</em>) – The file path to load the object from.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python object read from the file path.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If a file does not exist at the given <cite>file_path</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.save_object" title="py_entitymatching.save_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.save_object">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">save_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">object_to_save</span></em>, <em class="sig-param"><span class="n">file_path</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/io/pickles.html#save_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.save_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a Python object to disk.</p>
<p>This function is intended to be used to save py_entitymatching objects such as
rule-based blocker, feature vectors, etc. A user would like to store
py_entitymatching objects to disk, when he/she wants to save the workflow and
resume it later. This function provides a way to save the required
objects to disk.</p>
<p>This function takes in the object to save the file path. It pickles the object and
stores it in the file path specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>object_to_save</strong> (<em>Python object</em>) – The Python object to save. This can be
a rule-based blocker, feature vectors, etc.</p></li>
<li><p><strong>file_path</strong> (<em>string</em>) – The file path where the object must be saved.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned, if the saving was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>file_path</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If a file cannot be written in the given <cite>file_path</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasebBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;colA_colA_lev_dist(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.load_object" title="py_entitymatching.load_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_object()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/handling_metadata"></span><div class="section" id="handling-metadata">
<span id="label-handling-metadata"></span><h3>Handling Metadata<a class="headerlink" href="#handling-metadata" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.get_catalog">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_catalog</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_catalog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the catalog information for the current session.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>A Python dictionary containing the catalog information.</p>
<p>Specifically, the dictionary contains the Python identifier of a
DataFrame (obtained by id(DataFrame object)) as the key
and their properties as value.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">catalog</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_catalog</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_catalog_len">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_catalog_len</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_catalog_len"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_catalog_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the length (i.e the number of entries) in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of entries in the catalog as an integer.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_catalog_len</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.del_catalog">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">del_catalog</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#del_catalog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.del_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the catalog for the current session.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Boolean value of True is returned if the deletion was successful.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">del_catalog</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.is_catalog_empty">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">is_catalog_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#is_catalog_empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.is_catalog_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the catalog is empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Boolean value of True is returned if the catalog is empty,
else returns False.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_catalog_empty</span><span class="p">()</span>
<span class="go"> # False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.is_dfinfo_present">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">is_dfinfo_present</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#is_dfinfo_present"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.is_dfinfo_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the DataFrame information is present in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be checked for its
presence in the catalog.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the DataFrame is present in
the catalog, else False is returned.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas
    DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_dfinfo_present</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.is_property_present_for_df">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">is_property_present_for_df</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">property_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#is_property_present_for_df"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.is_property_present_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given property is present for the given DataFrame in the
catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property must be
checked for.</p></li>
<li><p><strong>property_name</strong> (<em>string</em>) – The name of the property that should be</p></li>
<li><p><strong>for its presence for the DataFrame</strong> (<em>checked</em>) – </p></li>
<li><p><strong>the catalog.</strong> (<em>in</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the property is present for
the given DataFrame.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>property_name</cite> is not of type string.</p></li>
<li><p><strong>KeyError</strong> – If <cite>data_frame</cite> is not present in the catalog.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="go"> # True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;fk_ltable&#39;</span><span class="p">)</span>
<span class="go"> # False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.show_properties">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">show_properties</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#show_properties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.show_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the properties for a DataFrame that is present in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input pandas DataFrame for which the
properties must be displayed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key_attr&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key_attr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_properties</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># id: 4572922488  # This will change dynamically</span>
<span class="go"># key: key_attr</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.show_properties_for_id">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">show_properties_for_id</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">object_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#show_properties_for_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.show_properties_for_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Shows the properties for an object id present in the catalog.</p>
<p>Specifically, given an object id got from typically executing id(
&lt;object&gt;), where the object could be a DataFrame, this function will
display the properties present for that object id in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>object_id</strong> (<em>int</em>) – The Python identifier of an object (typically a
pandas DataFrame).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key_attr&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key_attr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_properties_for_id</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go"># id: 4572922488  # This will change dynamically</span>
<span class="go"># key: key_attr</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_property">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">property_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the value of a property (with the given property name) for a pandas
DataFrame from the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property should be
retrieved.</p></li>
<li><p><strong>property_name</strong> (<em>string</em>) – The name of the property that should be
retrieved.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python object (typically a string or a pandas DataFrame depending
on the property name) is returned.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>property_name</cite> is not of type string.</p></li>
<li><p><strong>KeyError</strong> – If <cite>data_frame</cite> information is not present in the catalog.</p></li>
<li><p><strong>KeyError</strong> – If requested property for the <cite>data_frame</cite> is not present
    in the catalog.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"> # id</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_property">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">property_name</span></em>, <em class="sig-param"><span class="n">property_value</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of a property (with the given property name) for a pandas
DataFrame in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property must  be
set.</p></li>
<li><p><strong>property_name</strong> (<em>string</em>) – The name of the property to be set.</p></li>
<li><p><strong>property_value</strong> (<em>object</em>) – The value of the property to be set. This is
typically a string (such as key) or pandas DataFrame (such as
ltable, rtable).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the update was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>property_name</cite> is not of type string.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"> # id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # id</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the input DataFrame is not present in the catalog, this function
will create an entry in the catalog and set the given property.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.del_property">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">del_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">property_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#del_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.del_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a property for a pandas DataFrame from the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which a property must be
deleted from the catalog.</p></li>
<li><p><strong>property_name</strong> (<em>string</em>) – The name of the property that should be deleted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the deletion was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>property_name</cite> is not of type string.</p></li>
<li><p><strong>KeyError</strong> – If <cite>data_frame</cite> information is not present in the catalog.</p></li>
<li><p><strong>KeyError</strong> – If requested property for the DataFrame is not present
    in the catalog.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"># id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">del_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"># False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.copy_properties">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">copy_properties</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_data_frame</span></em>, <em class="sig-param"><span class="n">target_data_frame</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#copy_properties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.copy_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies properties from a source DataFrame to target DataFrame in the
catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_data_frame</strong> (<em>DataFrame</em>) – The DataFrame from which the properties
to be copied from, in the catalog.</p></li>
<li><p><strong>target_data_frame</strong> (<em>DataFrame</em>) – The DataFrame to which the properties
to be copied to, in the catalog.</p></li>
<li><p><strong>replace</strong> (<em>boolean</em>) – A flag to indicate whether the source
DataFrame’s  properties can replace the target
DataFrame’s properties in the catalog. The default value for the
flag is True.
Specifically, if the target DataFrame’s information is already
present in the catalog then the function will check if the
replace flag is True. If the flag is set to True, then the
function will first delete the existing properties and then set
it with the source DataFrame properties.
If the flag is False, the function will just return without
modifying the existing properties.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the copying was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>source_data_frame</cite> is not of
    type pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>target_data_frame</cite> is not of
    type pandas DataFrame.</p></li>
<li><p><strong>KeyError</strong> – If source DataFrame is not present in the
    catalog.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">copy_properties</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_key">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the value of ‘key’ property for a DataFrame from the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the key must be
retrieved from the catalog.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A string value containing the key column name is returned (if present).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_key">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">key_attribute</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of ‘key’ property for a DataFrame in the catalog with the
given attribute (i.e column name).</p>
<p>Specifically, this function set the the key attribute for the DataFrame
if the given attribute satisfies the following two properties:</p>
<blockquote>
<div><p>The key attribute should have unique values.</p>
<p>The key attribute should not have missing values. A missing value
is represented as np.NaN.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the key must be set in
the catalog.</p></li>
<li><p><strong>key_attribute</strong> (<em>string</em>) – The key attribute (column name) in the
DataFrame.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned, if the given attribute
satisfies the conditions for a key and the update was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>key_attribute</cite> is not of type string.</p></li>
<li><p><strong>KeyError</strong> – If given <cite>key_attribute</cite> is not in the DataFrame columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_fk_ltable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_fk_ltable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_fk_ltable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_fk_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the foreign key to left table for a DataFrame from the
catalog.</p>
<p>Specifically this function is a sugar function that will get the foreign
key to left table using underlying <a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a> function.
This function is typically called on a DataFrame which contains metadata
such as fk_ltable, fk_rtable, ltable, rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
ltable property must be retrieved.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python object, typically a string is returned.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;ltable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_fk_ltable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_fk_ltable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">fk_ltable</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_fk_ltable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_fk_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the foreign key to ltable for a DataFrame in the catalog.</p>
<p>Specifically this function is a sugar function that will set the foreign
key to the left table using <a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.set_property()</span></code></a> function. This
function is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
ltable property must be set.</p></li>
<li><p><strong>fk_ltable</strong> (<em>string</em>) – The attribute that must ne set as the foreign key
to the ltable in the catalog.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the foreign key to ltable was
set successfully.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>fk_ltable</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>fk_ltable</cite> is not in the input
    DataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;ltable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_fk_rtable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_fk_rtable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_fk_rtable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_fk_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the foreign key to right table for a DataFrame from the catalog.</p>
<p>Specifically this function is a sugar function that will get the foreign
key to right table using <a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_property()</span></code></a> function. This
function is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
rtable property must be retrieved.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python object, (typically a string) is returned.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;rtable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_fk_rtable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_fk_rtable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">foreign_key_rtable</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_fk_rtable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_fk_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the foreign key to rtable for a DataFrame in the catalog.</p>
<p>Specifically this function is a sugar function that will set the foreign
key to right table using set_property function. This function
is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
rtable property must be set.</p></li>
<li><p><strong>foreign_key_rtable</strong> (<em>string</em>) – The attribute that must be set as
foreign key to rtable in the catalog.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A Boolean value of True is returned if the foreign key to rtable was</dt><dd><p>set successfully.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>foreign_key_rtable</cite> is not of
    type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>fk_rtable</cite> is not in the input
    DataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;rtable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_ltable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_ltable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_ltable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the ltable for a DataFrame from the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the ltable must be
returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame that is pointed by ‘ltable’ property of the input
table.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_ltable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_ltable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_ltable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">table</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_ltable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the ltable for a DataFrame in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the ltable must be set.</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The table (typically a pandas DataFrame) that must
be set as ltable for the input DataFrame.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned, if the update was successful.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_ltable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_rtable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_rtable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#get_rtable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rtable for a DataFrame from the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>candset</strong> (<em>DataFrame</em>) – Input table for which the rtable must be returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame that is pointed by ‘rtable’ property of the input
table.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_rtable</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.set_rtable">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">set_rtable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">table</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/catalog/catalog_manager.html#set_rtable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.set_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rtable for a DataFrame in the catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the rtable must be set.</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The table that must be set as rtable for the input
DataFrame.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned, if the update was successful.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_rtable</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/downsampling"></span><div class="section" id="downsampling">
<h3>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.down_sample">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">down_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table_a</span></em>, <em class="sig-param"><span class="n">table_b</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">y_param</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rem_puncs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/sampler/down_sample.html#down_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.down_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>This function down samples two tables A and B into smaller tables A’ and
B’ respectively.</p>
<p>Specifically, first it randomly selects <cite>size</cite> tuples
from the table B to be table B’. Next, it builds an inverted index I
(token, tuple_id) on table A. For each tuple x ∈ B’, the algorithm
finds a set P of k/2 tuples from I that match x,
and a set Q of k/2 tuples randomly selected from A - P.
The idea is for A’ and B’ to share some matches yet be
as representative of A and B as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table_a</strong> (<em>DataFrame</em>) – The input tables A and B.</p></li>
<li><p><strong>table_b</strong> (<em>DataFrame</em>) – The input tables A and B.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size that table B should be down sampled to.</p></li>
<li><p><strong>y_param</strong> (<em>int</em>) – The parameter to control the down sample size of table A.
Specifically, the down sampled size of table A should be close to
size * y_param.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether a progress bar
should be displayed (defaults to True).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – The seed for the pseudo random number generator to select
the tuples from A and B (defaults to None).</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether a default set of stop words
must be removed.</p></li>
<li><p><strong>rem_puncs</strong> (<em>boolean</em>) – A flag to indicate whether the punctuations must be
removed from the strings.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Down sampled tables A and B as pandas DataFrames.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If any of the input tables (<cite>table_a</cite>, <cite>table_b</cite>) are
    empty or not a DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>size</cite> or <cite>y_param</cite> is empty or 0 or not a
    valid integer value.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>seed</cite> is not a valid integer
    value.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type bool.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type bool.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type int.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p># Example with seed = 0. This means the same sample data set will be returned
# each time this function is run.
&gt;&gt;&gt; A = em.read_csv_metadata(‘path_to_csv_dir/table_A.csv’, key=’ID’)
&gt;&gt;&gt; B = em.read_csv_metadata(‘path_to_csv_dir/table_B.csv’, key=’ID’)
&gt;&gt;&gt; sample_A, sample_B = em.down_sample(A, B, 500, 1, seed=0, n_jobs=-1)</p>
</dd></dl>

</div>
<span id="document-user_manual/api/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="py_entitymatching.data_explore_openrefine">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">data_explore_openrefine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">server</span><span class="o">=</span><span class="default_value">'http://127.0.0.1:3333'</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/explorer/openrefine/openrefine_wrapper.html#data_explore_openrefine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.data_explore_openrefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for using OpenRefine. Gives user a GUI to examine and edit
the dataframe passed in using OpenRefine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>Dataframe</em>) – The pandas dataframe to be explored with pandastable.</p></li>
<li><p><strong>server</strong> (<em>String</em>) – The address of the OpenRefine server (defaults to
<a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a>).</p></li>
<li><p><strong>name</strong> (<em>String</em>) – The name given to the file and project in OpenRefine.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If <cite>df</cite> is not of type pandas DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.data_explore_pandastable">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">data_explore_pandastable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/explorer/pandastable/pandastable_wrapper.html#data_explore_pandastable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.data_explore_pandastable" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for pandastable. Gives user a GUI to examine and edit
the dataframe passed in using pandastable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>df</strong> (<em>Dataframe</em>) – The pandas dataframe to be explored with pandastable.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If <cite>df</cite> is not of type pandas DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/blocking"></span><div class="section" id="blocking">
<h3>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="py_entitymatching.AttrEquivalenceBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">AttrEquivalenceBlocker</code><a class="reference internal" href="_modules/py_entitymatching/blocker/attr_equiv_blocker.html#AttrEquivalenceBlocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on the equivalence of attribute values.</p>
<dl class="py method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/attr_equiv_blocker.html#AttrEquivalenceBlocker.block_candset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on attribute equivalence.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs
such that the value of attribute l_block_attr of the left tuple in a
tuple pair exactly matches the value of attribute r_block_attr of the
right tuple in the tuple pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/attr_equiv_blocker.html#AttrEquivalenceBlocker.block_tables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on attribute equivalence.</p>
<p>Conceptually, this will check <cite>l_block_attr=r_block_attr</cite> for each tuple
pair from the Cartesian product of tables <cite>ltable</cite> and <cite>rtable</cite>. It outputs a
Pandas dataframe object with tuple pairs that satisfy the equality condition.
The dataframe will include attributes ‘_id’, key attribute from
ltable, key attributes from rtable, followed by lists <cite>l_output_attrs</cite> and
<cite>r_output_attrs</cite> if they are specified. Each of these output and key attributes will be
prefixed with given <cite>l_output_prefix</cite> and <cite>r_output_prefix</cite>. If <cite>allow_missing</cite> is set
to <cite>True</cite> then all tuple pairs with missing value in at least one of the tuples will be
included in the output dataframe.
Further, this will update the following metadata in the catalog for the output table:
(1) key, (2) ltable, (3) rtable, (4) fk_ltable, and (5) fk_rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/attr_equiv_blocker.html#AttrEquivalenceBlocker.block_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on attribute equivalence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left tuple.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right tuple.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked, i.e., the values
of l_block_attr in ltuple and r_block_attr in rtuple are different
(boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.OverlapBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">OverlapBlocker</code><a class="reference internal" href="_modules/py_entitymatching/blocker/overlap_blocker.html#OverlapBlocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.OverlapBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on the overlap of token sets of attribute values.</p>
<dl class="py method">
<dt id="py_entitymatching.OverlapBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/overlap_blocker.html#OverlapBlocker.block_candset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks an input candidate set of tuple pairs based on the overlap</dt><dd><p>of token sets of attribute values.</p>
</dd>
</dl>
<p>Finds tuple pairs from an input candidate set of tuple pairs such that
the overlap between (a) the set of tokens obtained by tokenizing the
value of attribute l_overlap_attr of the left tuple in a tuple pair,
and (b) the set of tokens obtained by tokenizing the value of
attribute r_overlap_attr of the right tuple in the tuple pair,
is above a certain threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – <p>A flag to indicate whether the debug information</p>
<p>should be logged (defaults to False).</p>
</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.OverlapBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/overlap_blocker.html#OverlapBlocker.block_tables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks two tables based on the overlap of token sets of attribute</dt><dd><p>values.</p>
</dd>
</dl>
<p>Finds tuple pairs from left and right tables such that the overlap
between (a) the set of tokens obtained by tokenizing the value of
attribute l_overlap_attr of a tuple from the left table, and (b) the
set of tokens obtained by tokenizing the value of attribute
r_overlap_attr of a tuple from the right table, is above a certain
threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed from the token sets of the
overlap attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes
values are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words (i.e, using whitespace
as delimiter) (defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must
overlap (defaults to 1).</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the output candidate set (defaults
to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the output candidate set  (defaults
to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="go"># Use word-level tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go"># Include all possible missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Use all the cores in the machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.OverlapBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/overlap_blocker.html#OverlapBlocker.block_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks a tuple pair based on the overlap of token sets of attribute</dt><dd><p>values.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left tuple.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right tuple.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – A value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.RuleBasedBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">RuleBasedBlocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on a sequence of blocking rules supplied by the user.</p>
<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.add_rule">
<code class="sig-name descname">add_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conjunct_list</span></em>, <em class="sig-param"><span class="n">feature_table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rule_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.add_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.add_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</p></li>
<li><p><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The name of the rule added (string).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>rule_name</cite> already exists.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is not a valid value
    parameter.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.block_candset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a sequence of
blocking rules supplied by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the sequence of blocking rules. A tuple pair survives the
sequence of blocking rules if none of the rules in the sequence returns
True for that pair. If any of the rules returns True, then the pair is
blocked (dropped).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is the candidate set.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.block_tables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on the sequence of rules supplied by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the sequence
of blocking rules. A tuple pair survives the sequence of blocking rules
if none of the rules in the sequence returns True for that pair. If any
of the rules returns True, then the pair is blocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived the sequence of
blocking rules (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.block_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a sequence of blocking rules supplied
by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked by applying the
sequence of blocking rules (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.delete_rule">
<code class="sig-name descname">delete_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.delete_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule">
<code class="sig-name descname">get_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.get_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function object corresponding to the specified rule.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule_names">
<code class="sig-name descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.get_rule_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of names of all the rules in the rule-based blocker (list).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.set_feature_table">
<code class="sig-name descname">set_feature_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_table</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.set_feature_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RuleBasedBlocker.view_rule">
<code class="sig-name descname">view_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/rule_based_blocker.html#RuleBasedBlocker.view_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.BlackBoxBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">BlackBoxBlocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/black_box_blocker.html#BlackBoxBlocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on a black box function specified by the user.</p>
<dl class="py method">
<dt id="py_entitymatching.BlackBoxBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/black_box_blocker.html#BlackBoxBlocker.block_candset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a black box
blocking function specified by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the black box function. A tuple pair survives the black box
blocking function if the function returns False for that pair,
otherwise the tuple pair is dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether logging should be done
(defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is an output from block_tables</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/black_box_blocker.html#BlackBoxBlocker.block_tables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on a black box blocking function specified
by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the black
box function. A tuple pair survives the black box blocking function if
the function returns False for that pair, otherwise the tuple pair is
dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/black_box_blocker.html#BlackBoxBlocker.block_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a black box blocking function specified
by the user.</p>
<p>Takes a tuple pair as input, applies the black box blocking function to
it, and returns True (if the intention is to drop the pair) or False
(if the intention is to keep the tuple pair).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair should be dropped or kept,
based on the black box blocking function (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># A, B are input tables.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.BlackBoxBlocker.set_black_box_function">
<code class="sig-name descname">set_black_box_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/black_box_blocker.html#BlackBoxBlocker.set_black_box_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.set_black_box_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets black box function to be used for blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<em>function</em>) – the black box function to be used for blocking .</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.SortedNeighborhoodBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">SortedNeighborhoodBlocker</code><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: THIS IS AN EXPERIMENTAL CLASS. THIS CLASS IS NOT TESTED.
USE AT YOUR OWN RISK.</p>
<p>Blocks based on the sorted neighborhood blocking method</p>
<dl class="py method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_candset">
<em class="property">static </em><code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker.block_candset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>block_candset does not apply to sn_blocker, return unimplemented</p>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">window_size</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker.block_tables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: THIS IS AN EXPERIMENTAL COMMAND. THIS COMMAND IS NOT TESTED.
USE AT YOUR OWN RISK.</p>
<p>Blocks two tables based on sorted neighborhood.</p>
<p>Finds tuple pairs from left and right tables such that when each table
is sorted based upon a blocking attribute, tuple pairs are within a
distance w of each other. The blocking attribute is created prior to calling
this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute for left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute for right table.</p></li>
<li><p><strong>window_size</strong> (<em>int</em>) – size of sliding window. Defaults to 2</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>window_size</cite> is not of type of
    int or if window_size &lt; 2.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_tuples">
<em class="property">static </em><code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker.block_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>block_tuples does not apply to sn_blocker, return unimplemented</p>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.validate_block_attrs">
<em class="property">static </em><code class="sig-name descname">validate_block_attrs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker.validate_block_attrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.validate_block_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the blocking attributes</p>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.validate_types_block_attrs">
<em class="property">static </em><code class="sig-name descname">validate_types_block_attrs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blocker/sn_blocker.html#SortedNeighborhoodBlocker.validate_types_block_attrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.validate_types_block_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the data types of the blocking attributes</p>
</dd></dl>

</dd></dl>

</div>
<span id="document-user_manual/api/debugging_blocker_output"></span><div class="section" id="debugging-blocker-output">
<h3>Debugging Blocker Output<a class="headerlink" href="#debugging-blocker-output" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.debug_blocker">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">debug_blocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candidate_set</span></em>, <em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">attr_corres</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_configs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugblocker/debugblocker.html#debug_blocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.debug_blocker" title="Permalink to this definition">¶</a></dt>
<dd><p>This function debugs the blocker output and reports a list of potential
matches that are discarded by a blocker (or a blocker sequence).
Specifically,  this function takes in the two input tables for
matching and the candidate set returned by a blocker (or a blocker
sequence), and produces a list of tuple pairs which are rejected by the
blocker but with high potential of being true matches.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candidate_set</strong> (<em>DataFrame</em>) – The candidate set generated by
applying the blocker on the ltable and rtable.</p></li>
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The input DataFrames that are used to
generate the blocker output.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The input DataFrames that are used to
generate the blocker output.</p></li>
<li><p><strong>output_size</strong> (<em>int</em>) – The number of tuple pairs that will be
returned (defaults to 200).</p></li>
<li><p><strong>attr_corres</strong> (<em>list</em>) – A list of attribute correspondence tuples.
When ltable and rtable have different schemas, or the same
schema but different words describing the attributes, the
user needs to manually specify the attribute correspondence.
Each element in this list should be a tuple of strings
which are the corresponding attributes in ltable and rtable.
The default value is None, and if the user doesn’t specify
this list, a built-in function for finding the
attribute correspondence list will be called. But we highly
recommend the users manually specify the attribute
correspondences, unless the schemas of ltable and rtable are
identical (defaults to None).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
<li><p><strong>n_configs</strong> (<em>int</em>) – The maximum number of configs to be used for
calculating the topk list(defaults to 1). If -1, the config
number is set as the number of cpu. If -2, all configs are used.
if n_configs is less than the maximum number of generated configs,
then n_configs will be used. Otherwise, all the generated configs
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame with ‘output_size’ number of rows. Each row in the
DataFrame is a tuple pair which has potential of being a true
match, but is rejected by the blocker (meaning that the tuple
pair is in the Cartesian product of ltable and rtable subtracted
by the candidate set). The fields in the returned DataFrame are
from ltable and rtable, which are useful for determining similar
tuple pairs.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite>, <cite>rtable</cite> or <cite>candset</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> or <cite>rtable</cite> is empty (size of 0).</p></li>
<li><p><strong>AssertionError</strong> – If the output <cite>size</cite> parameter is less than or equal
    to 0.</p></li>
<li><p><strong>AssertionError</strong> – If the attribute correspondence (<cite>attr_corres</cite>) list is
    not in the correct format (a list of tuples).</p></li>
<li><p><strong>AssertionError</strong> – If the attribute correspondence (<cite>attr_corres</cite>)
    cannot be built correctly.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.backup_debug_blocker">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">backup_debug_blocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">output_size</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">attr_corres</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugblocker/backup_debugblocker.html#backup_debug_blocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.backup_debug_blocker" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the old version of the blocker debugger. It is not reccomended
to use this version unless the new blocker debugger is not working properly.</p>
<p>This function debugs the blocker output and reports a list of potential
matches that are discarded by a blocker (or a blocker sequence).</p>
<p>Specifically,  this function takes in the two input tables for
matching and the candidate set returned by a blocker (or a blocker
sequence), and produces a list of tuple pairs which are rejected by the
blocker but with high potential of being true matches.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The candidate set generated by
applying the blocker on the ltable and rtable.</p></li>
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The input DataFrames that are used to
generate the blocker output.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The input DataFrames that are used to
generate the blocker output.</p></li>
<li><p><strong>output_size</strong> (<em>int</em>) – The number of tuple pairs that will be
returned (defaults to 200).</p></li>
<li><p><strong>attr_corres</strong> (<em>list</em>) – A list of attribute correspondence tuples.
When ltable and rtable have different schemas, or the same
schema but different words describing the attributes, the
user needs to manually specify the attribute correspondence.
Each element in this list should be a tuple of strings
which are the corresponding attributes in ltable and rtable.
The default value is None, and if the user doesn’t specify
this list, a built-in function for finding the
attribute correspondence list will be called. But we highly
recommend the users manually specify the attribute
correspondences, unless the schemas of ltable and rtable are
identical (defaults to None).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame with ‘output_size’ number of rows. Each row in the
DataFrame is a tuple pair which has potential of being a true
match, but is rejected by the blocker (meaning that the tuple
pair is in the Cartesian product of ltable and rtable subtracted
by the candidate set). The fields in the returned DataFrame are
from ltable and rtable, which are useful for determining similar
tuple pairs.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite>, <cite>rtable</cite> or <cite>candset</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> or <cite>rtable</cite> is empty (size of 0).</p></li>
<li><p><strong>AssertionError</strong> – If the output <cite>size</cite> parameter is less than or equal
    to 0.</p></li>
<li><p><strong>AssertionError</strong> – If the attribute correspondence (<cite>attr_corres</cite>) list is
    not in the correct format (a list of tuples).</p></li>
<li><p><strong>AssertionError</strong> – If the attribute correspondence (<cite>attr_corres</cite>)
    cannot be built correctly.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">backup_debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">backup_debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/combining_blocker_outputs"></span><div class="section" id="combining-blocker-outputs">
<h3>Combining Blocker Outputs<a class="headerlink" href="#combining-blocker-outputs" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.combine_blocker_outputs_via_union">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">combine_blocker_outputs_via_union</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">blocker_output_list</span></em>, <em class="sig-param"><span class="n">l_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/blockercombiner/blockercombiner.html#combine_blocker_outputs_via_union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.combine_blocker_outputs_via_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines multiple blocker outputs by doing a union of their tuple pair
ids (foreign key ltable, foreign key rtable).</p>
<p>Specifically, this function takes in a list of DataFrames (candidate
sets, typically the
output from blockers) and returns a consolidated DataFrame. The output
DataFrame contains the union of tuple pair ids (foreign key ltable,
foreign key rtable) and other attributes from the input list of DataFrames.</p>
<p>This function makes some assumptions about the input DataFrames. First,
each DataFrame is expected to contain the following metadata in the
catalog: key, fk_ltable, fk_rtable, ltable, and rtable. Second,
all the DataFrames must be a result of blocking from the same underlying
tables. Concretely the ltable and rtable properties must refer to the
same DataFrame across all the input tables. Third, all the input
DataFrames must have the same fk_ltable and fk_rtable properties.
Finally, in each input DataFrame, for the attributes included from the
ltable or rtable, the attribute names must be prefixed with the given
l_prefix and r_prefix in the function.</p>
<p>The input DataFrames may contain different attribute lists and it demands
the question of how to combine them. Currently py_entitymatching takes an union
of attribute names that has prefix l_prefix or r_prefix across
input tables. After taking the union, for each tuple id pair included
in output, the attribute values (for union-ed attribute names) are
probed from ltable/rtable and included in the output.</p>
<p>A subtle point to note here is,  if an input DataFrame has a column
added by user (say label for some reason), then that column will not
be present in the output. The reason is, the same column may not be
present in other candidate sets so it is not clear about how to
combine them. One possibility is to include label in output for all
tuple id pairs, but set as NaN for the values not present. Currently
py_entitymatching does not include such columns and addressing it will be part
of future work.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blocker_output_list</strong> (<em>list of DataFrames</em>) – The list of DataFrames that
should be combined.</p></li>
<li><p><strong>l_prefix</strong> (<em>string</em>) – The prefix given to the attributes from the ltable.</p></li>
<li><p><strong>r_prefix</strong> (<em>string</em>) – The prefix given to the attributes from the rtable.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (default value is
False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new DataFrame with the combined tuple pairs and other attributes from
all the blocker lists.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>l_prefix</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_prefix</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If the length of the input DataFrame list is 0.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>blocker_output_list</cite> is not a list of
    DataFrames.</p></li>
<li><p><strong>AssertionError</strong> – If the ltables are different across the input list of
    DataFrames.</p></li>
<li><p><strong>AssertionError</strong> – If the rtables are different across the input list of
    DataFrames.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>fk_ltable</cite> values are different across the
    input list of DataFrames.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>fk_rtable</cite> values are different across the
    input list of DataFrames.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/sampling"></span><div class="section" id="sampling">
<h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.sample_table">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">sample_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="n">sample_size</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/sampler/single_table.html#sample_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.sample_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a candidate set of tuple pairs (for labeling purposes).</p>
<p>This function samples a DataFrame, typically used for labeling
purposes. This function expects the input DataFrame containing the
metadata of a candidate set (such as key, fk_ltable, fk_rtable, ltable,
rtable). Specifically, this function creates a copy of the input
DataFrame, samples the data using uniform random sampling (uses ‘random’
function from numpy to sample) and returns the sampled DataFrame.
Further, also copies the properties from the input DataFrame to the output
DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input DataFrame to be sampled.
Specifically,
a DataFrame containing the metadata of a candidate set (such as
key, fk_ltable, fk_rtable, ltable, rtable) in the catalog.</p></li>
<li><p><strong>sample_size</strong> (<em>int</em>) – The number of samples to be picked from the input
DataFrame.</p></li>
<li><p><strong>replace</strong> (<em>boolean</em>) – A flag to indicate whether sampling should be
done with replacement or not (defaults to False).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (defaults to False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A new DataFrame with ‘sample_size’ number of rows.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>table</cite> is not of type pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If the size of <cite>table</cite> is 0.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>sample_size</cite> is greater than the input
    DataFrame size.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">450</span><span class="p">)</span> <span class="c1"># C is the candidate set to be sampled from.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As mentioned in the above description, the output DataFrame is
updated (in the catalog) with the properties from the input
DataFrame. A subtle point to note here is, when the replace flag is
set to True, then the output  DataFrame can contain duplicate keys.
In that case, this function  will not set the key and it is up to
the user to fix it after the function returns.</p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.label_table">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">label_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="n">label_column_name</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/labeler/labeler.html#label_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.label_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Label a pandas DataFrame (for supervised learning purposes).</p>
<p>This functions labels a DataFrame, typically used for supervised learning
purposes. This function expects the input DataFrame containing the metadata
of a candidate set (such as key, fk_ltable, fk_rtable, ltable, rtable).
This function creates a copy of the input DataFrame, adds label column
at the end of the DataFrame, fills the column values with 0, invokes a
GUI for the user to enter labels (0/1, 0: non-match, 1: match) and finally
returns the labeled DataFrame. Further, this function also copies the
properties from the input DataFrame to the output DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input DataFrame to be labeled.
Specifically,
a DataFrame containing the metadata of a candidate set (such as
key, fk_ltable, fk_rtable, ltable, rtable) in the catalog.</p></li>
<li><p><strong>label_column_name</strong> (<em>string</em>) – The column name to be given for the labels
entered by the user.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (default value is
False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new DataFrame with the labels entered by the user. Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>table</cite> is not of type pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>label_column_name</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>label_column_name</cite> is already present in the
    input table.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># S is the (sampled) table that has to be labeled.</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/handling_features"></span><div class="section" id="handling-features">
<h3>Handling Features<a class="headerlink" href="#handling-features" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/creating_the_features_automatically"></span><div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.get_features_for_blocking">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_features_for_blocking</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">validate_inferred_attr_types</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/autofeaturegen.html#get_features_for_blocking"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_features_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function automatically generates features that can be used for
blocking purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</p></li>
<li><p><strong>validate_inferred_attr_types</strong> (<em>boolean</em>) – A flag to indicate whether to
show the user the inferred attribute types and the features
chosen for those types.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing automatically generated features.</p>
<p>Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, and ‘is_auto_generated’.</p>
<p>Further, this function also sets the following global variables:
_block_t, _block_s, _atypes1, _atypes2, and _block_c.</p>
<p>The variable _block_t contains the tokenizers used and  _block_s
contains the similarity functions used for creating features.</p>
<p>The variables _atypes1, and  _atypes2 contain the attribute types for
ltable and rtable respectively. The variable _block_c contains the
attribute correspondences between the two input tables.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>validate_inferred_attr_types</cite> is not of type
    pandas DataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the output DataFrame, two
attributes demand some explanation: (1) function, and (2)
is_auto_generated. The function, points to the actual Python function
that implements the feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>
<a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_features_for_matching">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_features_for_matching</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">validate_inferred_attr_types</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/autofeaturegen.html#get_features_for_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_features_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function automatically generates features that can be used for
matching purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</p></li>
<li><p><strong>validate_inferred_attr_types</strong> (<em>boolean</em>) – A flag to indicate whether to
show the user the inferred attribute types and the features
chosen for those types.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing automatically generated features.</p>
<p>Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, and ‘is_auto_generated’.</p>
<p>Further, this function also sets the following global variables:
_match_t, _match_s, _atypes1, _atypes2, and _match_c.</p>
<p>The variable _match_t contains the tokenizers used and  _match_s
contains the similarity functions used for creating features.</p>
<p>The variables _atypes1, and  _atypes2 contain the attribute types for
ltable and rtable respectively. The variable _match_c contains the
attribute correspondences between the two input tables.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>validate_inferred_attr_types</cite> is not of type
    pandas DataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the output DataFrame, two
attributes demand some explanation: (1) function, and (2)
is_auto_generated. The function, points to the actual Python function
that implements the feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="singlepage.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>
<a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/creating_the_features_manually"></span><div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.get_features">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_features</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_attr_types</span></em>, <em class="sig-param"><span class="n">r_attr_types</span></em>, <em class="sig-param"><span class="n">attr_corres</span></em>, <em class="sig-param"><span class="n">tok_funcs</span></em>, <em class="sig-param"><span class="n">sim_funcs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/autofeaturegen.html#get_features"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_features" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will automatically generate a set of features based on the
attributes of the input tables.</p>
<p>Specifically, this function will go through the attribute
correspondences between the input tables. For each correspondence ,
it examines the types of the involved attributes, then apply the
appropriate tokenizers and sim functions to generate all appropriate
features for this correspondence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features must be generated.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features must be generated.</p></li>
<li><p><strong>l_attr_types</strong> (<em>dictionary</em>) – The attribute types for the
input DataFrames. Typically this is generated using the
function ‘get_attr_types’.</p></li>
<li><p><strong>r_attr_types</strong> (<em>dictionary</em>) – The attribute types for the
input DataFrames. Typically this is generated using the
function ‘get_attr_types’.</p></li>
<li><p><strong>attr_corres</strong> (<em>dictionary</em>) – The attribute correspondences between the
input DataFrames.</p></li>
<li><p><strong>tok_funcs</strong> (<em>dictionary</em>) – A Python dictionary containing tokenizer
functions.</p></li>
<li><p><strong>sim_funcs</strong> (<em>dictionary</em>) – A Python dictionary containing similarity
functions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas DataFrame containing automatically generated features.
Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, ‘is_auto_generated’.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_attr_types</cite> is not of type
    python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_attr_types</cite> is not of type
    python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>attr_corres</cite> is not of type
    python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>sim_funcs</cite> is not of type
    python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>tok_funcs</cite> is not of type
    python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>ltable</cite> and <cite>rtable</cite> order is same as mentioned
    in the <cite>l_attr_types</cite>/<cite>r_attr_types</cite> and <cite>attr_corres</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the output DataFrame, two
attributes demand some explanation: (1)function, and (2)
is_auto_generated. The function, points to the actual python function
that implements feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_attr_corres">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_attr_corres</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/attributeutils.html#get_attr_corres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_attr_corres" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the attribute correspondences between the attributes
of ltable and rtable.</p>
<p>The user may need to get the correspondences so
that he/she can generate features based those correspondences.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – Input DataFrames for which
the attribute correspondences must be obtained.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – Input DataFrames for which
the attribute correspondences must be obtained.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python dictionary is returned containing the attribute
correspondences.</p>
<p>Specifically, this returns a dictionary with the following key-value
pairs:</p>
<p>corres: points to the list correspondences as tuples. Each
correspondence is a tuple with two attributes: one from ltable
and the other from rtable.</p>
<p>ltable: points to ltable.</p>
<p>rtable: points to rtable.</p>
<p>Currently, ‘corres’ contains only pairs of attributes with exact
names in ltable and rtable.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type
    pandas DataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_attr_types">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_attr_types</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/attributeutils.html#get_attr_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_attr_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the attribute types for a DataFrame.</p>
<p>Specifically this function gets the attribute types based on the
statistics of the attributes. These attribute types can be str_eq_1w,
str_bt_1w_5w, str_bt_5w_10w, str_gt_10w, boolean or numeric.</p>
<p>The types roughly capture whether the attribute is of type string,
boolean or numeric. Further, with in the string type the subtypes are
capture the average number of tokens in the column values. For example,
str_bt_1w_5w means the average number of tokens in that column is
greater than one word but less than 5 words.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which types of
attributes must be determined.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python dictionary is returned containing the attribute types.</p>
<p>Specifically, in the dictionary key is an attribute name, value
is the type of that attribute.</p>
<p>Further, the dictionary will have a  key _table, and the value of
that should be a pointer to the input DataFrame.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type
    pandas DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_sim_funs_for_blocking">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_sim_funs_for_blocking</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#get_sim_funs_for_blocking"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_sim_funs_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the similarity functions that can be used for
blocking purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>A Python dictionary containing the similarity functions.</p>
<p>Specifically, the key is the similarity function name and the value
is the actual similary function.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_sim_funs_for_matching">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_sim_funs_for_matching</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#get_sim_funs_for_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_sim_funs_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the similarity functions that can be used for
matching purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>A Python dictionary containing the similarity functions.</p>
<p>Specifically, the key is the similarity function name and the value
is the actual similarity function.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_tokenizers_for_blocking">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_tokenizers_for_blocking</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">[2, 3]</span></em>, <em class="sig-param"><span class="n">dlm_char</span><span class="o">=</span><span class="default_value">[' ']</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#get_tokenizers_for_blocking"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_tokenizers_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the single argument tokenizers that can be used for
blocking purposes (typically in rule-based blocking).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>list</em>) – The list of integers (i.e q value) for which the q-gram
tokenizer must be generated (defaults to [2, 3]).</p></li>
<li><p><strong>dlm_char</strong> (<em>list</em>) – The list of characters (i.e delimiter character) for
which the delimiter tokenizer must be generated (defaults to [` ‘]).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python dictionary with tokenizer name as the key and tokenizer
function as the value.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If both <cite>q</cite> and <cite>dlm_char</cite> are set to None.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dlm_char</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dlm_char</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_tokenizers_for_matching">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_tokenizers_for_matching</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">[2, 3]</span></em>, <em class="sig-param"><span class="n">dlm_char</span><span class="o">=</span><span class="default_value">[' ']</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#get_tokenizers_for_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_tokenizers_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the single argument tokenizers that can be used for
matching purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>list</em>) – The list of integers (i.e q value) for which the q-gram
tokenizer must be generated (defaults to [2, 3]).</p></li>
<li><p><strong>dlm_char</strong> (<em>list</em>) – The list of characters (i.e delimiter character) for
which the delimiter tokenizer must be generated (defaults to [` ‘]).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python dictionary with tokenizer name as the key and tokenizer
function as the value.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If both <cite>q</cite> and <cite>dlm_char</cite> are set to None.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dlm_char</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dlm_char</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/adding_features"></span><div class="section" id="adding-features-to-feature-table">
<h4>Adding Features to Feature Table<a class="headerlink" href="#adding-features-to-feature-table" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.get_feature_fn">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_feature_fn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_string</span></em>, <em class="sig-param"><span class="n">tokenizers</span></em>, <em class="sig-param"><span class="n">similarity_functions</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/addfeatures.html#get_feature_fn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_feature_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a feature in a declarative manner.</p>
<p>Specifically, this function uses the feature string, parses it and
compiles it into a function using the given tokenizers and similarity
functions. This compiled function will take in two tuples and return a
feature value (typically a number).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_string</strong> (<em>string</em>) – A feature expression
to be converted into a function.</p></li>
<li><p><strong>tokenizers</strong> (<em>dictionary</em>) – A Python dictionary containing tokenizers.
Specifically, the dictionary contains tokenizer names as keys and
tokenizer functions as values. The tokenizer function typically
takes in a string and returns a list of tokens.</p></li>
<li><p><strong>similarity_functions</strong> (<em>dictionary</em>) – A Python dictionary containing
similarity functions. Specifically, the dictionary contains
similarity function names as keys and similarity functions as
values. The similarity function typically
takes in a string or two lists of tokens and returns a number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>This function returns a Python dictionary which contains sufficient
information (such as attributes, tokenizers, function code) to be added
to the feature table.</p>
<p>Specifically the Python dictionary contains the following keys:
‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’,
‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
‘function_source’.</p>
<p>For all the keys except the ‘function’ and ‘function_source’ the
value will be either a valid string (if the input feature string is
parsed correctly) or PARSE_EXP (if the parsing was not successful).
The ‘function’ will have a valid Python function as value,
and ‘function_source’ will have the Python function’s source in
string format.</p>
<p>The created function is a self-contained function
which means that the tokenizers and sim functions that it calls are
bundled along with the returned function code.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>feature_string</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>tokenizers</cite> is not of type
    dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>similarity_functions</cite> is not of
    type dictionary.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">match_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>,
<a class="reference internal" href="singlepage.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.add_feature">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">add_feature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_table</span></em>, <em class="sig-param"><span class="n">feature_name</span></em>, <em class="sig-param"><span class="n">feature_dict</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/addfeatures.html#add_feature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.add_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a feature to the feature table.</p>
<p>Specifically, this function is used in combination with
<a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code></a>.
First the user creates a dictionary using <a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code></a>,
then the user uses this function to add feature_dict to the feature table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</p></li>
<li><p><strong>feature_name</strong> (<em>string</em>) – The name that should be given to the feature.</p></li>
<li><p><strong>feature_dict</strong> (<em>dictionary</em>) – A Python dictionary, that is typically
returned by executing <a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the addition was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the input <cite>feature_table</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_name</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_dict</cite> is not of type
    Python dictionary.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>feature_table</cite> does not have necessary columns
    such as ‘feature_name’, ‘left_attribute’, ‘right_attribute’,
    ‘left_attr_tokenizer’,
    ‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
    ‘function_source’ in the DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>feature_name</cite> is already present in the feature
    table.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">match_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.add_blackbox_feature">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">add_blackbox_feature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_table</span></em>, <em class="sig-param"><span class="n">feature_name</span></em>, <em class="sig-param"><span class="n">feature_function</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/addfeatures.html#add_blackbox_feature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.add_blackbox_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a black box feature to the feature table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – The input DataFrame (typically a feature
table) to which the feature must be added.</p></li>
<li><p><strong>feature_name</strong> (<em>string</em>) – The name that should be given to the feature.</p></li>
<li><p><strong>feature_function</strong> (<em>Python function</em>) – A Python function for the black box
feature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value of True is returned if the addition was successful.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the input <cite>feature_table</cite> is not of type
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>feature_name</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>feature_table</cite> does not have necessary columns
    such as ‘feature_name’, ‘left_attribute’, ‘right_attribute’,
    ‘left_attr_tokenizer’,
    ‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
    ‘function_source’ in the DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>feature_name</cite> is already present in the
    feature table.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/extracting_feature_vectors"></span><div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.extract_feature_vecs">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">extract_feature_vecs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">attrs_before</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feature_table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">attrs_after</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/extractfeatures.html#extract_feature_vecs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.extract_feature_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts feature vectors from a DataFrame (typically a
labeled candidate set).</p>
<p>Specifically, this function uses feature
table, ltable and rtable (that is present in the <cite>candset</cite>’s
metadata) to extract feature vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set for which the features
vectors should be extracted.</p></li>
<li><p><strong>attrs_before</strong> (<em>list</em>) – The list of attributes from the input candset,
that should be added before the feature vectors (defaults to None).</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing a list of
features that should be used to compute the feature vectors (
defaults to None).</p></li>
<li><p><strong>attrs_after</strong> (<em>list</em>) – The list of attributes from the input candset
that should be added after the feature vectors (defaults to None).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing feature vectors.</p>
<p>The DataFrame will have metadata ltable and rtable, pointing
to the same ltable and rtable as the input candset.</p>
<p>Also, the output
DataFrame will have three columns: key, foreign key ltable, foreign
key rtable copied from input candset to the output DataFrame. These
three columns precede the columns mentioned in <cite>attrs_before</cite>.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>attrs_before</cite> has attributes that
    are not present in the input candset.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>attrs_after</cite> has attribtues that
    are not present in the input candset.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is set to None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled dataframe which should be converted into feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h4>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.impute_table">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">impute_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">missing_val</span><span class="o">=</span><span class="default_value">'NaN'</span></em>, <em class="sig-param"><span class="n">strategy</span><span class="o">=</span><span class="default_value">'mean'</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">val_all_nans</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/matcherutils.html#impute_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.impute_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute table containing missing values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<em>DataFrame</em>) – DataFrame which values should be imputed.</p></li>
<li><p><strong>exclude_attrs</strong> (<em>List</em>) – list of attribute names to be excluded from
imputing (defaults to None).</p></li>
<li><p><strong>missing_val</strong> (<em>string</em><em> or </em><em>int</em>) – The placeholder for the missing values.
All occurrences of <cite>missing_values</cite> will be imputed.
For missing values encoded as np.nan, use the string value ‘NaN’
(defaults to ‘NaN’).</p></li>
<li><p><strong>strategy</strong> (<em>string</em>) – String that specifies on how to impute values. Valid
strings: ‘mean’, ‘median’, ‘most_frequent’ (defaults to ‘mean’).</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – axis=1 along rows, and axis=0 along columns  (defaults
to 0).</p></li>
<li><p><strong>val_all_nans</strong> (<em>float</em>) – Value to fill in if all the values in the column
are NaN.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Imputed DataFrame.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If <cite>table</cite> is not of type pandas DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># H is the feature vector which should be imputed. Specifically, impute the missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># in each column, with the mean of that column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_similarity_functions"></span><div class="section" id="supported-similarity-functions">
<h4>Supported Similarity Functions<a class="headerlink" href="#supported-similarity-functions" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.affine">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the affine measure between the two input strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure
should be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure
should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The affine measure if both the strings are not missing (i.e NaN or
None), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.hamming_dist">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">hamming_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#hamming_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.hamming_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Hamming distance between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Hamming distance if both the strings are not missing (i.e NaN),
else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_dist</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;john&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;john&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.hamming_sim">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">hamming_sim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#hamming_sim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.hamming_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Hamming similarity between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Hamming similarity if both the strings are not missing (i.e NaN),
else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_sim</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_sim</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.lev_dist">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">lev_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#lev_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.lev_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Levenshtein distance between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Levenshtein distance if both the strings are not missing (i.e NaN),
else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.lev_sim">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">lev_sim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#lev_sim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.lev_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Levenshtein similarity between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Levenshtein similarity if both the strings are not missing (i.e
NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_sim</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.jaro">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">jaro</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#jaro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.jaro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaro measure between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaro measure if both the strings are not missing (i.e NaN),
else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="s1">&#39;MARHTA&#39;</span><span class="p">)</span>
<span class="go">0.9444444444444445</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;MARTHA&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.jaro_winkler">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">jaro_winkler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#jaro_winkler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.jaro_winkler" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaro Winkler measure between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaro Winkler measure if both the strings are not missing (i.e NaN),
else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro_winkler</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="s1">&#39;MARHTA&#39;</span><span class="p">)</span>
<span class="go">0.9611111111111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">jaro_winkler</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.needleman_wunsch">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">needleman_wunsch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#needleman_wunsch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.needleman_wunsch" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Needleman-Wunsch measure between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Needleman-Wunsch measure if both the strings are not missing (i.e
NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">needleman_wunsch</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">needleman_wunsch</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.smith_waterman">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">smith_waterman</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s1</span></em>, <em class="sig-param"><span class="n">s2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#smith_waterman"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.smith_waterman" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Smith-Waterman measure between the two input
strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
<li><p><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Smith-Waterman measure if both the strings are not missing (i.e
NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">smith_waterman</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;hat&#39;</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">smith_waterman</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.jaccard">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">jaccard</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#jaccard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaccard measure between the two input
lists/sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr1</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Jaccard
measure should be computed.</p></li>
<li><p><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Jaccard
measure should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaccard measure if both the lists/set are not None and do not have
any missing tokens (i.e NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaccard</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaccard</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.cosine">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">cosine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#cosine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the cosine measure between the two input
lists/sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr1</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the cosine
measure should be computed.</p></li>
<li><p><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the cosine
measure should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The cosine measure if both the lists/set are not None and do not have
any missing tokens (i.e NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">cosine</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.7071067811865475</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">cosine</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.overlap_coeff">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">overlap_coeff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#overlap_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.overlap_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the overlap coefficient between the two input
lists/sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr1</strong> (<em>list</em><em> or </em><em>set</em>) – The input lists or sets for which the overlap
coefficient should be computed.</p></li>
<li><p><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input lists or sets for which the overlap
coefficient should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The overlap coefficient if both the lists/sets are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">overlap_coeff</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">overlap_coeff</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.dice">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">dice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#dice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.dice" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Dice score between the two input
lists/sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr1</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Dice
score should be computed.</p></li>
<li><p><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Dice
score should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Dice score if both the lists/set are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">dice</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.6666666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">dice</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.monge_elkan">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">monge_elkan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr1</span></em>, <em class="sig-param"><span class="n">arr2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#monge_elkan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.monge_elkan" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Monge-Elkan measure between the two input
lists/sets. Specifically, this function uses Jaro-Winkler measure as the
secondary function to compute the similarity score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr1</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the
Monge-Elkan measure should be computed.</p></li>
<li><p><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the
Monge-Elkan measure should be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Monge-Elkan measure if both the lists/set are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">monge_elkan</span><span class="p">([</span><span class="s1">&#39;Niall&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Neal&#39;</span><span class="p">])</span>
<span class="go">0.8049999999999999</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">monge_elkan</span><span class="p">([</span><span class="s1">&#39;Niall&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.exact_match">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">exact_match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d1</span></em>, <em class="sig-param"><span class="n">d2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#exact_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.exact_match" title="Permalink to this definition">¶</a></dt>
<dd><p>This function check if two objects are match exactly. Typically the
objects are string, boolean and ints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d1</strong> (<em>str</em><em>, </em><em>boolean</em><em>, </em><em>int</em>) – The input objects which should checked
whether they match exactly.</p></li>
<li><p><strong>d2</strong> (<em>str</em><em>, </em><em>boolean</em><em>, </em><em>int</em>) – The input objects which should checked
whether they match exactly.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A value of 1 is returned if they match exactly,
else returns 0. Further if one of the objects is NaN or None,
it returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="s1">&#39;Niall&#39;</span><span class="p">,</span> <span class="s1">&#39;Neal&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="s1">&#39;Niall&#39;</span><span class="p">,</span> <span class="s1">&#39;Niall&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.rel_diff">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">rel_diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d1</span></em>, <em class="sig-param"><span class="n">d2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#rel_diff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.rel_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the relative difference between two numbers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d1</strong> (<em>float</em>) – The input numbers for which the relative difference
must be computed.</p></li>
<li><p><strong>d2</strong> (<em>float</em>) – The input numbers for which the relative difference
must be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A float value of relative difference between the input numbers (if
they are valid). Further if one of the input objects is NaN or None,
it returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="go">0.6666666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.abs_norm">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">abs_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d1</span></em>, <em class="sig-param"><span class="n">d2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/simfunctions.html#abs_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.abs_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the absolute norm similarity between two numbers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d1</strong> (<em>float</em>) – Input numbers for which the absolute norm must
be computed.</p></li>
<li><p><strong>d2</strong> (<em>float</em>) – Input numbers for which the absolute norm must
be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A float value of absolute norm between the input numbers (if
they are valid). Further if one of the input objects is NaN or None,
it returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_tokenizers"></span><div class="section" id="supported-tokenizers">
<h4>Supported Tokenizers<a class="headerlink" href="#supported-tokenizers" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.tok_qgram">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">tok_qgram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_string</span></em>, <em class="sig-param"><span class="n">q</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#tok_qgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tok_qgram" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of q-grams. Note that,
by default the input strings are padded and then tokenized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – q-val that should be used to tokenize the input string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens, if the input string is not NaN,
else returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="s1">&#39;database&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[&#39;#d&#39;, &#39;da&#39;, &#39;at&#39;, &#39;ta&#39;, &#39;ab&#39;, &#39;ba&#39;, &#39;as&#39;, &#39;se&#39;, &#39;e$&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="s1">&#39;database&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;##d&#39;, &#39;#da&#39;, &#39;dat&#39;, &#39;ata&#39;, &#39;tab&#39;, &#39;aba&#39;, &#39;bas&#39;, &#39;ase&#39;, &#39;se$&#39;, &#39;e$$&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.tok_delim">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">tok_delim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_string</span></em>, <em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#tok_delim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tok_delim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of tokens
(based on the delimiter).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</p></li>
<li><p><strong>d</strong> (<em>string</em>) – Delimiter string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens, if the input string is not NaN ,
else returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="s1">&#39;data science&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="s1">&#39;data$#$science&#39;</span><span class="p">,</span> <span class="s1">&#39;$#$&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.tok_wspace">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">tok_wspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_string</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#tok_wspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tok_wspace" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of tokens
(based on the white space).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens, if the input string is not NaN ,
else returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="s1">&#39;data science&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="s1">&#39;data         science&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.tok_alphabetic">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">tok_alphabetic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_string</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#tok_alphabetic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tok_alphabetic" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of tokens that are maximal sequences of
consecutive alphabetical characters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens, if the input string is not NaN ,
else returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="s1">&#39;data99science, data#integration.&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;, &#39;data&#39;, &#39;integration&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="s1">&#39;99&#39;</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.tok_alphanumeric">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">tok_alphanumeric</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_string</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/feature/tokenizers.html#tok_alphanumeric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tok_alphanumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of tokens that are maximal sequences of
consecutive alphanumeric characters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens, if the input string is not NaN ,
else returns NaN.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="s1">&#39;data9,(science), data9#.(integration).88&#39;</span><span class="p">)</span>
<span class="go">[&#39;data9&#39;, &#39;science&#39;, &#39;data9&#39;, &#39;integration&#39;, &#39;88&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="s1">&#39;#.$&#39;</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<span id="document-user_manual/api/matching"></span><div class="section" id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/splitting_data_into_train_test"></span><div class="section" id="splitting-data-into-train-and-test">
<h4>Splitting Data into Train and Test<a class="headerlink" href="#splitting-data-into-train-and-test" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.split_train_test">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">split_train_test</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labeled_data</span></em>, <em class="sig-param"><span class="n">train_proportion</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/matcherutils.html#split_train_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.split_train_test" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input data into train and test.</p>
<p>Specifically, this function is just a wrapper of scikit-learn’s
train_test_split function.</p>
<p>This function also takes care of copying the metadata from the input
table to train and test splits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labeled_data</strong> (<em>DataFrame</em>) – The input pandas DataFrame that needs to be
split into train and test.</p></li>
<li><p><strong>train_proportion</strong> (<em>float</em>) – A number between 0 and 1, indicating the
proportion of tuples that should be included in the train split (
defaults to 0.5).</p></li>
<li><p><strong>random_state</strong> (<em>object</em>) – A number of random number object (as in
scikit-learn).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python dictionary containing two keys - train and test.</p>
<p>The value for the key ‘train’ is a pandas DataFrame containing tuples
allocated from the input table based on train_proportion.</p>
<p>Similarly, the value for the key ‘test’ is a pandas DataFrame containing
tuples for evaluation.</p>
<p>This function sets the output DataFrames (train, test) properties
same as the input DataFrame.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data or the feature vectors that should be split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_matchers"></span><div class="section" id="supported-matchers">
<h4>Supported Matchers<a class="headerlink" href="#supported-matchers" title="Permalink to this headline">¶</a></h4>
<div class="section" id="ml-matchers">
<h5>ML Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h5>
<dl class="py class">
<dt id="py_entitymatching.DTMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">DTMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/dtmatcher.html#DTMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.DTMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Decision Tree matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Decision Tree
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Decision Tree
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For more details please see</p>
<dl class="py method">
<dt id="py_entitymatching.DTMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.DTMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.DTMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.DTMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.RFMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">RFMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/rfmatcher.html#RFMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.RFMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Random Forest matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Random Forest
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Random Forest
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.RFMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RFMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.RFMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RFMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.SVMMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">SVMMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/svmmatcher.html#SVMMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.SVMMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s SVM
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s SVM
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.SVMMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SVMMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.SVMMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SVMMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.NBMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">NBMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/nbmatcher.html#NBMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.NBMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Naive Bayes matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Naive Bayes
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Naive Bayes
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.NBMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.NBMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.NBMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.NBMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.LinRegMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">LinRegMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/linregmatcher.html#LinRegMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.LinRegMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear regression matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – Arguments to scikit-learn’s Linear Regression matcher.</p></li>
<li><p><strong>**kwargs</strong> – <p>Arguments to scikit-learn’s Linear Regression matcher.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – Name that should be given to this matcher.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.LinRegMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LinRegMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.LinRegMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LinRegMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.LogRegMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">LogRegMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/logregmatcher.html#LogRegMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.LogRegMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Logistic Regression matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – THe Arguments to scikit-learn’s Logistic Regression
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>THe Arguments to scikit-learn’s Logistic Regression
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.LogRegMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LogRegMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.LogRegMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LogRegMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.XGBoostMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">XGBoostMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcher/xgboostmatcher.html#XGBoostMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.XGBoostMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>XGBoost matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to XGBoost
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to XGBoost
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.XGBoostMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.XGBoostMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.XGBoostMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.XGBoostMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rule-based-matcher">
<h5>Rule-Based Matcher<a class="headerlink" href="#rule-based-matcher" title="Permalink to this headline">¶</a></h5>
</div>
</div>
<span id="document-user_manual/api/selecting_matcher"></span><div class="section" id="selecting-matcher">
<h4>Selecting Matcher<a class="headerlink" href="#selecting-matcher" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.select_matcher">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">select_matcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matchers</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">metric_to_select_matcher</span><span class="o">=</span><span class="default_value">'precision'</span></em>, <em class="sig-param"><span class="n">metrics_to_display</span><span class="o">=</span><span class="default_value">['precision', 'recall', 'f1']</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matcherselector/mlmatcherselection.html#select_matcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.select_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function selects a matcher from a given list of matchers based on a
given metric.</p>
<p>Specifically, this function internally uses scikit-learn’s
cross validation function to select a matcher. There are two ways the
user can call the fit method. First, interface similar to scikit-learn
where the feature vectors and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matchers</strong> (<em>MLMatcher</em>) – List of ML matchers to be selected from.</p></li>
<li><p><strong>x</strong> (<em>DataFrame</em>) – Input feature vectors given as pandas DataFrame (
defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – Input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – Input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table (defaults
to None).</p></li>
<li><p><strong>metric_to_select_matcher</strong> (<em>string</em>) – The metric based on which the matchers must be
selected. The string can be one of ‘precision’, ‘recall’,
‘f1’ (defaults to ‘precision’).</p></li>
<li><p><strong>metrics_to_display</strong> (<em>list</em>) – The metrics that will be displayed to
the user. It should be a list of any of the strings ‘precision’,
‘recall’, or ‘f1’ (defaults to [‘precision’, ‘recall’, ‘f1’]).</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The k value for cross-validation (defaults to 5).</p></li>
<li><p><strong>n_jobs</strong> (<em>integer</em>) – The number of CPUs to use to do the computation.
-1 means ‘all CPUs (defaults to -1)’.</p></li>
<li><p><strong>random_state</strong> (<em>object</em>) – Pseudo random number generator that should be
used for splitting the data into folds (defaults to None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A dictionary containing three keys - selected matcher, cv_stats, and drill_down_cv_stats.</p>
<blockquote>
<div><p>The selected matcher has a value that is a matcher (MLMatcher) object,
cv_stats is a Dataframe containing average metrics for each matcher,
and drill_down_cv_stats is a dictionary containing a table for each metric
the user wants to display containing the score of the matchers for each fold.</p>
</div></blockquote>
<dl class="simple">
<dt>Raises:</dt><dd><dl class="simple">
<dt>AssertionError: If <cite>metric_to_select_matcher</cite> is not one of ‘precision’, ‘recall’,</dt><dd><p>or ‘f1’.</p>
</dd>
<dt>AssertionError: If each item in the list <cite>metrics_to_display</cite> is not one of</dt><dd><p>’precision’, ‘recall’, or ‘f1’.</p>
</dd>
</dl>
</dd>
</dl>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="go"># train is the feature vector containing user labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<span id="document-user_manual/api/debugging_matcher"></span><div class="section" id="debugging-matcher">
<h3>Debugging Matcher<a class="headerlink" href="#debugging-matcher" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.vis_debug_dt">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">vis_debug_dt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matcher</span></em>, <em class="sig-param"><span class="n">train</span></em>, <em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span></em>, <em class="sig-param"><span class="n">target_attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugmatcher/debug_gui_decisiontree_matcher.html#vis_debug_dt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.vis_debug_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Visual debugger for Decision Tree matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matcher</strong> (<a class="reference internal" href="singlepage.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><em>DTMatcher</em></a>) – The Decision tree matcher that should be debugged.</p></li>
<li><p><strong>train</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to train the
matcher.</p></li>
<li><p><strong>test</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to test the
matcher.</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes to be excluded from train
and test, for training and testing.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name in the ‘train’ containing the
true labels.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="go"># &#39;devel&#39; is the labeled set used for development (e.g., selecting the best matcher) purposes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.vis_debug_rf">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">vis_debug_rf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matcher</span></em>, <em class="sig-param"><span class="n">train</span></em>, <em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span></em>, <em class="sig-param"><span class="n">target_attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugmatcher/debug_gui_randomforest_matcher.html#vis_debug_rf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.vis_debug_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Visual debugger for Random Forest matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matcher</strong> (<a class="reference internal" href="singlepage.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><em>RFMatcher</em></a>) – The Random Forest matcher that should be debugged.</p></li>
<li><p><strong>train</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to train the
matcher.</p></li>
<li><p><strong>test</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to test the
matcher.</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes to be excluded from train
and test, for training and testing.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name in the ‘train’ containing the
true labels.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="go"># &#39;devel&#39; is the labeled set used for development (e.g., selecting the best matcher) purposes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_rf</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.debug_decisiontree_matcher">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">debug_decisiontree_matcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">decision_tree</span></em>, <em class="sig-param"><span class="n">tuple_1</span></em>, <em class="sig-param"><span class="n">tuple_2</span></em>, <em class="sig-param"><span class="n">feature_table</span></em>, <em class="sig-param"><span class="n">table_columns</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugmatcher/debug_decisiontree_matcher.html#debug_decisiontree_matcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.debug_decisiontree_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to debug a decision tree matcher using two input
tuples.</p>
<p>Specifically, this function takes in two tuples, gets the feature vector
using the feature table and finally passes it to the decision tree and
displays the path that the feature vector takes in the decision tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>decision_tree</strong> (<a class="reference internal" href="singlepage.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><em>DTMatcher</em></a>) – The input
decision tree object that should be debugged.</p></li>
<li><p><strong>tuple_1</strong> (<em>Series</em>) – Input tuples that should be debugged.</p></li>
<li><p><strong>tuple_2</strong> (<em>Series</em>) – Input tuples that should be debugged.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – Feature table containing the functions
for the features.</p></li>
<li><p><strong>table_columns</strong> (<em>list</em>) – List of all columns that will be outputted
after generation of feature vectors.</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – List of attributes that should be removed from
the table columns.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input feature table is not of type pandas
    DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># devel is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># F is the feature vector got from evaluation set of the labeled data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A and B are input tables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.debug_randomforest_matcher">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">debug_randomforest_matcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">random_forest</span></em>, <em class="sig-param"><span class="n">tuple_1</span></em>, <em class="sig-param"><span class="n">tuple_2</span></em>, <em class="sig-param"><span class="n">feature_table</span></em>, <em class="sig-param"><span class="n">table_columns</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/debugmatcher/debug_randomforest_matcher.html#debug_randomforest_matcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.debug_randomforest_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to debug a random forest matcher using two input
tuples.</p>
<p>Specifically, this function takes in two tuples, gets the feature vector
using the feature table and finally passes it to the random forest  and
displays the path that the feature vector takes in each of the decision
trees that make up the random forest matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_forest</strong> (<a class="reference internal" href="singlepage.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><em>RFMatcher</em></a>) – The input
random forest object that should be debugged.</p></li>
<li><p><strong>tuple_1</strong> (<em>Series</em>) – Input tuples that should be debugged.</p></li>
<li><p><strong>tuple_2</strong> (<em>Series</em>) – Input tuples that should be debugged.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – Feature table containing the functions
for the features.</p></li>
<li><p><strong>table_columns</strong> (<em>list</em>) – List of all columns that will be outputted
after generation of feature vectors.</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – List of attributes that should be removed from
the table columns.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input feature table is not of type pandas
    DataFrame.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># devel is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># F is the feature vector got from evaluation set of the labeled data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A and B are input tables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_randomforest_matcher</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/triggers"></span><div class="section" id="triggers">
<h3>Triggers<a class="headerlink" href="#triggers" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="py_entitymatching.MatchTrigger">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">MatchTrigger</code><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="py_entitymatching.MatchTrigger.add_action">
<code class="sig-name descname">add_action</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.add_action"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an action to the match trigger. If the result of a rule is the
same value as the condition status, then the action will be carried
out. The condition status can be added with the function add_cond_status.</p>
<blockquote>
<div><dl>
<dt>Args:</dt><dd><p>value (integer): The action. Currently only the values 0 and 1 are supported.</p>
</dd>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.add_cond_rule">
<code class="sig-name descname">add_cond_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conjunct_list</span></em>, <em class="sig-param"><span class="n">feature_table</span></em>, <em class="sig-param"><span class="n">rule_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.add_cond_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_cond_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the match trigger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</p></li>
<li><p><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The name of the rule added (string).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>rule_name</cite> already exists.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is not a valid value parameter.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.add_cond_status">
<code class="sig-name descname">add_cond_status</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">status</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.add_cond_status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_cond_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a condition status to the match trigger. If the result of a rule
is the same value as the condition status, then the action will be
carried out. The action can be added with the function add_action.</p>
<blockquote>
<div><dl>
<dt>Args:</dt><dd><p>status (boolean): The condition status.</p>
</dd>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.delete_rule">
<code class="sig-name descname">delete_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.delete_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the match trigger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_table</span></em>, <em class="sig-param"><span class="n">label_column</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the rules of the match trigger for a table of matcher
results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_table</strong> (<em>DataFrame</em>) – The input table of type pandas DataFrame
containing tuple pairs and labels from matching (defaults to None).</p></li>
<li><p><strong>label_column</strong> (<em>string</em>) – The attribute name where the predictions
are stored in the input table (defaults to None).</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A DataFrame with predictions updated.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The table H is a table with prediction labels generated from matching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.get_rule">
<code class="sig-name descname">get_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.get_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function object corresponding to the specified rule.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.get_rule_names">
<code class="sig-name descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.get_rule_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the match trigger.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of names of all the rules in the match trigger (list).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.set_feature_table">
<code class="sig-name descname">set_feature_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_table</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.set_feature_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the match trigger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.MatchTrigger.view_rule">
<code class="sig-name descname">view_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/triggers/matchtrigger.html#MatchTrigger.view_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.MatchTrigger.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<span id="document-user_manual/api/evaluating_the_matching_output"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="py_entitymatching.eval_matches">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">eval_matches</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_frame</span></em>, <em class="sig-param"><span class="n">gold_label_attr</span></em>, <em class="sig-param"><span class="n">predicted_label_attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/evaluation/evaluation.html#eval_matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.eval_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the matches from the matcher.</p>
<p>Specifically, given a DataFrame containing golden labels and predicted
labels, this function would evaluate the matches and return the accuracy
results such as precision, recall and F1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_frame</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing “gold”
labels and “predicted” labels.</p></li>
<li><p><strong>gold_label_attr</strong> (<em>string</em>) – An attribute in the input DataFrame containing
“gold” labels.</p></li>
<li><p><strong>predicted_label_attr</strong> (<em>string</em>) – An attribute in the input DataFrame
containing “predicted” labels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Python dictionary containing the accuracy measures such as
precision, recall, F1.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>data_frame</cite> is not of type
    pandas DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>gold_label_attr</cite> is not of
    type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>predicted_label_attr</cite> is not of
    type string.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>gold_label_attr</cite> is not in
    the input dataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If the <cite>predicted_label_attr</cite> is not in
    the input dataFrame.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.print_eval_summary">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">print_eval_summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eval_summary</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/evaluation/evaluation.html#print_eval_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.print_eval_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a summary of evaluation results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eval_summary</strong> (<em>dictionary</em>) – Dictionary containing evaluation results,
typically from ‘eval_matches’ function.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">print_eval_summary</span><span class="p">(</span><span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_false_positives_as_df">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_false_positives_as_df</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="n">eval_summary</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/evaluation/evaluation.html#get_false_positives_as_df"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_false_positives_as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only the false positives from the input table and return as a
DataFrame based on the evaluation results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input table (pandas DataFrame) that was used for
evaluation.</p></li>
<li><p><strong>eval_summary</strong> (<em>dictionary</em>) – A Python dictionary containing evaluation
results, typically from ‘eval_matches’ command.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing only the False positives from
the input table.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_pos_df</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_false_positives_as_df</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="py_entitymatching.get_false_negatives_as_df">
<code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">get_false_negatives_as_df</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="n">eval_summary</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/evaluation/evaluation.html#get_false_negatives_as_df"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.get_false_negatives_as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only the false negatives from the input table and return as a
DataFrame based on the evaluation results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input table (pandas DataFrame) that was used for
evaluation.</p></li>
<li><p><strong>eval_summary</strong> (<em>dictionary</em>) – A Python dictionary containing evaluation
results, typically from ‘eval_matches’ command.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing only the false negatives from
the input table.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_neg_df</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_false_negatives_as_df</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="experimental-commands">
<h2>Experimental Commands<a class="headerlink" href="#experimental-commands" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/dask_commands"></span><div class="section" id="commands-implemented-using-dask">
<h3>Commands Implemented Using Dask<a class="headerlink" href="#commands-implemented-using-dask" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.dask.dask_down_sample.dask_down_sample">
<code class="sig-prename descclassname">py_entitymatching.dask.dask_down_sample.</code><code class="sig-name descname">dask_down_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">y_param</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rem_puncs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_ltable_chunks</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_sample_rtable_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_down_sample.dask_down_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>This command down samples two tables A and B into smaller tables A’ and
B’ respectively.
Specifically, first it randomly selects <cite>size</cite> tuples
from the table B to be table B’. Next, it builds an inverted index I
(token, tuple_id) on table A. For each tuple x ∈ B’, the algorithm
finds a set P of k/2 tuples from I that match x,
and a set Q of k/2 tuples randomly selected from A - P.
The idea is for A’ and B’ to share some matches yet be
as representative of A and B as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table, i.e., table A.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table, i.e., table B.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size that table B should be down sampled to.</p></li>
<li><p><strong>y_param</strong> (<em>int</em>) – The parameter to control the down sample size of table A.
Specifically, the down sampled size of table A should be close to
size * y_param.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether a progress bar
should be displayed (defaults to True).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – The seed for the pseudo random number generator to select
the tuples from A and B (defaults to None).</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether a default set of stop words
must be removed.</p></li>
<li><p><strong>rem_puncs</strong> (<em>boolean</em>) – A flag to indicate whether the punctuations must be
removed from the strings.</p></li>
<li><p><strong>n_ltable_chunks</strong> (<em>int</em>) – The number of partitions for ltable (defaults to 1). If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
<li><p><strong>n_sample_rtable_chunks</strong> (<em>int</em>) – The number of partitions for the
sampled rtable (defaults to 1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Down sampled tables A and B as pandas DataFrames.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If any of the input tables (<cite>table_a</cite>, <cite>table_b</cite>) are
    empty or not a DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>size</cite> or <cite>y_param</cite> is empty or 0 or not a
    valid integer value.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>seed</cite> is not a valid integer
    value.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type bool.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type bool.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_ltable_chunks</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_sample_rtable_chunks</cite> is not of type int.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_down_sample</span> <span class="kn">import</span> <span class="n">dask_down_sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">dask_down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_sample_rtable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Example with seed = 0. This means the same sample data set will be returned</span>
<span class="go"># each time this function is run.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">dask_down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_sample_rtable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="blocking">
<h4>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h4>
<dl class="py class">
<dt id="py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_attr_equiv_blocker.</code><code class="sig-name descname">DaskAttrEquivalenceBlocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS BLOCKER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks based on the equivalence of attribute values.</p>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks an input candidate set of tuple pairs based on attribute equivalence.
Finds tuple pairs from an input candidate set of tuple pairs
such that the value of attribute l_block_attr of the left tuple in a
tuple pair exactly matches the value of attribute r_block_attr of the
right tuple in the tuple pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_attr_equiv_blocker</span> <span class="kn">import</span> <span class="n">DaskAttrEquivalenceBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">DaskAttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">n_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_ltable_chunks</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_rtable_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK</p>
<p>Blocks two tables based on attribute equivalence.
Conceptually, this will check <cite>l_block_attr=r_block_attr</cite> for each tuple
pair from the Cartesian product of tables <cite>ltable</cite> and <cite>rtable</cite>. It outputs a
Pandas dataframe object with tuple pairs that satisfy the equality condition.
The dataframe will include attributes ‘_id’, key attribute from
ltable, key attributes from rtable, followed by lists <cite>l_output_attrs</cite> and
<cite>r_output_attrs</cite> if they are specified. Each of these output and key attributes will be
prefixed with given <cite>l_output_prefix</cite> and <cite>r_output_prefix</cite>. If <cite>allow_missing</cite> is set
to <cite>True</cite> then all tuple pairs with missing value in at least one of the tuples will be
included in the output dataframe.
Further, this will update the following metadata in the catalog for the output table:
(1) key, (2) ltable, (3) rtable, (4) fk_ltable, and (5) fk_rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_ltable_chunks</strong> (<em>int</em>) – The number of partitions to split the left table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
<li><p><strong>n_rtable_chunks</strong> (<em>int</em>) – The number of partitions to split the right table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_ltable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_rtable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_attr_equiv_blocker</span> <span class="kn">import</span> <span class="n">DaskAttrEquivalenceBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">DaskAttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em>, <em class="sig-param"><span class="n">l_block_attr</span></em>, <em class="sig-param"><span class="n">r_block_attr</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_attr_equiv_blocker.DaskAttrEquivalenceBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on attribute equivalence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left tuple.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right tuple.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the blocking attributes
should be blocked (defaults to False). If this flag is set
to True, the pair will be kept if either ltuple has missing value in
l_block_attr or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked, i.e., the values
of l_block_attr in ltuple and r_block_attr in rtuple are different
(boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_attr_equiv_blocker</span> <span class="kn">import</span> <span class="n">DaskAttrEquivalenceBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">DaskAttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_overlap_blocker.</code><code class="sig-name descname">DaskOverlapBlocker</code><a class="headerlink" href="#py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks an input candidate set of tuple pairs based on the overlap
of token sets of attribute values. Finds tuple pairs from an input
candidate set of tuple pairs such that
the overlap between (a) the set of tokens obtained by tokenizing the
value of attribute l_overlap_attr of the left tuple in a tuple pair,
and (b) the set of tokens obtained by tokenizing the value of
attribute r_overlap_attr of the right tuple in the tuple pair,
is above a certain threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – <p>A flag to indicate whether the debug information</p>
<p>should be logged (defaults to False).</p>
</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_overlap_blocker</span> <span class="kn">import</span> <span class="n">DaskOverlapBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">DaskOverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">n_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_ltable_chunks</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_rtable_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks two tables based on the overlap of token sets of attribute
values. Finds tuple pairs from left and right tables such that the overlap
between (a) the set of tokens obtained by tokenizing the value of
attribute l_overlap_attr of a tuple from the left table, and (b) the
set of tokens obtained by tokenizing the value of attribute
r_overlap_attr of a tuple from the right table, is above a certain
threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed from the token sets of the
overlap attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes
values are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words (i.e, using whitespace
as delimiter) (defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must
overlap (defaults to 1).</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the output candidate set (defaults
to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the output candidate set  (defaults
to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_ltable_chunks</strong> (<em>int</em>) – The number of partitions to split the left table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
<li><p><strong>n_rtable_chunks</strong> (<em>int</em>) – The number of partitions to split the right table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_ltable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_rtable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_overlap_blocker</span> <span class="kn">import</span> <span class="n">DaskOverlapBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">DaskOverlapBlocker</span><span class="p">()</span>
<span class="go"># Use all cores</span>
<span class="go"># # Use word-level tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rtable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># # Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rtable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># # Include all possible missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rtable_chunks</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">q_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">word_level</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">overlap_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">allow_missing</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_overlap_blocker.DaskOverlapBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on the overlap of token sets of attribute values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left tuple.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right tuple.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – A value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_rule_based_blocker.</code><code class="sig-name descname">DaskRuleBasedBlocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS BLOCKER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks  based on a sequence of blocking rules supplied by the user.</p>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.add_rule">
<code class="sig-name descname">add_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conjunct_list</span></em>, <em class="sig-param"><span class="n">feature_table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rule_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.add_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</p></li>
<li><p><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The name of the rule added (string).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>rule_name</cite> already exists.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is not a valid value
    parameter.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_rule_based_blocker</span> <span class="kn">import</span> <span class="n">DaskRuleBasedBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK</p>
<p>Blocks an input candidate set of tuple pairs based on a sequence of
blocking rules supplied by the user.
Finds tuple pairs from an input candidate set of tuple pairs that
survive the sequence of blocking rules. A tuple pair survives the
sequence of blocking rules if none of the rules in the sequence returns
True for that pair. If any of the rules returns True, then the pair is
blocked (dropped).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_rule_based_blocker</span> <span class="kn">import</span> <span class="n">DaskRuleBasedBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is the candidate set.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_ltable_chunks</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_rtable_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK</p>
<p>Blocks two tables based on the sequence of rules supplied by the user.
Finds tuple pairs from left and right tables that survive the sequence
of blocking rules. A tuple pair survives the sequence of blocking rules
if none of the rules in the sequence returns True for that pair. If any
of the rules returns True, then the pair is blocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_ltable_chunks</strong> (<em>int</em>) – The number of partitions to split the left table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
<li><p><strong>n_rtable_chunks</strong> (<em>int</em>) – The number of partitions to split the right table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived the sequence of
blocking rules (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_ltable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_rtable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_rule_based_blocker</span> <span class="kn">import</span> <span class="n">DaskRuleBasedBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a sequence of blocking rules supplied
by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked by applying the
sequence of blocking rules (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_rule_based_blocker</span> <span class="kn">import</span> <span class="n">DaskRuleBasedBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.delete_rule">
<code class="sig-name descname">delete_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_rule_based_blocker</span> <span class="kn">import</span> <span class="n">DaskRuleBasedBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.get_rule">
<code class="sig-name descname">get_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function object corresponding to the specified rule.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.get_rule_names">
<code class="sig-name descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of names of all the rules in the rule-based blocker (list).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.set_feature_table">
<code class="sig-name descname">set_feature_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feature_table</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.view_rule">
<code class="sig-name descname">view_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rule_based_blocker.DaskRuleBasedBlocker.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DaskRuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_black_box_blocker.</code><code class="sig-name descname">DaskBlackBoxBlocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS BLOCKER IS EXPERIMENTAL AND NOT TESTED. USE A0T YOUR OWN RISK.</p>
<p>Blocks based on a black box function specified by the user.</p>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks an input candidate set of tuple pairs based on a black box
blocking function specified by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the black box function. A tuple pair survives the black box
blocking function if the function returns False for that pair,
otherwise the tuple pair is dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether logging should be done
(defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_black_box_blocker</span> <span class="kn">import</span> <span class="n">DaskBlackBoxBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">DaskBlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is an output from block_tables</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">r_output_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l_output_prefix</span><span class="o">=</span><span class="default_value">'ltable_'</span></em>, <em class="sig-param"><span class="n">r_output_prefix</span><span class="o">=</span><span class="default_value">'rtable_'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_ltable_chunks</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_rtable_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Blocks two tables based on a black box blocking function specified
by the user.
Finds tuple pairs from left and right tables that survive the black
box function. A tuple pair survives the black box blocking function if
the function returns False for that pair, otherwise the tuple pair is
dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_ltable_chunks</strong> (<em>int</em>) – The number of partitions to split the left table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
<li><p><strong>n_rtable_chunks</strong> (<em>int</em>) – The number of partitions to split the right table (
defaults to 1). If it is set to -1, then the number of
partitions is set to the number of cores in the
machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_ltable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_rtable_chunks</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_black_box_blocker</span> <span class="n">DaskBlackBoxBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">DaskBlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltuple</span></em>, <em class="sig-param"><span class="n">rtuple</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a black box blocking function specified
by the user.</p>
<p>Takes a tuple pair as input, applies the black box blocking function to
it, and returns True (if the intention is to drop the pair) or False
(if the intention is to keep the tuple pair).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair should be dropped or kept,
based on the black box blocking function (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_black_box_blocker</span> <span class="kn">import</span> <span class="n">DaskBlackBoxBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">DaskBlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># A, B are input tables.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.set_black_box_function">
<code class="sig-name descname">set_black_box_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_black_box_blocker.DaskBlackBoxBlocker.set_black_box_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets black box function to be used for blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<em>function</em>) – the black box function to be used for blocking .</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.dask.dask_extract_features.dask_extract_feature_vecs">
<code class="sig-prename descclassname">py_entitymatching.dask.dask_extract_features.</code><code class="sig-name descname">dask_extract_feature_vecs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">candset</span></em>, <em class="sig-param"><span class="n">attrs_before</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feature_table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">attrs_after</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_extract_features.dask_extract_feature_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK</p>
<p>This function extracts feature vectors from a DataFrame (typically a
labeled candidate set).</p>
<p>Specifically, this function uses feature
table, ltable and rtable (that is present in the <cite>candset</cite>’s
metadata) to extract feature vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set for which the features
vectors should be extracted.</p></li>
<li><p><strong>attrs_before</strong> (<em>list</em>) – The list of attributes from the input candset,
that should be added before the feature vectors (defaults to None).</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing a list of
features that should be used to compute the feature vectors (
defaults to None).</p></li>
<li><p><strong>attrs_after</strong> (<em>list</em>) – The list of attributes from the input candset
that should be added after the feature vectors (defaults to None).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A pandas DataFrame containing feature vectors.</p>
<p>The DataFrame will have metadata ltable and rtable, pointing
to the same ltable and rtable as the input candset.</p>
<p>Also, the output
DataFrame will have three columns: key, foreign key ltable, foreign
key rtable copied from input candset to the output DataFrame. These
three columns precede the columns mentioned in <cite>attrs_before</cite>.</p>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>attrs_before</cite> has attributes that
    are not present in the input candset.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>attrs_after</cite> has attribtues that
    are not present in the input candset.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is set to None.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_chunks</cite> is not of type
    int.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_extract_features</span> <span class="kn">import</span> <span class="n">dask_extract_feature_vecs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled dataframe which should be converted into feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">dask_extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
<dl class="py class">
<dt id="py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_dtmatcher.</code><code class="sig-name descname">DaskDTMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS MATCHER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Decision Tree matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Decision Tree
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Decision Tree
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_dtmatcher.DaskDTMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<p>Currently, the Dask implementation supports only the cases when the table is not
None and the flags inplace, append are False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_rfmatcher.</code><code class="sig-name descname">DaskRFMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS MATCHER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Random Forest matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Random Forest
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Random Forest
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_rfmatcher.DaskRFMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<p>Currently, the Dask implementation supports only the cases when the table is not
None and the flags inplace, append are False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_nbmatcher.</code><code class="sig-name descname">DaskNBMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS MATCHER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Naive Bayes matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to scikit-learn’s Naive Bayes
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to scikit-learn’s Naive Bayes
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_nbmatcher.DaskNBMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<p>Currently, the Dask implementation supports only the cases when the table is not
None and the flags inplace, append are False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_logregmatcher.</code><code class="sig-name descname">DaskLogRegMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS MATCHER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Logistic Regression matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – THe Arguments to scikit-learn’s Logistic Regression
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>THe Arguments to scikit-learn’s Logistic Regression
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_logregmatcher.DaskLogRegMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<p>Currently, the Dask implementation supports only the cases when the table is not
None and the flags inplace, append are False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.dask.dask_xgboost_matcher.</code><code class="sig-name descname">DaskXGBoostMatcher</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS MATCHER IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK</p>
<p>XGBoost matcher.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – The arguments to XGBoost
classifier.</p></li>
<li><p><strong>**kwargs</strong> – <p>The arguments to XGBoost
classifier.</p>
</p></li>
<li><p><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</p></li>
<li><p><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">table</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_attrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">append</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_probs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">probs_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_chunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dask.dask_xgboost_matcher.DaskXGBoostMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<p>Currently, the Dask implementation supports only the cases when the table is not
None and the flags inplace, append are False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</p></li>
<li><p><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</p></li>
<li><p><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</p></li>
<li><p><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</p></li>
<li><p><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</p></li>
<li><p><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</p></li>
<li><p><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</p></li>
<li><p><strong>n_chunks</strong> (<em>int</em>) – The number of partitions to split the candidate set. If it
is set to -1, the number of partitions will be set to the
number of cores in the machine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of predictions or a DataFrame with predictions updated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<span id="document-user_manual/api/tuners"></span><div class="section" id="tuners-for-the-dask-based-commands">
<h3>Tuners for the Dask-based Commands<a class="headerlink" href="#tuners-for-the-dask-based-commands" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.tuner.tuner_down_sample.tuner_down_sample">
<code class="sig-prename descclassname">py_entitymatching.tuner.tuner_down_sample.</code><code class="sig-name descname">tuner_down_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">y_param</span></em>, <em class="sig-param"><span class="n">seed</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span></em>, <em class="sig-param"><span class="n">rem_puncs</span></em>, <em class="sig-param"><span class="n">n_bins</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">sample_proportion</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">repeat</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/tuner/tuner_down_sample.html#tuner_down_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tuner.tuner_down_sample.tuner_down_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Tunes the parameters for down sampling command implemented using Dask.</p>
<p>Given the input tables and the parameters for Dask-based down sampling command,
this command returns the configuration including whether the input tables need to
be swapped, the number of left table chunks, and the number of right table chunks.
It uses “Staged Tuning” approach to select the configuration setting. The key idea
of this approach select the configuration for one parameter at a time.</p>
<p>Conceptually, this command performs the following steps. First, it samples the
left table and down sampled rtable using stratified sampling. Next, it uses the
sampled tables to decide if they need to be swapped or not (by running the down
sample command and comparing the runtimes). Next, it finds the number of rtable
partitions using the sampled tables (by trying the a fixed set of partitions and
comparing the runtimes). The number of partitions is selected to be the number
before which the runtime starts increasing. Then it finds the number of right table
partitions similar to selecting the number of left table partitions. while doing
this, set the number of right table partitions is set to the value found in the
previous step. Finally, it returns the configuration setting back to the user as a
triplet (x, y, z) where x indicates if the tables need to be swapped or not,
y indicates the number of left table partitions (if the tables need to be swapped,
then this indicates the number of left table partitions after swapping),
and z indicates the number of down sampled right table partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table, i.e., table A.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table, i.e., table B.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size that table B should be down sampled to.</p></li>
<li><p><strong>y_param</strong> (<em>int</em>) – The parameter to control the down sample size of table A.
Specifically, the down sampled size of table A should be close to
size * y_param.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – The seed for the pseudo random number generator to select
the tuples from A and B (defaults to None).</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether a default set of stop words
must be removed.</p></li>
<li><p><strong>rem_puncs</strong> (<em>boolean</em>) – A flag to indicate whether the punctuations must be
removed from the strings.</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – The number of bins to be used for stratified sampling.</p></li>
<li><p><strong>sample_proportion</strong> (<em>float</em>) – The proportion used to sample the tables. This value
is expected to be greater than 0 and less thank 1.</p></li>
<li><p><strong>repeat</strong> (<em>int</em>) – The number of times to execute the down sample command while
selecting the values for the parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple containing 3 values. For example if the tuple is represented as (x, y,
z) then x indicates if the tables need to be swapped or not, y indicates the number of
left table partitions (if the tables need to be swapped, then this indicates the
number of left table partitions after swapping), and z indicates the number of
down sampled right table partitions.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.tuner.tuner_down_sample</span> <span class="kn">import</span> <span class="n">tuner_down_sample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">swap_or_not</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="p">,</span> <span class="n">n_sample_rtable_chunks</span><span class="p">)</span> <span class="o">=</span> <span class="n">tuner_down_sample</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">y_param</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">rem_stop_words</span><span class="p">,</span> <span class="n">rem_puncs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="overlap-blocker">
<h4>Overlap Blocker<a class="headerlink" href="#overlap-blocker" title="Permalink to this headline">¶</a></h4>
<dl class="py function">
<dt id="py_entitymatching.tuner.tuner_overlap_blocker.tuner_overlap_blocker">
<code class="sig-prename descclassname">py_entitymatching.tuner.tuner_overlap_blocker.</code><code class="sig-name descname">tuner_overlap_blocker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ltable</span></em>, <em class="sig-param"><span class="n">rtable</span></em>, <em class="sig-param"><span class="n">l_key</span></em>, <em class="sig-param"><span class="n">r_key</span></em>, <em class="sig-param"><span class="n">l_overlap_attr</span></em>, <em class="sig-param"><span class="n">r_overlap_attr</span></em>, <em class="sig-param"><span class="n">rem_stop_words</span></em>, <em class="sig-param"><span class="n">q_val</span></em>, <em class="sig-param"><span class="n">word_level</span></em>, <em class="sig-param"><span class="n">overlap_size</span></em>, <em class="sig-param"><span class="n">ob_obj</span></em>, <em class="sig-param"><span class="n">n_bins</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">sample_proportion</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">repeat</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/tuner/tuner_overlap_blocker.html#tuner_overlap_blocker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.tuner.tuner_overlap_blocker.tuner_overlap_blocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING THIS COMMAND IS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Tunes the parameters for blocking two tables command implemented using Dask.</p>
<p>Given the input tables and the parameters for Dask-based overlap blocker command,
this command returns the configuration including whether the input tables need to
be swapped, the number of left table chunks, and the number of right table chunks.
It uses “Staged Tuning” approach to select the configuration setting. The key idea
of this approach select the configuration for one parameter at a time.</p>
<p>Conceptually, this command performs the following steps. First, it samples the
left table and rtable using stratified sampling. Next, it uses the
sampled tables to decide if they need to be swapped or not (by running the down
sample command and comparing the runtimes). Next, it finds the number of rtable
partitions using the sampled tables (by trying the a fixed set of partitions and
comparing the runtimes). The number of partitions is selected to be the number
before which the runtime starts increasing. Then it finds the number of right table
partitions similar to selecting the number of left table partitions. while doing
this, set the number of right table partitions is set to the value found in the
previous step. Finally, it returns the configuration setting back to the user as a
triplet (x, y, z) where x indicates if the tables need to be swapped or not,
y indicates the number of left table partitions (if the tables need to be swapped,
then this indicates the number of left table partitions after swapping),
and z indicates the number of right table partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed from the token sets of the
overlap attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes
values are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words (i.e, using whitespace
as delimiter) (defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap.</p></li>
<li><p><strong>ob_obj</strong> (<a class="reference internal" href="singlepage.html#py_entitymatching.OverlapBlocker" title="py_entitymatching.OverlapBlocker"><em>OverlapBlocker</em></a>) – The object used to call commands to block two tables
and a candidate set</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – The number of bins to be used for stratified sampling.</p></li>
<li><p><strong>sample_proportion</strong> (<em>float</em>) – The proportion used to sample the tables. This value
is expected to be greater than 0 and less thank 1.</p></li>
<li><p><strong>repeat</strong> (<em>int</em>) – The number of times to execute the down sample command while
selecting the values for the parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple containing 3 values. For example if the tuple is represented as (x, y,
z) then x indicates if the tables need to be swapped or not, y indicates the number of
left table partitions (if the tables need to be swapped, then this indicates the
number of left table partitions after swapping), and z indicates the number of
right table partitions.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.tuner.tuner_overlap_blocker</span> <span class="kn">import</span> <span class="n">tuner_overlap_blocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">py_entitymatching.dask.dask_overlap_blocker</span> <span class="kn">import</span> <span class="n">DaskOverlapBlocker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">DaskOverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">swap_or_not</span><span class="p">,</span> <span class="n">n_ltable_chunks</span><span class="p">,</span> <span class="n">n_sample_rtable_chunks</span><span class="p">)</span> <span class="o">=</span> <span class="n">tuner_overlap_blocker</span><span class="p">(</span><span class="n">ltable</span><span class="p">,</span> <span class="n">rtable</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="n">rem_stop_words</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ob_obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<span id="document-user_manual/api/combiner"></span><div class="section" id="matcher-combiner">
<h3>Matcher Combiner<a class="headerlink" href="#matcher-combiner" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="py_entitymatching.matchercombiner.matchercombiner.MajorityVote">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.matchercombiner.matchercombiner.</code><code class="sig-name descname">MajorityVote</code><a class="reference internal" href="_modules/py_entitymatching/matchercombiner/matchercombiner.html#MajorityVote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.matchercombiner.matchercombiner.MajorityVote" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS CLASS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>The goal of this combiner is to combine a list of predictions from multiple
matchers to produce a consolidated prediction. In this majority voting-based
combining, the prediction that occurs most is returned as the consolicated
prediction. If there is no clear winning prediction (for example, 0 and 1 occuring
equal number of times) then 0 is returned.</p>
<p>Implementation wise, there should be a combiner command to which an object of this
class must be given as a parameter. Based on this parameter, the combiner command
will use this object to combine the predictions.</p>
<dl class="py method">
<dt id="py_entitymatching.matchercombiner.matchercombiner.MajorityVote.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predictions</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matchercombiner/matchercombiner.html#MajorityVote.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.matchercombiner.matchercombiner.MajorityVote.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a list of predictions from matchers using majority voting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>predictions</strong> (<em>DataFrame</em>) – A table containing predictions from multiple
matchers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of consolidated predictions.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv_combiner</span> <span class="o">=</span> <span class="n">MajorityVote</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;rf_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;nb_predictions&#39;</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="py_entitymatching.matchercombiner.matchercombiner.WeightedVote">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.matchercombiner.matchercombiner.</code><code class="sig-name descname">WeightedVote</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matchercombiner/matchercombiner.html#WeightedVote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.matchercombiner.matchercombiner.WeightedVote" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS CLASS EXPERIMENTAL AND NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>The goal of this combiner is to combine a list of predictions from multiple
matchers to produce a consolidated prediction. In this weighted voting-based
combining, each prediction is given a weight, we compute a weighted sum of these
predictions and compare the result to a threshold. If the result is greater than or equal to
the threshold then the consolidated prediction is returned as a match (i.e., 1) else
returned as a no-match.</p>
<p>Implementation wise, there should be a combiner command to which an object of this
class must be given as a parameter. Based on this parameter, the combiner command
will use this object to combine the predictions.</p>
<dl class="py method">
<dt id="py_entitymatching.matchercombiner.matchercombiner.WeightedVote.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predictions</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/py_entitymatching/matchercombiner/matchercombiner.html#WeightedVote.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#py_entitymatching.matchercombiner.matchercombiner.WeightedVote.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a list of predictions from matchers using weighted voting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>predictions</strong> (<em>DataFrame</em>) – A table containing predictions from multiple
matchers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of consolidated predictions.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wv_combiner</span> <span class="o">=</span> <span class="n">WeightedVote</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;rf_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;nb_predictions&#39;</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-contributing"></span><div class="section" id="contributing-to-py-entitymatching">
<span id="contributing"></span><h2><a class="toc-backref" href="#id1">Contributing to py_entitymatching</a><a class="headerlink" href="#contributing-to-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#contributing-to-py-entitymatching" id="id1">Contributing to py_entitymatching</a></p>
<ul>
<li><p><a class="reference internal" href="#where-to-start" id="id2">Where to start?</a></p></li>
<li><p><a class="reference internal" href="#bug-reports-and-enhancement-requests" id="id3">Bug reports and enhancement requests</a></p></li>
<li><p><a class="reference internal" href="#working-with-the-code" id="id4">Working with the code</a></p>
<ul>
<li><p><a class="reference internal" href="#version-control-git-and-github" id="id5">Version control, Git, and GitHub</a></p></li>
<li><p><a class="reference internal" href="#getting-started-with-git" id="id6">Getting started with Git</a></p></li>
<li><p><a class="reference internal" href="#forking" id="id7">Forking</a></p></li>
<li><p><a class="reference internal" href="#creating-a-branch" id="id8">Creating a branch</a></p></li>
<li><p><a class="reference internal" href="#creating-a-development-environment" id="id9">Creating a development environment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-to-the-documentation" id="id10">Contributing to the documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#about-the-py-entitymatching-documentation" id="id11">About the <em>py_entitymatching</em> documentation</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-the-py-entitymatching-documentation" id="id12">How to build the <em>py_entitymatching</em> documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#requirements" id="id13">Requirements</a></p></li>
<li><p><a class="reference internal" href="#building-the-documentation" id="id14">Building the documentation</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-to-the-code-base" id="id15">Contributing to the code base</a></p>
<ul>
<li><p><a class="reference internal" href="#code-standards" id="id16">Code standards</a></p></li>
<li><p><a class="reference internal" href="#writing-tests" id="id17">Writing tests</a></p>
<ul>
<li><p><a class="reference internal" href="#unit-testing" id="id18">Unit testing</a></p></li>
<li><p><a class="reference internal" href="#performance-testing" id="id19">Performance testing</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-your-changes-to-py-entitymatching" id="id20">Contributing your changes to <em>py_entitymatching</em></a></p>
<ul>
<li><p><a class="reference internal" href="#committing-your-code" id="id21">Committing your code</a></p></li>
<li><p><a class="reference internal" href="#combining-commits" id="id22">Combining commits</a></p></li>
<li><p><a class="reference internal" href="#pushing-your-changes" id="id23">Pushing your changes</a></p></li>
<li><p><a class="reference internal" href="#review-your-code" id="id24">Review your code</a></p></li>
<li><p><a class="reference internal" href="#finally-make-the-pull-request" id="id25">Finally, make the pull request</a></p></li>
<li><p><a class="reference internal" href="#delete-your-merged-branch-optional" id="id26">Delete your merged branch (optional)</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">local</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p>This document is adapted from <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/contributing.html">pandas how to contribute guidelines</a> for
<em>py_entitymatching</em> package.</p>
<div class="section" id="where-to-start">
<h3><a class="toc-backref" href="#id2">Where to start?</a><a class="headerlink" href="#where-to-start" title="Permalink to this headline">¶</a></h3>
<p>All contributions, bug reports, bug fixes, documentation improvements,
enhancements and ideas are welcome.</p>
<p>If you are simply looking to start working with the <em>py_entitymatching</em> codebase, navigate to the
<a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching/issues">GitHub “issues” tab</a> and start looking through
interesting issues.</p>
<p>Or maybe through using <em>py_entitymatching</em> you have an idea of your own or are looking for something
in the documentation and thinking ‘this can be improved’…you can do something
about it!</p>
<p>Feel free to ask questions on the <a class="reference external" href="https://groups.google.com/forum/#!forum/py_entitymatching">mailing list</a></p>
</div>
<div class="section" id="bug-reports-and-enhancement-requests">
<h3><a class="toc-backref" href="#id3">Bug reports and enhancement requests</a><a class="headerlink" href="#bug-reports-and-enhancement-requests" title="Permalink to this headline">¶</a></h3>
<p>Bug reports are an important part of making <em>py_entitymatching</em> more stable.Having a
complete bug report will allow others to reproduce the bug and provide insight into
fixing. We use GitHub issue tracker to track bugs. It is important that you provide the
exact version of <em>py_entitymatching</em> where the bug is found. Trying the bug-producing
code out on the <em>master</em> branch is often a worthwhile exercise to confirm the bug still
exists. It is also worth searching existing bug reports and pull requests to see if the
issue has already been reported and/or fixed.</p>
<p>Bug reports must:</p>
<ol class="arabic">
<li><p>Include a short, self-contained Python snippet reproducing the problem.
You can format the code nicely by using <a class="reference external" href="http://github.github.com/github-flavored-markdown/">GitHub Flavored Markdown</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```python
&gt;&gt;&gt; import py_entitymatching as em
&gt;&gt;&gt; em.down_sample(...)
...
```
</pre></div>
</div>
</li>
<li><p>Include the full version string of <em>py_entitymatching</em>. You can find the version as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">__version__</span>
</pre></div>
</div>
</li>
<li><p>Explain why the current behavior is wrong/not desired and what you expect instead.</p></li>
</ol>
<p>The issue will then show up to the <em>py_entitymatching</em> community and be open to
comments/ideas from others.</p>
</div>
<div class="section" id="working-with-the-code">
<h3><a class="toc-backref" href="#id4">Working with the code</a><a class="headerlink" href="#working-with-the-code" title="Permalink to this headline">¶</a></h3>
<p>Now that you have an issue you want to fix, enhancement to add, or documentation to
improve, you need to learn how to work with GitHub and the <em>py_entitymatching</em> code base.</p>
<div class="section" id="version-control-git-and-github">
<h4><a class="toc-backref" href="#id5">Version control, Git, and GitHub</a><a class="headerlink" href="#version-control-git-and-github" title="Permalink to this headline">¶</a></h4>
<p>To the new user, working with Git is one of the more daunting aspects of contributing
to <em>py_entitymatching</em>. It can very quickly become overwhelming, but sticking to the
guidelines below will help keep the process straightforward and mostly trouble free.
As always, if you are having difficulties please feel free to ask for help.</p>
<p>The code is hosted on <a class="reference external" href="https://www.github.com/anhaidgroup/py_entitymatching">GitHub</a>. To
contribute you will need to sign up for a <a class="reference external" href="https://github.com/signup/free">free GitHub account</a>. We use <a class="reference external" href="http://git-scm.com/">Git</a> for
version control to allow many people to work together on the project.</p>
<p>Some great resources for learning Git:</p>
<ul class="simple">
<li><p>the <a class="reference external" href="http://help.github.com/">GitHub help pages</a>.</p></li>
<li><p>the <a class="reference external" href="http://docs.scipy.org/doc/numpy/dev/index.html">NumPy’s documentation</a>.</p></li>
<li><p>Matthew Brett’s <a class="reference external" href="http://matthew-brett.github.com/pydagogue/">Pydagogue</a>.</p></li>
</ul>
</div>
<div class="section" id="getting-started-with-git">
<h4><a class="toc-backref" href="#id6">Getting started with Git</a><a class="headerlink" href="#getting-started-with-git" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://help.github.com/set-up-git-redirect">GitHub has instructions</a> for installing git,
setting up your SSH key, and configuring git.  All these steps need to be completed before
you can work seamlessly between your local repository and GitHub.</p>
</div>
<div class="section" id="forking">
<span id="contributing-forking"></span><h4><a class="toc-backref" href="#id7">Forking</a><a class="headerlink" href="#forking" title="Permalink to this headline">¶</a></h4>
<p>You will need your own fork to work on the code. Go to the <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching">py_entitymatching project
page</a> and hit the <code class="docutils literal notranslate"><span class="pre">Fork</span></code> button. You will
want to clone your fork to your machine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">your</span><span class="o">-</span><span class="n">user</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="o">&lt;</span><span class="n">local</span><span class="o">-</span><span class="n">repo</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
<span class="n">cd</span> <span class="o">&lt;</span><span class="n">local</span><span class="o">-</span><span class="n">repo</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
<span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">upstream</span> <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>This creates the directory <cite>local-repo-name</cite> and connects your repository to
the upstream (main project) <em>py_entitymatching</em> repository.</p>
<p>The testing suite will run automatically on Travis-CI once your pull request is
submitted.  However, if you wish to run the test suite on a branch prior to
submitting the pull request, then Travis-CI needs to be hooked up to your
GitHub repository.  Instructions for doing so are <a class="reference external" href="http://about.travis-ci.org/docs/user/getting-started/">here</a>.</p>
</div>
<div class="section" id="creating-a-branch">
<h4><a class="toc-backref" href="#id8">Creating a branch</a><a class="headerlink" href="#creating-a-branch" title="Permalink to this headline">¶</a></h4>
<p>You want your master branch to reflect only production-ready code, so create a
feature branch for making your changes. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">branch</span> <span class="n">new_feature</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>The above can be simplified to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>This changes your working directory to the <em>new_feature</em> branch.  Keep any
changes in this branch specific to one bug or feature so it is clear
what the branch brings to <em>py_entitymatching</em>. You can have many new features
and switch in between them using the git checkout command.</p>
<p>To update this branch, you need to retrieve the changes from the master branch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
<span class="n">git</span> <span class="n">rebase</span> <span class="n">upstream</span><span class="o">/</span><span class="n">master</span>
</pre></div>
</div>
<p>This will replay your commits on top of the lastest py_entitymatching git master.  If this
leads to merge conflicts, you must resolve them before submitting your pull
request.  If you have uncommitted changes, you will need to <code class="docutils literal notranslate"><span class="pre">stash</span></code> them prior
to updating.  This will effectively store your changes and they can be reapplied
after updating.</p>
</div>
<div class="section" id="creating-a-development-environment">
<span id="contributing-dev-env"></span><h4><a class="toc-backref" href="#id9">Creating a development environment</a><a class="headerlink" href="#creating-a-development-environment" title="Permalink to this headline">¶</a></h4>
<p>An easy way to create a <em>py_entitymatching</em> development environment is as follows.</p>
<ul class="simple">
<li><p>Install either <span class="xref std std-ref">Anaconda</span> or <span class="xref std std-ref">miniconda</span></p></li>
<li><p>Make sure that you have <a class="reference internal" href="#contributing-forking"><span class="std std-ref">cloned the repository</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cd</span></code> to the <em>py_entitymatching</em> source directory</p></li>
</ul>
<p>Tell conda to create a new environment, named <code class="docutils literal notranslate"><span class="pre">py_entitymatching_dev</span></code>, or any other
name you would like for this environment, by running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="o">--</span><span class="n">file</span> <span class="n">requirements</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>For a python 3 environment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">python</span><span class="o">=</span><span class="mi">3</span> <span class="o">--</span><span class="n">file</span> <span class="n">requirements</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>This will create the new environment, and not touch any of your existing environments,
nor any existing python installation. It will install all of the basic dependencies of
<em>py_entitymatching</em>. You need to install the <em>nose</em> package which is used for
testing, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">nose</span>
</pre></div>
</div>
<p>To work in this environment, Windows users should <code class="docutils literal notranslate"><span class="pre">activate</span></code> it as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">activate</span> <span class="n">py_entitymatching_dev</span>
</pre></div>
</div>
<p>Mac OSX / Linux users should use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="n">activate</span> <span class="n">py_entitymatching_dev</span>
</pre></div>
</div>
<p>You will then see a confirmation message to indicate you are in the new development environment.</p>
<p>To view your environments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">info</span> <span class="o">-</span><span class="n">e</span>
</pre></div>
</div>
<p>To return to your home root environment in Windows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deactivate</span>
</pre></div>
</div>
<p>To return to your home root environment in OSX / Linux:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="n">deactivate</span>
</pre></div>
</div>
<p>See the full conda docs <a class="reference external" href="http://conda.pydata.org/docs">here</a>.</p>
</div>
</div>
<div class="section" id="contributing-to-the-documentation">
<span id="contributing-documentation"></span><h3><a class="toc-backref" href="#id10">Contributing to the documentation</a><a class="headerlink" href="#contributing-to-the-documentation" title="Permalink to this headline">¶</a></h3>
<p>If you’re not the developer type, contributing to the documentation is still
of huge value. You don’t even have to be an expert on
<em>py_entitymatching</em> to do so! Something as simple as rewriting small passages for clarity
as you reference the docs is a simple but effective way to contribute. The
next person to read that passage will be in your debt!</p>
<p>In fact, there are sections of the docs that are worse off after being written
by experts. If something in the docs doesn’t make sense to you, updating the
relevant section after you figure it out is a simple way to ensure it will
help the next person.</p>
<div class="contents local topic" id="documentation">
<p class="topic-title">Documentation:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#about-the-py-entitymatching-documentation" id="id27">About the <em>py_entitymatching</em> documentation</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-the-py-entitymatching-documentation" id="id28">How to build the <em>py_entitymatching</em> documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#requirements" id="id29">Requirements</a></p></li>
<li><p><a class="reference internal" href="#building-the-documentation" id="id30">Building the documentation</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="about-the-py-entitymatching-documentation">
<h4><a class="toc-backref" href="#id27">About the <em>py_entitymatching</em> documentation</a><a class="headerlink" href="#about-the-py-entitymatching-documentation" title="Permalink to this headline">¶</a></h4>
<p>The documentation is written in <strong>reStructuredText</strong>, which is almost like writing
in plain English, and built using <a class="reference external" href="http://sphinx.pocoo.org/">Sphinx</a>. The
Sphinx Documentation has an excellent <a class="reference external" href="http://sphinx.pocoo.org/rest.html">introduction to reST</a>. Review the Sphinx docs to perform more
complex changes to the documentation as well.</p>
<p>Some other important things to know about the docs:</p>
<ul>
<li><p>The <em>py_entitymatching</em> documentation consists of two parts: the docstrings in the code
itself and the docs in this folder <code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/</span></code>.</p>
<p>The docstrings provide a clear explanation of the usage of the individual
functions, while the documentation in this folder consists of tutorial-like
overviews per topic together with some other information (what’s new,
installation, etc).</p>
</li>
<li><p>The docstrings follow the <strong>Google Docstring Standard</strong>. This standard specifies the format of
the different sections of the docstring. See <a class="reference external" href="http://www.sphinx-doc.org/en/stable/ext/example_google.html">this document</a>
for a detailed explanation, or look at some of the existing functions to
extend it in a similar manner.</p></li>
</ul>
</div>
<div class="section" id="how-to-build-the-py-entitymatching-documentation">
<h4><a class="toc-backref" href="#id28">How to build the <em>py_entitymatching</em> documentation</a><a class="headerlink" href="#how-to-build-the-py-entitymatching-documentation" title="Permalink to this headline">¶</a></h4>
<div class="section" id="requirements">
<h5><a class="toc-backref" href="#id29">Requirements</a><a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h5>
<p>To build the <em>py_entitymatching</em> docs there are some extra requirements: you will need to
have <code class="docutils literal notranslate"><span class="pre">sphinx</span></code> and <code class="docutils literal notranslate"><span class="pre">ipython</span></code> installed.</p>
<p>It is easiest to <a class="reference internal" href="#contributing-dev-env"><span class="std std-ref">create a development environment</span></a>, then install:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">py_entitymatching_dev</span> <span class="n">sphinx</span> <span class="n">sphinx_rtd_theme</span> <span class="n">ipython</span>
</pre></div>
</div>
</div>
<div class="section" id="building-the-documentation">
<h5><a class="toc-backref" href="#id30">Building the documentation</a><a class="headerlink" href="#building-the-documentation" title="Permalink to this headline">¶</a></h5>
<p>So how do you build the docs? Navigate to your local
<code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/</span></code> directory in the console and run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">html</span>
</pre></div>
</div>
<p>Then you can find the HTML output in the folder <code class="docutils literal notranslate"><span class="pre">py_entitymatching/docs/_build/html/</span></code>.</p>
<p>If you want to do a full clean build, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">clean</span> <span class="n">html</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="contributing-to-the-code-base">
<span id="contributing-dev-docs"></span><h3><a class="toc-backref" href="#id15">Contributing to the code base</a><a class="headerlink" href="#contributing-to-the-code-base" title="Permalink to this headline">¶</a></h3>
<div class="contents local topic" id="code-base">
<p class="topic-title">Code Base:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#code-standards" id="id31">Code standards</a></p></li>
<li><p><a class="reference internal" href="#writing-tests" id="id32">Writing tests</a></p>
<ul>
<li><p><a class="reference internal" href="#unit-testing" id="id33">Unit testing</a></p></li>
<li><p><a class="reference internal" href="#performance-testing" id="id34">Performance testing</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="code-standards">
<h4><a class="toc-backref" href="#id31">Code standards</a><a class="headerlink" href="#code-standards" title="Permalink to this headline">¶</a></h4>
<p><em>py_entitymatching</em> follows <a class="reference external" href="https://google.github.io/styleguide/pyguide.html">Google Python Style Guide</a>.</p>
<p>Please try to maintain backward compatibility. <em>py_entitymatching</em> has lots of users with lots of
existing code, so don’t break it if at all possible.  If you think breakage is required,
clearly state why as part of the pull request.  Also, be careful when changing method
signatures and add deprecation warnings where needed.</p>
</div>
<div class="section" id="writing-tests">
<h4><a class="toc-backref" href="#id32">Writing tests</a><a class="headerlink" href="#writing-tests" title="Permalink to this headline">¶</a></h4>
<p>Adding tests is one of the most common requests after code is pushed to <em>py_entitymatching</em>.  Therefore,
it is worth getting in the habit of writing tests ahead of time so this is never an issue.</p>
<div class="section" id="unit-testing">
<h5><a class="toc-backref" href="#id33">Unit testing</a><a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h5>
<p>Like many packages, <em>py_entitymatching</em> uses the <a class="reference external" href="http://nose.readthedocs.org/en/latest/index.html">Nose testing system</a>.</p>
<p>All tests should go into the <code class="docutils literal notranslate"><span class="pre">tests</span></code> subdirectory of the specific package.
This folder contains many current examples of tests, and we suggest looking to these for
inspiration.</p>
<p>The tests can then be run directly inside your Git clone (without having to
install <em>py_entitymatching</em>) by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nosetests</span>
</pre></div>
</div>
</div>
<div class="section" id="performance-testing">
<h5><a class="toc-backref" href="#id34">Performance testing</a><a class="headerlink" href="#performance-testing" title="Permalink to this headline">¶</a></h5>
<p>Performance matters and it is worth considering whether your code has introduced
performance regressions.  <em>py_entitymatching</em> uses
<a class="reference external" href="https://github.com/spacetelescope/asv">asv</a> for performance testing.
The benchmark test cases are all found in the <code class="docutils literal notranslate"><span class="pre">benchmarks/asv_benchmarks</span></code> directory.  asv
supports both python2 and python3.</p>
<p>To install asv:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">spacetelescope</span><span class="o">/</span><span class="n">asv</span>
</pre></div>
</div>
<p>If you need to run a benchmark, run the following from the <code class="docutils literal notranslate"><span class="pre">benchmarks</span></code> directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asv</span> <span class="n">run</span>
</pre></div>
</div>
<p>This command uses <code class="docutils literal notranslate"><span class="pre">conda</span></code> by default for creating the benchmark environments.</p>
<p>Information on how to write a benchmark and how to use asv can be found in the
<a class="reference external" href="http://asv.readthedocs.org/en/latest/writing_benchmarks.html">asv documentation</a>.</p>
</div>
</div>
</div>
<div class="section" id="contributing-your-changes-to-py-entitymatching">
<h3><a class="toc-backref" href="#id20">Contributing your changes to <em>py_entitymatching</em></a><a class="headerlink" href="#contributing-your-changes-to-py-entitymatching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="committing-your-code">
<h4><a class="toc-backref" href="#id21">Committing your code</a><a class="headerlink" href="#committing-your-code" title="Permalink to this headline">¶</a></h4>
<p>Finally, commit your changes to your local repository with an explanatory message.</p>
<p>The following defines how a commit message should be structured.  Please reference the
relevant GitHub issues in your commit message using GH1234 or #1234.  Either style
is fine, but the former is generally preferred:</p>
<blockquote>
<div><ul class="simple">
<li><p>a subject line with <cite>&lt; 80</cite> chars.</p></li>
<li><p>One blank line.</p></li>
<li><p>Optionally, a commit message body.</p></li>
</ul>
</div></blockquote>
<p>Now you can commit your changes in your local repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-commits">
<h4><a class="toc-backref" href="#id22">Combining commits</a><a class="headerlink" href="#combining-commits" title="Permalink to this headline">¶</a></h4>
<p>If you have multiple commits, you may want to combine them into one commit, often
referred to as “squashing” or “rebasing”.  This is a common request by package maintainers
when submitting a pull request as it maintains a more compact commit history.  To rebase
your commits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">rebase</span> <span class="o">-</span><span class="n">i</span> <span class="n">HEAD</span><span class="o">~</span><span class="c1">#</span>
</pre></div>
</div>
<p>Where # is the number of commits you want to combine.  Then you can pick the relevant
commit message and discard others.</p>
<p>To squash to the master branch do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">rebase</span> <span class="o">-</span><span class="n">i</span> <span class="n">master</span>
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">s</span></code> option on a commit to <code class="docutils literal notranslate"><span class="pre">squash</span></code>, meaning to keep the commit messages,
or <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">fixup</span></code>, meaning to merge the commit messages.</p>
<p>Then you will need to push the branch (see below) forcefully to replace the current
commits with the new ones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">new_feature</span> <span class="o">-</span><span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="pushing-your-changes">
<h4><a class="toc-backref" href="#id23">Pushing your changes</a><a class="headerlink" href="#pushing-your-changes" title="Permalink to this headline">¶</a></h4>
<p>When you want your changes to appear publicly on your GitHub page, push your
forked feature branch’s commits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">origin</span></code> is the default name given to your remote repository on GitHub.
You can see the remote repositories:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">remote</span> <span class="o">-</span><span class="n">v</span>
</pre></div>
</div>
<p>If you added the upstream repository as described above you will see something
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">origin</span>  <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">yourname</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
<span class="n">origin</span>  <span class="n">git</span><span class="nd">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="o">&lt;</span><span class="n">yourname</span><span class="o">&gt;/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
<span class="n">upstream</span>        <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
<span class="n">upstream</span>        <span class="n">git</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">anhaidgroup</span><span class="o">/</span><span class="n">py_entitymatching</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</pre></div>
</div>
<p>Now your code is on GitHub, but it is not yet a part of the <em>py_entitymatching</em> project.  For that to
happen, a pull request needs to be submitted on GitHub.</p>
</div>
<div class="section" id="review-your-code">
<h4><a class="toc-backref" href="#id24">Review your code</a><a class="headerlink" href="#review-your-code" title="Permalink to this headline">¶</a></h4>
<p>When you’re ready to ask for a code review, file a pull request. Before you do, once
again make sure that you have followed all the guidelines outlined in this document
regarding code style, tests, performance tests, and documentation. You should also
double check your branch changes against the branch it was based on:</p>
<ol class="arabic simple">
<li><p>Navigate to your repository on GitHub – <a class="reference external" href="https://github.com">https://github.com</a>/&lt;your-user-name&gt;/py_entitymatching</p></li>
<li><p>Click on <code class="docutils literal notranslate"><span class="pre">Branches</span></code></p></li>
<li><p>Click on the <code class="docutils literal notranslate"><span class="pre">Compare</span></code> button for your feature branch</p></li>
<li><p>Select the <code class="docutils literal notranslate"><span class="pre">base</span></code> and <code class="docutils literal notranslate"><span class="pre">compare</span></code> branches, if necessary. This will be <code class="docutils literal notranslate"><span class="pre">master</span></code> and
<code class="docutils literal notranslate"><span class="pre">new_feature</span></code>, respectively.</p></li>
</ol>
</div>
<div class="section" id="finally-make-the-pull-request">
<h4><a class="toc-backref" href="#id25">Finally, make the pull request</a><a class="headerlink" href="#finally-make-the-pull-request" title="Permalink to this headline">¶</a></h4>
<p>If everything looks good, you are ready to make a pull request.  A pull request is how
code from a local repository becomes available to the GitHub community and can be looked
at and eventually merged into the master version.  This pull request and its associated
changes will eventually be committed to the master branch and available in the next
release.  To submit a pull request:</p>
<ol class="arabic simple">
<li><p>Navigate to your repository on GitHub</p></li>
<li><p>Click on the <code class="docutils literal notranslate"><span class="pre">Pull</span> <span class="pre">Request</span></code> button</p></li>
<li><p>You can then click on <code class="docutils literal notranslate"><span class="pre">Commits</span></code> and <code class="docutils literal notranslate"><span class="pre">Files</span> <span class="pre">Changed</span></code> to make sure everything looks
okay one last time</p></li>
<li><p>Write a description of your changes.</p></li>
<li><p>Click <code class="docutils literal notranslate"><span class="pre">Send</span> <span class="pre">Pull</span> <span class="pre">Request</span></code>.</p></li>
</ol>
<p>This request then goes to the repository maintainers, and they will review
the code. If you need to make more changes, you can make them in
your branch, push them to GitHub, and the pull request will be automatically
updated.  Pushing them to GitHub again is done by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="o">-</span><span class="n">f</span> <span class="n">origin</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>This will automatically update your pull request with the latest code and restart the
Travis-CI tests.</p>
</div>
<div class="section" id="delete-your-merged-branch-optional">
<h4><a class="toc-backref" href="#id26">Delete your merged branch (optional)</a><a class="headerlink" href="#delete-your-merged-branch-optional" title="Permalink to this headline">¶</a></h4>
<p>Once your feature branch is accepted into upstream, you’ll probably want to get rid of
the branch. First, merge upstream master into your branch so git knows it is safe to
delete your branch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">fetch</span> <span class="n">upstream</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">master</span>
<span class="n">git</span> <span class="n">merge</span> <span class="n">upstream</span><span class="o">/</span><span class="n">master</span>
</pre></div>
</div>
<p>Then you can just do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">new_feature</span>
</pre></div>
</div>
<p>Make sure you use a lower-case <code class="docutils literal notranslate"><span class="pre">-d</span></code>, or else git won’t warn you if your feature
branch has not actually been merged.</p>
<p>The branch will still exist on GitHub, so to delete it there do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">new_feature</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016, anhaidgroup

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>